<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.1.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>JVM面试大纲 - 灰色と青</title>

  
    <meta name="description" content="JVM面试大纲JVM 类加载的整体流程 通过一个类的全限定名来获取定义此类的二进制字节流。(初次获取Class文件字节流)  —加载 loader.findClass() Class文件验证            —链接 –验证—文件格式验证 将这个字节流所代表的**静态存储(class文件本身)**结构转化为方法区的运行时数据结构。 – 加载 在Java堆里面生成这个类的java.lang.Cl">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM面试大纲">
<meta property="og:url" content="http://example.com/2022/03/28/JVM%E9%9D%A2%E8%AF%95%E5%A4%A7%E7%BA%B2/index.html">
<meta property="og:site_name" content="灰色と青">
<meta property="og:description" content="JVM面试大纲JVM 类加载的整体流程 通过一个类的全限定名来获取定义此类的二进制字节流。(初次获取Class文件字节流)  —加载 loader.findClass() Class文件验证            —链接 –验证—文件格式验证 将这个字节流所代表的**静态存储(class文件本身)**结构转化为方法区的运行时数据结构。 – 加载 在Java堆里面生成这个类的java.lang.Cl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203281801537.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282044338.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282049654.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282057356.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282106139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282131886.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282253667.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282257462.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282303272.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282353093.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282355988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282356934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291751151.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291801259.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291854073.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291911230.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291912776.png">
<meta property="og:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291930936.png">
<meta property="article:published_time" content="2022-03-28T09:50:14.000Z">
<meta property="article:modified_time" content="2022-03-29T11:45:36.725Z">
<meta property="article:author" content="sean">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203281801537.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="灰色と青" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/header.jpg" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">灰色と青</div><div class="sub cap">Eurekawm's Blog</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/notes/">笔记</a><a class="nav-item" href="/more/">更多</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">JVM 类加载的整体流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5JVM%E5%85%B7%E4%BD%93%E5%81%9A%E7%9A%84%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="toc-text">加载阶段JVM具体做的什么操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">加载数据和加载类有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">验证阶段做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%9C%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">JVM在准备阶段做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%9C%A8%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">JVM在解析阶段做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">类加载的初始化阶段做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99JVM%E7%AB%8B%E5%8D%B3%E4%BC%9A%E5%AF%B9%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-text">什么时候JVM立即会对类进行初始化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%89%8D%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84"><span class="toc-text">什么情况下一个类才是相同的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc-text">运行时栈结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">什么是局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%8F%98%E9%87%8F%E7%9A%84-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%AE%9E%E5%8F%82%E5%88%B0%E5%BD%A2%E5%8F%82%E4%BC%A0%E9%80%92%E7%9A%84"><span class="toc-text">栈帧的局部变量表是如何定位变量的?是如何完成实参到形参传递的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%88%E5%B8%A7%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-text">说说栈帧中的操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">栈帧中的动态链接和返回地址有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-text">JVM运行时数据区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">什么是程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BB%E8%A6%81%E6%98%AF%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-text">方法区主要是存储什么数据的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8CClass%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">运行时常量池和Class的文件结构的常量池有什么区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">什么是直接内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%8BJVM%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">说说下JVM堆内存中对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E4%BD%8DJvm%EF%BC%8Cnew-Object-%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9C%A8Java%E4%B8%AD%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98"><span class="toc-text">64位Jvm，new Object()新创建的对象在Java中占用多少内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E7%9A%84"><span class="toc-text">对象是如何定位的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="toc-text">JVM如何判断对象是否存活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGC-Roots"><span class="toc-text">什么是GC Roots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">Java中的那些引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E6%97%B6%E5%80%99JVM%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%9B%9E%E6%94%B6%E5%90%97"><span class="toc-text">对象不可达的时候JVM会立即回收吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97"><span class="toc-text">方法区有垃圾回收吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%A9%E5%BC%8A"><span class="toc-text">几种垃圾回收算法和利弊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E8%8A%82%E7%82%B9%E6%9E%9A%E4%B8%BE%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97"><span class="toc-text">根节点枚举有了解过吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJVM%E7%9A%84%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-text">什么是JVM的安全点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%8F%91%E7%94%9F%E6%97%B6%E8%AE%A9%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E9%83%BD%E8%B7%91%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-text">如何在垃圾收集发生时让所有线程都跑到最近的安全点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E2%80%9C%E4%B8%8D%E6%89%A7%E8%A1%8C%E2%80%9D%E7%9A%84%E6%97%B6%E5%80%99%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BE%BE%E5%88%B0%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-text">程序“不执行”的时候线程如何达到安全点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-text">垃圾回收是如何处理跨代引用问题的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%90%86%E8%AE%BA"><span class="toc-text">说说垃圾回收器的三色标记理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">说说你所知道的垃圾回收器的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Serial%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">说说Serial收集器的特点及使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84"><span class="toc-text">ParNew收集器是如何进行垃圾回收的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paralle-Scavenge%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">Paralle Scavenge垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">说说Serial Old收集器的特点及使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">说说Parallel Old收集器的特点及使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4CMS%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">说说CMS收集器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%E5%90%97"><span class="toc-text">CMS收集器有什么缺点吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-text">说说你对 G1 垃圾回收器的了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%BB%BA%E7%AB%8B%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9E%8B"><span class="toc-text">G1收集器为什么能够建立可预测的停顿时间模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%94%B6%E9%9B%86%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%BA%92%E4%B8%8D%E5%B9%B2%E6%89%B0%E5%9C%B0%E8%BF%90"><span class="toc-text">在并发标记阶段如何保证收集线程与用户线程互不干扰地运</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%9B%9E%E6%94%B6%E6%AD%A5%E9%AA%A4"><span class="toc-text">G1收集器回收步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">JVM堆内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%88%86%E9%85%8D%E5%88%B0%E8%80%81%E5%B9%B4%E4%BB%A3%E5%90%97"><span class="toc-text">新创建的对象可能直接分配到老年代吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E5%AD%98%E6%94%BE%E7%9A%84%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%AF%B9%E8%B1%A1"><span class="toc-text">老年代存放的都是什么对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B9%B4%E9%BE%84%E5%BF%85%E9%A1%BB%E8%BE%BE%E5%88%B0-XX-MaxTenuringThreshold%E6%89%8D%E8%83%BD%E6%99%8B%E5%8D%87%E8%80%81%E5%B9%B4-%E4%BB%A3%E5%90%97-%E7%BB%9D%E5%AF%B9%E5%90%97"><span class="toc-text">JVM中对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年 代吗?绝对吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-text">什么是空间分配担保</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-text">什么是内存泄漏，与内存溢出有什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%AF%B9%E8%B1%A1%E9%80%83%E9%80%B8-%E5%AF%B9%E8%B1%A1%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96"><span class="toc-text">什么对象逃逸 对象逃逸分析优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">JVM调优经验</span></a></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Java/">Java</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-03-28T09:50:14.000Z">2022-03-28</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>JVM面试大纲</span></h1>
<h1 id="JVM面试大纲"><a href="#JVM面试大纲" class="headerlink" title="JVM面试大纲"></a>JVM面试大纲</h1><h3 id="JVM-类加载的整体流程"><a href="#JVM-类加载的整体流程" class="headerlink" title="JVM 类加载的整体流程"></a>JVM 类加载的整体流程</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。(初次获取Class文件字节流)  —加载 loader.findClass()</li>
<li>Class文件验证            —链接 –验证—文件格式验证</li>
<li>将这个字节流所代表的**静态存储(class文件本身)**结构转化为方法区的运行时数据结构。 – 加载</li>
<li>在Java堆里面生成这个类的java.lang.Class对象 作为方法区这个类的各种数据的访问入口 – 加载</li>
<li>元数据验证      <strong>– 链接-验证-元数据验证</strong></li>
<li>字节码验证   <strong>– 链接-验证-元数据验证</strong></li>
<li>准备              – 链接-准备</li>
<li>解析              链接–解析 符号引用-</li>
<li>初始化       – 初始化 <cinit></li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203281801537.png" alt="image-20220328180131499"></p>
<h3 id="加载阶段JVM具体做的什么操作"><a href="#加载阶段JVM具体做的什么操作" class="headerlink" title="加载阶段JVM具体做的什么操作"></a>加载阶段JVM具体做的什么操作</h3><p>“加载”是类加载的一个最初始的阶段，在加载阶段JVM需要完成以下三件事情：</p>
<ol>
<li>根据一个全限定类名来获取这个类的二进制流数据（初次获取Class文件字节流）</li>
<li>把这个字节流所代表的静态存储（class文件本身）转为方法区的运行时数据结构</li>
<li>在Java堆里面生成一个java.lang.Class，作为方法去这个类的各种数据的访问入口 比如Method。</li>
</ol>
<p>一般我们弄接触到的就是获取类的二进制流数据，开发人员自己写类加载器重写一下findClass() loadClass()自定义获取二进制流的行为</p>
<h3 id="加载数据和加载类有什么区别"><a href="#加载数据和加载类有什么区别" class="headerlink" title="加载数据和加载类有什么区别"></a>加载数据和加载类有什么区别</h3><p>对于数据而言，数据本身不是通过类加载器来创建的，而是在内存中动态构造出来的，但是数据的元素类型是需要类加载器来完成的，一个数据类创建过程遵循以下规则：</p>
<ol>
<li>如果数组的元素是引用类型的，那就先遵循类加载过程去加载这个组件，然后数据C将会被标志在加载该组件的类型的类加载器的类名称空间上（一个类型必须与类加载器一起确定唯一性）</li>
<li>如果数组的组件类型不是引用类型的，比如int[]，那么JVM会把数组C标记为与引导类加载器关联</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访 问性将默认为public，可被所有的类和接口访问到。</li>
</ol>
<h3 id="验证阶段做了什么"><a href="#验证阶段做了什么" class="headerlink" title="验证阶段做了什么"></a>验证阶段做了什么</h3><p>验证是链接的第一步，这一步的目的是保障Class文件的字节流中包含的信息符合JVM规范，保障这些信息不会危害JVM。</p>
<p>验证阶段是很重要的，决定了JVM会不会收到恶意代码的攻击，从代码量和耗时的执行性能角度上讲，这一阶段在类加载过程中是相对比较耗时</p>
<p>从整体来看验证阶段是以下四个检验动作</p>
<ol>
<li><p>文件格式验证：要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能 包括下面这些验证点。</p>
<ol>
<li>以魔数0xCAFEBABE开头。 </li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内。 ·常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 </li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
</ol>
<p>这个阶段是保证了二进制流是可以进入JVM内部去存储的，后面三个验证阶段是基于方法区的存储结构上进行的，不会再读取操作字节流了。</p>
</li>
<li><p>元数据验证：对字节码进行语义分析，保障他的描述信息符合《Java语言规范》的要求，比如这个类是否有父类（所有类应该都有父类），这个类是否继承了不应该被继承的父类等等，一句话说就是这个类是否是一个语义正确的类</p>
</li>
<li><p>字节码验证：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合 法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体**(Class文 件中的Code属性)进行校验分析**，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。比如操作数栈上面不能放一个long</p>
</li>
<li><p>符号引用验证： 把符号引用转位直接引用的时候，是在解析阶段中发生，符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下<br>列内容:</p>
<ol>
<li>符号引用通过字符串描述的全限定类名能否找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
</ol>
</li>
</ol>
<p>符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一 个java.lang.IncompatibleClassChangeError的子类异常，典型的如:java.lang.IllegalAccessError、 java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<h3 id="JVM在准备阶段做了什么"><a href="#JVM在准备阶段做了什么" class="headerlink" title="JVM在准备阶段做了什么"></a>JVM在准备阶段做了什么</h3><p>将类变量也就是静态变量赋初始值，初始值就是类型的零值比如int的的零值是0，boolean的零值是false。final变量是在编译期就确定了的。</p>
<h3 id="JVM在解析阶段做了什么"><a href="#JVM在解析阶段做了什么" class="headerlink" title="JVM在解析阶段做了什么"></a>JVM在解析阶段做了什么</h3><p>解析就是把JVM常量池中符号引用替换为直接引用的过程</p>
<p><strong>符号引用</strong>(Symbolic References):符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面 量，只要使用时能无歧义地定位到目标即可。<br> <strong>直接引用</strong>(Direct References):直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位 到目标的句柄。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
<h3 id="类加载的初始化阶段做了什么"><a href="#类加载的初始化阶段做了什么" class="headerlink" title="类加载的初始化阶段做了什么"></a>类加载的初始化阶段做了什么</h3><p>初始化是类加载的最后一个阶段，之前介绍的几个类加载的动作里，除了在加载阶段用户 应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p>
<p>在准备阶段，类变量已经有一次初始赋值了，在初始化阶段，JVM收集静态变量的赋值动作，然后进行一次赋值，内容就是我们代码中的想赋予的值。这是由<cinit> 完成的，这是一个类构造器，他是自动生成的。</p>
<h3 id="什么时候JVM立即会对类进行初始化操作"><a href="#什么时候JVM立即会对类进行初始化操作" class="headerlink" title="什么时候JVM立即会对类进行初始化操作"></a>什么时候JVM立即会对类进行初始化操作</h3><ol>
<li>遇到了new getstatic putstatic invokestatic这几个字节码操作的时候，且没有加载类<ul>
<li>new 创建对象</li>
<li>获取设置一个静态变量</li>
<li>调用静态方法</li>
</ul>
</li>
<li>使用反射调用的时候java.lang.reflect，如果类没初始化，那么要先加载</li>
<li>虚拟机启动的时候加载一些默认的类</li>
<li>初始化类的时候发现父类还没初始化，优先初始化父类</li>
<li>一个接口定义了JDK8 的默认方法，如果这个类接口的实现类发生了初始化，那么接口要在之前初始化</li>
</ol>
<h3 id="什么情况下一个类才是相同的"><a href="#什么情况下一个类才是相同的" class="headerlink" title="什么情况下一个类才是相同的"></a>什么情况下一个类才是相同的</h3><p><strong>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共 同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个 独立的类名称空间。这句话可以表达得更通俗一些:比较两个类是 否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有 意义，否则，即使这两个类来源于同一个Class文件，被同一个 Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必 定不相等。</strong></p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>启动类加载器(Bootstrap Class Loader):这个类加载器负责加载存放在 <JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的， 而且是Java虚拟机能够识别的(按照文件名识别，如rt.jar、tools.jar，名字不符 合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机的内存中。启动 类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要 把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</p>
<p>扩展类加载器(Extension Class Loader):这个类加载器是在类 sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载 <JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所 有的类库。</p>
<p>应用程序类加载器(Application Class Loader):这个类加载器由 sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是 ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也 称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库， 开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义 过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>除了引导类加载器，其他加载器都是有父类，他们的关系是组合而不是继承。</p>
<p>双亲委派机制的工作流程：一个类加载器收到加载请求，他自己不会加载这个类，而是交给父类加载器去。每层加载都是如此，直到把加载请求传递到顶级也就是系统类加载器。只有当父类无法加载的时候这个加载请求(它的搜索范围中没有找到所 需的类)时，子加载器才会尝试自己去完成加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。(<strong>翻看上一题 190, 想要确定一个加载一个类的唯一性，是需要由类加载器和类共同验证才能生 效的。</strong>)</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282044338.png" alt="image-20220328204450296"></p>
<h3 id="运行时栈结构"><a href="#运行时栈结构" class="headerlink" title="运行时栈结构"></a>运行时栈结构</h3><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”(Stack Frame)则是用 于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运 行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储 了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一 个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面 从入栈到出栈的过程。</p>
<p>在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的 操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。 换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的 影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>
<p>对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的， 只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”(Current Stack Frame)，与这个栈帧所关联的方法被称为“当前方法”(Current Method)。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操 作。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282049654.png" alt="image-20220328204933615"></p>
<h3 id="什么是局部变量表"><a href="#什么是局部变量表" class="headerlink" title="什么是局部变量表"></a>什么是局部变量表</h3><p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。 在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量 表的最大容量。</p>
<p>局部变量表的容量以变量槽(Variable Slot)为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应 占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、byte、char、short、int、 float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储，但这 种描述与明确指出“每个变量槽应占用32位长度的内存空间”是有本质差别的，它允许变量槽的长度可以随着处理 器、操作系统或虚拟机实现的不同而发生变化。</p>
<p>对于64位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java语言中明确的64位 的数据类型只有long和double两种。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两 个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282057356.png" alt="image-20220328205727324"></p>
<h3 id="栈帧的局部变量表是如何定位变量的-是如何完成实参到形参传递的"><a href="#栈帧的局部变量表是如何定位变量的-是如何完成实参到形参传递的" class="headerlink" title="栈帧的局部变量表是如何定位变量的?是如何完成实参到形参传递的?"></a><strong>栈帧的局部变量表是如何定位变量的?是如何完成实参到形参传递的?</strong></h3><p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如 果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说 明会同时使用第N和N+1两个变量槽。对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用 任何方式单独访问其中的某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟 机就应该在类加载的校验阶段中抛出异常。</p>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的 传递。如果执行的是实例方法(没有被static修饰的方法)，那局部变量表中第0位索引的变量槽默认是用于传递 方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序 排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 变量槽。</p>
<h3 id="说说栈帧中的操作数栈"><a href="#说说栈帧中的操作数栈" class="headerlink" title="说说栈帧中的操作数栈"></a><strong>说说栈帧中的操作数栈</strong></h3><p>操作数栈(Operand Stack)也常被称为操作栈，它是一个后入先出(Last In First Out，LIFO)栈。同局部变 量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每 一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类 型所占的栈容量为2。</p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令 往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作 数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传 递。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个 元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新 入栈。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282106139.png" alt="image-20220328210644102"></p>
<h3 id="栈帧中的动态链接和返回地址有什么作用"><a href="#栈帧中的动态链接和返回地址有什么作用" class="headerlink" title="栈帧中的动态链接和返回地址有什么作用"></a><strong>栈帧中的动态链接和返回地址有什么作用</strong></h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段 或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在<strong>每一次运行期间都转化为直接引用，这部分就称为动态连接</strong>。</p>
<p>当一个方法开始执行后，只有两种方式退出这个方法。一个是正常退出，另外一个是异常退出。无论 采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行， 方法返回时<strong>可能需要</strong>在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说， 方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。 而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有:恢复上层方法的局部 变量表和操作数栈，把返回值(如果有的话)压入调用者栈帧的操作数栈中，调整PC计数器的值以指 向方法调用指令后面的一条指令等。</p>
<h3 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282131886.png" alt="image-20220328213132846"></p>
<h3 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h3><p>PCR(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执 行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这 个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、 跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何 一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指 令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数 器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，<strong>这个计数器记录的是正在执行的虚拟机字节码指令的地 址</strong>;如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。此内存区 域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="方法区主要是存储什么数据的"><a href="#方法区主要是存储什么数据的" class="headerlink" title="方法区主要是存储什么数据的"></a><strong>方法区主要是存储什么数据的</strong></h3><p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开 发、部署程序，很多人都更愿意把方法区称呼为“永久代”(Permanent Generation)，或将两者混为一谈。本质上 这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说 使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门 为方法区编写内存管理代码的工作。</p>
<p>到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来 代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。</p>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者 可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非 数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型 的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的 回收有时又确实是必要的。</p>
<h3 id="运行时常量池和Class的文件结构的常量池有什么区别和联系"><a href="#运行时常量池和Class的文件结构的常量池有什么区别和联系" class="headerlink" title="运行时常量池和Class的文件结构的常量池有什么区别和联系"></a>运行时常量池和Class的文件结构的常量池有什么区别和联系</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接 口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间 也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OOM异常。</p>
<h3 id="什么是直接内存"><a href="#什么是直接内存" class="headerlink" title="什么是直接内存"></a>什么是直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地 使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>在JDK 1.4中新加入了NIO(New Input&#x2F;Output)类，引入了一种基于通 道(Channel)与缓冲区(Buffer)的I&#x2F;O方式，它可以使用Native函数库 直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。</p>
<h3 id="说说下JVM堆内存中对象的内存布局"><a href="#说说下JVM堆内存中对象的内存布局" class="headerlink" title="说说下JVM堆内存中对象的内存布局"></a>说说下JVM堆内存中对象的内存布局</h3><p>三大数据区域：</p>
<ol>
<li>对象头</li>
<li>实例数据</li>
<li>对其填充</li>
</ol>
<p>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码 (HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在 32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它为“Mark Word”。对象需要存 储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自 身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结 构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟 机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4 个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。对象头的另外一部分是类型指针， 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内 容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到 虚拟机分配策略参数(-XX:FieldsAllocationStyle参数)和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops (Ordinary Object Pointers，OOPs)，从以上默认的分配策略中可以看到，相同宽度的字段总是被分 配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot 虚拟机的+XX:CompactFields参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类 变量的空隙之中，以节省出一点点空间。</p>
<p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何 对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者2 倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h3 id="64位Jvm，new-Object-新创建的对象在Java中占用多少内存"><a href="#64位Jvm，new-Object-新创建的对象在Java中占用多少内存" class="headerlink" title="64位Jvm，new Object()新创建的对象在Java中占用多少内存"></a>64位Jvm，new Object()新创建的对象在Java中占用多少内存</h3><p>markword 8 字节，因为 java 默认使用了calssPointer 压缩，classpointer 4 字节，对象实例0字节， padding 4 字节 因此是 16 字节 如果没开启 classpointer 默认压缩，markword 8 字节，classpointer 8 字节，对象实例0字节，padding 0 字节 也是 16 字节。</p>
<h3 id="对象是如何定位的"><a href="#对象是如何定位的" class="headerlink" title="对象是如何定位的"></a>对象是如何定位的</h3><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由 于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过 什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式 主要有使用句柄和直接指针两种。</p>
<p>如果使用<strong>句柄访问</strong>的话， Java堆中将可能会划分 出一块内存来作为句柄 池，reference中存储的 就是对象的句柄地址， 而句柄中包含了对象实 例数据与类型数据各自 具体的地址信息</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282253667.png" alt="image-20220328225345585"></p>
<p>如果使用直接指针访问 的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的 相关信息，reference中 存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282257462.png" alt="image-20220328225739429"></p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象 被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需 要被修改。</p>
<p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中 非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就虚拟机HotSpot而言，它主要使用第二种 方式进行对象访问。</p>
<h3 id="JVM如何判断对象是否存活"><a href="#JVM如何判断对象是否存活" class="headerlink" title="JVM如何判断对象是否存活"></a>JVM如何判断对象是否存活</h3><p>可达性分析算法</p>
<p>这个算法的基本思路就是通过 一系列称为“GC Roots”的根对 象作为起始节点集，从这些节点开始，根据引用关系向下搜 索，搜索过程所走过的路径称 为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282303272.png" alt="image-20220328230353232"></p>
<h3 id="什么是GC-Roots"><a href="#什么是GC-Roots" class="headerlink" title="什么是GC Roots"></a>什么是GC Roots</h3><ul>
<li>在虚拟机<strong>栈</strong>(栈帧中的本地变量表)<strong>中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用 到的参数、局部变量、临时变量等。</li>
<li>在<strong>方法区中类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</li>
<li>在<strong>方法区中常量引用的对象</strong>，譬如字符串常量池(String Table)里的引用。</li>
<li>在<strong>本地方法栈中JNI</strong>(即通常所说的Native方法)<strong>引用的对象</strong>。</li>
<li><strong>Java虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象(比如 NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器</li>
<li>所有被同步<strong>锁</strong>(synchronized关键字)<strong>持有的对象</strong></li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<h3 id="Java中的那些引用类型"><a href="#Java中的那些引用类型" class="headerlink" title="Java中的那些引用类型"></a>Java中的那些引用类型</h3><p>强软弱虚</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的 对象。 </li>
<li>·<strong>软引用</strong>是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常 前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出 异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 </li>
<li>·<strong>弱引用</strong>也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下 一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对 象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 ·</li>
<li><strong>虚引用</strong>也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全 不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目 的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来 实现虚引用。</li>
</ul>
<h3 id="对象不可达的时候JVM会立即回收吗"><a href="#对象不可达的时候JVM会立即回收吗" class="headerlink" title="对象不可达的时候JVM会立即回收吗"></a>对象不可达的时候JVM会立即回收吗</h3><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段， 要真正宣告一个对象死亡，至少要经历两次标记过程:</p>
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之 中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>
<p>如果不重写 说明这个对象已经寄了没挽回的余地 然后就让jvm清除</p>
<p>唯一挽回的余地就是重写的方法内部 让他重新被引用，然而这种挽回有且只有一次</p>
<h3 id="方法区有垃圾回收吗"><a href="#方法区有垃圾回收吗" class="headerlink" title="方法区有垃圾回收吗"></a>方法区有垃圾回收吗</h3><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，方法区垃圾收 集的“性价比”通常也是比较低的:在Java堆中，尤其是在新生代中，对常规应用进行一次 垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条 件，其区域垃圾收集的回收成果往往远低于此。</p>
<p> 方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型。</p>
<h3 id="几种垃圾回收算法和利弊"><a href="#几种垃圾回收算法和利弊" class="headerlink" title="几种垃圾回收算法和利弊"></a>几种垃圾回收算法和利弊</h3><ol>
<li><p>标记-清除算法</p>
<p>算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。 最基础的收集算法，是因为后续的收集算法大多 都是以标记-清除算法为基础，对其缺点进行改 进而得到的。它的主要缺点有两个:第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程 的执行效率都随对象数量增长而降低;第二个是内存空间的碎片化问题，标记、清除之后会产生 大量不连续的内存碎片，空间碎片太多可能会导 致当以后在程序运行过程中需要分配较大对象时 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282353093.png" alt="image-20220328235347049"></p>
</li>
<li><p>标记-复制算法</p>
<p>常被简称为复制算法。为了解决标记-清除 算法面对大量可回收对象时执行效率低的 问题，1969年Fenichel提出了一种称为“半 区复制”(Semispace Copying)的垃圾收集 算法，它将可用内存按容量划分为大小相 等的两块，每次只使用其中的一块。当这 一块的内存用完了，就将还存活着的对象 复制到另外一块上面，然后再把已使用过 的内存空间一次清理掉。如果内存中多数 对象都是存活的，这种算法将会产生大量 的内存间复制的开销，但对于多数对象都 是可回收的情况，算法需要复制的就是占 少数的存活对象，而且每次都是针对整个 半区进行内存回收，分配内存时也就不用 考虑有空间碎片的复杂情况，只要移动堆 顶指针，按顺序分配即可。这样实现简单， 运行高效，不过其缺陷也显而易见，这种 复制回收算法的代价是将可用内存缩小为 了原来的一半，空间浪费未免太多了一点。</p>
<p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公 司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代 中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生 代的内存空间。</p>
<p>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化 的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、 ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel式 回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空 间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden 和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接 清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor 的大小比例是8∶1</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282355988.png" alt="image-20220328235504943"></p>
</li>
<li><p>标记-整理算法</p>
<p>标记-复制算法在对象存活率 较高时就要进行较多的复制操作，效率将会降低。更关键的 是，如果不想浪费50%的空间， 就需要有额外的空间进行分配 担保，以应对被使用的内存中 所有对象都100%存活的极端情 况，所以在老年代一般不能直 接选用这种算法。</p>
<p>针对老年代对象的存亡特征， 1974年Edward Lueders提出了另外一种有针对性的“标记-整理”(Mark-Compact)算法， 其中的标记过程仍然与“标记- 清除”算法一样，但后续步骤 不是直接对可回收对象进行清理，而是让所有存活的对象都 向内存空间一端移动，然后直 接清理掉边界以外的内存</p>
<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282356934.png" alt="image-20220328235637888"></p>
</li>
</ol>
<h3 id="根节点枚举有了解过吗"><a href="#根节点枚举有了解过吗" class="headerlink" title="根节点枚举有了解过吗?"></a><strong>根节点枚举有了解过吗?</strong></h3><p>根节点枚举：就是找出所有的GC Roots 也就是STW</p>
<p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能<strong>保障一致性的快照</strong>中才得以进 行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中， 根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致 垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者(几乎)不会发生停顿 的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。</p>
<p>由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检 查完所有执行上下文和全局的引用位置，虚拟机是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决 方案里，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的。一旦类加载动作完成的时候，<strong>HotSpot就会把对象 内什么偏移量上是什么类型的数据计算出来</strong>，<strong>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位 置是引用</strong>。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查 找。</p>
<h3 id="什么是JVM的安全点"><a href="#什么是JVM的安全点" class="headerlink" title="什么是JVM的安全点"></a><strong>什么是JVM的安全点</strong></h3><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来:可能导致引用关 系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的 额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</p>
<p>实际上HotSpot也的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置被称为安全 点(Safepoint)。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开 始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待 时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。<strong>安全点位置的选取基本上是以“是否具有让程序长时 间执行的特征”为标准进行选定的</strong>，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的 原因而长时间执行，<strong>“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于 指令序列复用，所以只有具有这些功能的指令才会产生安全点。</strong></p>
<h3 id="如何在垃圾收集发生时让所有线程都跑到最近的安全点"><a href="#如何在垃圾收集发生时让所有线程都跑到最近的安全点" class="headerlink" title="如何在垃圾收集发生时让所有线程都跑到最近的安全点"></a>如何在垃圾收集发生时让所有线程都跑到最近的安全点</h3><p>有两种方案可供选择:<strong>抢先式中断(Preemptive Suspension)<strong>和</strong>主动式中断(Voluntary Suspension)<strong>，</strong>抢先 式中断</strong>不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有 用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在<strong>几乎 没有虚拟机</strong>实现<strong>采用抢先式中断来</strong>暂停线程响应GC事件。</p>
<p>而<strong>主动式中断</strong>的思想是当垃圾收集需要中断线程的时候，<strong>不直接对线程操作，仅仅简单地设置一个标志位</strong>，各个 <strong>线程</strong>执行过程时会不停地主动去轮询这个标志，一旦<strong>发现中断标志为真时就自己在最近的安全点上主动中断挂起</strong>。 <strong>轮询标志的地方和安全点是重合的</strong>，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为 了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p>
<h3 id="程序“不执行”的时候线程如何达到安全点"><a href="#程序“不执行”的时候线程如何达到安全点" class="headerlink" title="程序“不执行”的时候线程如何达到安全点?"></a><strong>程序“不执行”的时候线程如何达到安全点?</strong></h3><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行” 的时候呢?所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状 态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续 等待线程重新被激活分配处理器时间。对于这种情况，就必须<strong>引入安全区域(Safe Region)来解决</strong>。</p>
<p><strong>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化</strong>，因此，在这个区域中任意地方开始垃圾 收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发<br>起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是<br>否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，那线程就当作没<br>事发生过，继续执行;否则它就必须一直等待，直到收到可以离开安全区域的信号为止</p>
<h3 id="垃圾回收是如何处理跨代引用问题的"><a href="#垃圾回收是如何处理跨代引用问题的" class="headerlink" title="垃圾回收是如何处理跨代引用问题的?"></a><strong>垃圾回收是如何处理跨代引用问题的?</strong></h3><p><strong>跨代引用举例</strong>:假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可 能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中 所有对象来确保可达性分析结果的正确性，反过来也是一样。</p>
<p>并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(Partial GC)行为的垃圾收集器，典 型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，JVM 为了用尽量少的资源消耗解决跨代引用下的垃 圾回收问题，引入了<strong>记忆集</strong>。记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可 以了，并不需要了解这些跨代指针的全部细节。目前最常用的一种记忆集实现形式种称为“卡表”,卡表中的每个记 录精确到一块内存区域(每块内存区域称之为卡页)，该区域内有对象含有跨代指针。</p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个(或更多)对象的字段存在着跨代指针，那就将对 应卡表的数组元素的值标识为1，称为这个元素变脏(Dirty)，没有则标识为0。在垃圾收集发生时，只要筛选出 卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>
<h3 id="说说垃圾回收器的三色标记理论"><a href="#说说垃圾回收器的三色标记理论" class="headerlink" title="说说垃圾回收器的三色标记理论"></a><strong>说说垃圾回收器的三色标记理论</strong></h3><p>了当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理 论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。 在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技 巧(如OopMap)的加持下，它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了。</p>
<p>“标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影 响就会波及几乎所有的垃圾收集器。</p>
<p>·<strong>白色</strong>:表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在 分析结束的阶段，仍然是白色的对象，即代表不可达。</p>
<p>·<strong>黑色</strong>:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过， 它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接(不经过灰 色对象)指向某个白色对象。</p>
<p>·<strong>灰色</strong>:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</p>
<h3 id="说说你所知道的垃圾回收器的种类"><a href="#说说你所知道的垃圾回收器的种类" class="headerlink" title="说说你所知道的垃圾回收器的种类"></a><strong>说说你所知道的垃圾回收器的种类</strong></h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291751151.png" alt="image-20220329175118105"></p>
<h3 id="说说Serial收集器的特点及使用场景"><a href="#说说Serial收集器的特点及使用场景" class="headerlink" title="说说Serial收集器的特点及使用场景"></a><strong>说说Serial收集器的特点及使用场景</strong></h3><p>该收集器是一个<strong>单线程工作的收集器</strong>，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程 去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必<strong>须暂停其他所有工作线程，直到它收集结束。</strong></p>
<p>迄今为止，它依然是HotSpot虚拟机运行在<strong>客户端模式</strong>下的<strong>默认新生代收集器</strong>，有着优于其他收集器的地方，那就是 简单而高效(与其他收集器的单线程相比)，对于内存资源受限的环境，它是所有收集器里<strong>额外内存消耗(Memory Footprint)最小</strong>的;对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心 做垃圾收集自然可以获得最高的单线程收集效率。在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配 给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代(仅仅是指新生代使用的内存，桌面 应用甚少超过这个容量)，垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频 繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以，Serial收集器对于运行在客户端模式下的虚拟 机来说是一个很好的选择。</p>
<h3 id="ParNew收集器是如何进行垃圾回收的"><a href="#ParNew收集器是如何进行垃圾回收的" class="headerlink" title="ParNew收集器是如何进行垃圾回收的"></a><strong>ParNew收集器是如何进行垃圾回收的</strong></h3><p>ParNew收集器<strong>实质上是Serial收集器的多线程并行版本</strong>，除了同时使用多条线程进行垃圾收集之外，其余的行为 包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器 完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<p>ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行 在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性 能无关但其实很重要的原因是:除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p>
<p>在JDK 5发布时，HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器——CMS收集器。 这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线 程(基本上)同时工作。</p>
<p>遗憾的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作[1]， 所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器 是激活CMS后(使用-XX:+UseConcMarkSweepGC选项)的默认新生代收集器，也可以使用-XX:+&#x2F;- UseParNewGC选项来强制指定或者禁用它。</p>
<p>ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销， 该收集器在通过超线程(Hyper-Threading)技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集 器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好 处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多(譬如32个，现在CPU都是多核 加超线程设计，服务器达到或超过32个逻辑核心的情况非常普遍)的环境中，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291801259.png" alt="image-20220329180102218"></p>
<h3 id="Paralle-Scavenge垃圾收集器"><a href="#Paralle-Scavenge垃圾收集器" class="headerlink" title="Paralle Scavenge垃圾收集器"></a>Paralle Scavenge垃圾收集器</h3><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够<strong>并行收 集</strong>的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢?</p>
<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收 集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即:</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX: MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p>
<p>-XX:MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变 得更快，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的:系统把新生代调得小一些，收集 300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100 毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p>-XX:GCTimeRatio参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞 吐量的倒数。譬如把此参数设置为<strong>19</strong>，那允许的最大垃圾收集时间就占总时间的5%(<strong>即1&#x2F;(1+19)</strong>)，默认值为<strong>99</strong>， 即允许最大1%(<strong>即1&#x2F;(1+99)</strong>)的垃圾收集时间。</p>
<p>由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。除上述两个参数之外， Parallel Scavenge收集器还有一个参数-XX:+<strong>UseAdaptiveSizePolicy</strong>值得我们关注。这是一个开关参数，当这个 参数被激活之后，就不需要人工指定新生代的大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRatio)、 晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性 能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适 应的调节策略(GC Ergonomics)</p>
<h3 id="说说Serial-Old收集器的特点及使用场景"><a href="#说说Serial-Old收集器的特点及使用场景" class="headerlink" title="说说Serial Old收集器的特点及使用场景"></a><strong>说说Serial Old收集器的特点及使用场景</strong></h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法。这个收集器的主 要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途:一种是在 JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后 备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<p>需要说明一下，Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非直接调 用Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现几乎是一样的，所以在官方的许多资 料中都是直接以Serial Old代替PS MarkSweep进行讲解</p>
<h3 id="说说Parallel-Old收集器的特点及使用场景"><a href="#说说Parallel-Old收集器的特点及使用场景" class="headerlink" title="说说Parallel Old收集器的特点及使用场景"></a><strong>说说Parallel Old收集器的特点及使用场景</strong></h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器 是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果 新生代选择了Parallel Scavenge收集器，老年代除了Serial Old(PS MarkSweep)收集器以外别无选择，其他表现良 好的老年代收集器，如CMS无法与它配合工作。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用 Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分 利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总 吞吐量甚至不一定比ParNew加CMS的组合来得优秀。</p>
<p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器 资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
<h3 id="说说CMS收集器的特点"><a href="#说说CMS收集器的特点" class="headerlink" title="说说CMS收集器的特点"></a><strong>说说CMS收集器的特点</strong></h3><p>CMS(<strong>Concurrent Mark Sweep</strong>)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java 应用集中在互联网网站或者基于浏览器的B&#x2F;S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p>
<p>从名字(包含“Mark Sweep”)上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几 种收集器来说要更复杂一些，整个过程分为<strong>四个步骤</strong>，包括:<br> 1)初始标记(CMS initial mark)</p>
<p>2)并发标记(CMS concurrent mark)</p>
<p>3)重新标记(CMS remark)</p>
<p>4)并发清除(CMS concurrent sweep)</p>
<p>其中<strong>初始标记、重新标记这两个步骤仍然需要“Stop The World”</strong>。初始标记仅仅只是标记一下GC Roots能直接关联 到的对象，速度很快;并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较 长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行;而重新标记阶段则是为了修正并发标记期间，因 用户程序继续运作而导致标记产生变动的那一部分对象的标记记录(详见220题中关于增量更新的讲解)，这个阶 段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短;最后是并发清除阶段，清理删除 掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291854073.png" alt="image-20220329185456029"></p>
<h3 id="CMS收集器有什么缺点吗"><a href="#CMS收集器有什么缺点吗" class="headerlink" title="CMS收集器有什么缺点吗"></a><strong>CMS收集器有什么缺点吗</strong></h3><p>CMS是一款优秀的收集器，它最主要的优点在名字上已经体现出来:并发收集、低停顿，一些官方公开文档里面 也称之为“并发低停顿收集器”(Concurrent Low Pause Collector)。CMS收集器是HotSpot虚拟机追求低停顿的第 一次成功尝试，但是它还远达不到完美的程度，至少有以下<strong>三个明显的缺点</strong>:</p>
<p>首先，CMS收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段， 它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢， 降低总吞吐量。<strong>CMS默认启动的回收线程数是(处理器核心数量+3)&#x2F;4</strong>，也就是说，如果处理器核心数在四个或 以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。 但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高， 还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。为了缓解这种情况， 虚拟机提供了一种称为“<strong>增量式并发收集器</strong>”(Incremental Concurrent Mark Sweep&#x2F;i-CMS)的CMS收集器变种，所 做的事情和以前单核处理器年代PC机操作系统靠抢占式多任务来模拟多核并行多任务的思想一样，是在并发标记、 清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间，这样整个垃圾收集的 过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变慢的时间更多了，但速度下降幅度就没 有那么明显。实践证明增量式的CMS收集器效果很一般，从JDK 7开始，i-CMS模式已经被声明为“deprecated”， 即已过时不再提倡用户使用，<strong>到JDK 9发布后i-CMS模式被完全废弃</strong>。</p>
<p>然后，由于CMS收集器无法处理“浮动垃圾”(Floating Garbage)，有可能出现“Con-current Mode Failure”失败进 而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运 行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样 也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此 CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集 时的程序运作使用。在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保 守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX:CMSInitiatingOccu-pancyFraction 的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已 经默认提升至92%。但这又会更容易面临另一种风险:要是CMS运行期间预留的内存无法满足程序分配新对象的需 要，就会出现一次“并发失败”(Concurrent Mode Failure)，这时候虚拟机将不得不启动后备预案:冻结用户线程 的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数-XX: CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产 环境中根据实际应用情况来权衡设置。</p>
<p>还有最后一个缺点，在本节的开头曾提到，CMS是一款基于“标记-清除”算法实现的收集器，如 果对前面对垃圾回收器算法讲解还有印象的话，就可能想到这意味着收集结束时会有大量空间 碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩 余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的 情况。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMS-CompactAtFullCollection开 关参数(默认是开启的，此参数从JDK 9开始废弃)，用于在CMS收集器不得不进行Full GC时开 启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，(在Shenandoah和ZGC出 现前)是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者 们还提供了另外一个参数-XX:CMSFullGCsBefore-Compaction(此参数从JDK 9开始废弃)，这 个参数的作用是要求CMS收集器在执行过若干次(数量由参数值决定)不整理空间的Full GC之 后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整 理)。<strong>只能预防，不能根治。</strong></p>
<h3 id="说说你对-G1-垃圾回收器的了解"><a href="#说说你对-G1-垃圾回收器的了解" class="headerlink" title="说说你对 G1 垃圾回收器的了解"></a><strong>说说你对 G1 垃圾回收器的了解</strong></h3><p>Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器<strong>面向局部收 集</strong>的设计思路和<strong>基于Region的内存布局</strong>形式。</p>
<p>G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是(在比较长期的)未来可 以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用 (Deprecate)的收集器。如果对JDK 9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来 开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p>
<p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代(Minor GC)， 要么就是整个老年代(Major GC)，再要么就是整个Java堆(FullGC)。而G1跳出了这个樊笼，它可以面向堆 内存任何部分来组成回收集(Collection Set，一般简称CSet)进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的<strong>Mixed GC模式</strong>。</p>
<h3 id="G1收集器为什么能够建立可预测的停顿时间模型"><a href="#G1收集器为什么能够建立可预测的停顿时间模型" class="headerlink" title="G1收集器为什么能够建立可预测的停顿时间模型"></a><strong>G1收集器为什么能够建立可预测的停顿时间模型</strong></h3><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集 到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<p>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空 间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿 时间(使用参数-XX:MaxGCPauseMillis指定，默认值是200毫秒)，优先处理回收价值收益最大的那些 Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收 方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
<h3 id="在并发标记阶段如何保证收集线程与用户线程互不干扰地运"><a href="#在并发标记阶段如何保证收集线程与用户线程互不干扰地运" class="headerlink" title="在并发标记阶段如何保证收集线程与用户线程互不干扰地运"></a><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运</strong></h3><p>CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照(SATB)算法来实现的。此外， 垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定 会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS(Top at Mark Start)的指针，把 Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址 都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认 它们是存活的，不纳入回收范围。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似， 如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而 产生长时间“Stop The World”。</p>
<h3 id="G1收集器回收步骤"><a href="#G1收集器回收步骤" class="headerlink" title="G1收集器回收步骤"></a>G1收集器回收步骤</h3><p>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下 一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而 且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p>
<p>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图， 找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB 记录下的在并发时有引用变动的对象。</p>
<p>最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少 量的SATB记录。</p>
<p>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成 本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决 定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉 及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p>
<p>从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291911230.png" alt="image-20220329191104180"></p>
<h3 id="JVM堆内存结构"><a href="#JVM堆内存结构" class="headerlink" title="JVM堆内存结构"></a>JVM堆内存结构</h3><p>把新生代分为一块较大的Eden空间和两块较小的Survivor 空间，每次分配内存只使用Eden和其中一块Survivor。发 生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次 性复制到另外一块Survivor空间上，然后直接清理掉Eden 和已用过的那块Survivor空间。HotSpot虚拟机默认Eden 和Survivor的大小比例是8∶1。</p>
<p>还有一个老年代</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291912776.png" alt="image-20220329191258730"></p>
<h3 id="新创建的对象可能直接分配到老年代吗"><a href="#新创建的对象可能直接分配到老年代吗" class="headerlink" title="新创建的对象可能直接分配到老年代吗"></a><strong>新创建的对象可能直接分配到老年代吗</strong></h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<p>对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量 很庞大的数组。大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏 的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。</p>
<p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就<strong>提前触 发垃圾收集，以获取足够的连续空间才能安置好它们</strong>，而当复制对象时，大对象就意味着高额的内存复 制开销。<strong>HotSpot虚拟机提供了-XX:PretenureSizeThreshold参数，指定大于该设置值的对象直接在 老年代分配</strong>，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操 作。</p>
<h3 id="老年代存放的都是什么对象"><a href="#老年代存放的都是什么对象" class="headerlink" title="老年代存放的都是什么对象"></a><strong>老年代存放的都是什么对象</strong></h3><p>HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当 放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数 器，存储在对象头中。</p>
<p>对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移 动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁， 当它的年龄增加到一定程度(<strong>默认为15</strong>)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参 数**-XX:MaxTenuringThreshold**设置。</p>
<h3 id="JVM中对象的年龄必须达到-XX-MaxTenuringThreshold才能晋升老年-代吗-绝对吗"><a href="#JVM中对象的年龄必须达到-XX-MaxTenuringThreshold才能晋升老年-代吗-绝对吗" class="headerlink" title="JVM中对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年 代吗?绝对吗?"></a>JVM中对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年 代吗?绝对吗?</h3><p>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX: MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中<strong>相同年龄所有对象大小的总和</strong>大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX: MaxTenuringThreshold中要求的年龄。</p>
<h3 id="什么是空间分配担保"><a href="#什么是空间分配担保" class="headerlink" title="什么是空间分配担保"></a><strong>什么是空间分配担保</strong></h3><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查 看-XX:HandlePromotionFailure参数的设置值是否允许担保失败(Handle Promotion Failure); 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的;如果小于，或者-XX: HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</p>
<h3 id="什么是内存泄漏，与内存溢出有什么关系"><a href="#什么是内存泄漏，与内存溢出有什么关系" class="headerlink" title="什么是内存泄漏，与内存溢出有什么关系"></a><strong>什么是内存泄漏，与内存溢出有什么关系</strong></h3><p>内存泄漏:是指创建的对象已经没有用处，正常情况下应该会被垃圾收集器回收，但是由于该对象仍然被其他对象进行了无效引用，导致不能够被垃圾收集器及时清理，这种现象称之为内存泄漏。</p>
<p>内存泄漏会导致内存堆积，最终发生内存溢出，导致OOM。</p>
<p>发生内存泄漏大部分是由于程序代码导致的，排查方法一般是使用 visualVM 进行heap dump，查看占用 空间比较多的 class 对象，然后检查该对象的instances 以及 reference引用，最终定位到程序代码。</p>
<p>如果堆内存比较大，进行head dump 产生的资源消耗不可接受，可以尝试使用轻量级的jmap生成堆转储快照 分析，思路与使用可视化工具一样。</p>
<h3 id="什么对象逃逸-对象逃逸分析优化"><a href="#什么对象逃逸-对象逃逸分析优化" class="headerlink" title="什么对象逃逸 对象逃逸分析优化"></a>什么对象逃逸 对象逃逸分析优化</h3><p>逃逸分析的基本原理是:分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，<br>例如作为调用参数传递到其他方法中，这种称为方法逃逸;甚至还有可能被外部线程访问到，譬如赋值给可<br>以在其他线程中访问的实例变量，这种称为线程逃逸;从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。<br>优化有三种:栈上分配;标量替换;锁消除(或称同步消除)。</p>
<p>·<strong>栈上分配</strong>(Stack Allocations):在Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道 的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储 的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象， 还是回收和整理内存，都需要耗费大量资源。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分 配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会 逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着 方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线 程逃逸。</p>
<p>·<strong>标量替换</strong>(Scalar Replacement):若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型 (int、long等数值类型及reference类型等)都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果 一个数据可以继续分解，那它就被称为聚合量(Aggregate)，Java中的对象就是典型的聚合量。如果把一个Java对象 拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析 能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对 象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈 上(栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储)分配和读写之外，还可以为后续进一 步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单(不用考虑整个对象完整结构的分配)， 但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</p>
<p>·<strong>同步消除</strong>(Synchronization Elimination):线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不 会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以 安全地消除掉。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291930936.png" alt="image-20220329193034885"></p>
<h3 id="JVM调优经验"><a href="#JVM调优经验" class="headerlink" title="JVM调优经验"></a>JVM调优经验</h3><p>VM调优情况十分复杂，各种情况都可能导致垃圾回收不能够达到预想的效果。对于场景问题，可以从如下几个 大方向进行设计:</p>
<ol>
<li><p>在大访问压力下，MinorGC 频繁，MinorGC 是针对新生代进行回收的，每次在MGC 存活下来的对象，会移动 到Survivor1区。先到这里为止，大访问压力下，MGC 频繁一些是正常的，只要MGC 延迟不导致停顿时间过长或 者引发FGC ，那可以适当的增大Eden 空间大小，降低频繁程度，同时要保证，空间增大对垃圾回收时间产生的 停顿时间增长也是可以接受的。继续说，如果MinorGC 频繁，且容易引发 Full GC。需要从如下几个角度进行分析。a:每次MGC存活的对象的 大小，是否能够全部移动到 S1区，如果S1 区大小 &lt; MGC 存活的对象大小，这批对象会直接进入老年代。注意 了，这批对象的年龄才1岁，很有可能再多等1次MGC 就能被回收了，可是却进入了老年代，只能等到Full GC 进 行回收，很可怕。这种情况下，应该在系统压测的情况下，实时监控MGC存活的对象大小，并合理调整eden和s 区的大小以及比例。还有一种情况会导致对象在未达到15岁之前，直接进入老年代，就是S1区的对象，相同年 龄的对象所占总空间大小&gt;s1区空间大小的一半，所以为了应对这种情况，对于S区的大小的调整就要考虑:尽 量保证峰值状态下，S1区的对象所占空间能够在MGC的过程中，相同对象年龄所占空间不大于S1区空间的一半， 因此对于S1空间大小的调整，也是十分重要的。</p>
</li>
<li><p>由于大对象创建频繁，导致Full GC 频繁。对于大对象，JVM专门有参数进行控制，-XX: PretenureSizeThreshold。超过这个参数值的对象，会直接进入老年代，只能等到full GC 进行回收，所以在系统 压测过程中，要重点监测大对象的产生。如果能够优化对象大小，则进行代码层面的优化，优化如:根据业务 需求看是否可以将该大对象设置为单例模式下的对象，或者该大对象是否可以进行拆分使用，或者如果大对象 确定使用完成后，将该对象赋值为null，方便垃圾回收。如果代码层面无法优化，则需要考虑:调高-XX: PretenureSizeThreshold参数的大小，使对象有机会在eden区创建，有机会经历MGC以被回收。但是这个参数的 调整要结合MGC过程中Eden区的大小是否能够承载，包括S1区的大小承载问题。b:这是最不希望发生的情况， 如果必须要进入老年代，也要尽量保证，该对象确实是长时间使用的对象，放入老年代的总对象创建量不会造 成老年代的内存空间迅速长满发生Full GC，在这种情况下，可以通过定时脚本，在业务系统不繁忙情况下，主动触发full gc。</p>
</li>
<li><p>MGC 与 FGC 停顿时间长导致影响用户体验。其实对于停顿时间长的问题无非就两种情况:a gc 真实回收过 程时间长，即real time时间长。这种时间长大部分是因为内存过大导致，导致从标记到清理的过程中需要对很大 的空间进行操作，导致停顿时间长。b:gc真实回收时间 real time 并不长，但是user time(用户态执行时间) 和 sys time(核心态执行时间)时间长，导致从客户角度来看，停顿时间过长。对于a情况，要考虑减少堆内存大 小，包括新生代和老年代，比如之前使用16G的堆内存，可以考虑将16G 内存拆分为4个4G的内存区域，可以单 台机器部署JVM逻辑集群，也可以为了降低GC回收时间进行4节点的分布式部署，这里的分布式部署是为了降低 GC垃圾回收时间。对于b情况，要考虑线程是否及时达到了安全点，通过-XX:+PrintSafepointStatistics和-XX: PrintSafepointStatisticsCount&#x3D;1去查看安全点日志，如果有长时间未达到安全点的线程，再通过参数-XX: +SafepointTimeout和-XX:SafepointTimeoutDelay&#x3D;2000两个参数来找到大于2000ms到达安全点的线程，这里 的2000ms可以根据情况自己设置，然后对代码进行针对的调整。除了安全点问题，也有可能是操作系统本身负 载比较高，导致处理速度过慢，线程达到安全点时间长，因此需要同时检测操作系统自身的运行情况。</p>
</li>
<li><p>内存泄漏导致的MGC和FGC频繁，最终引发oom。内存泄漏的排查参见面试题247.</p>
</li>
<li><p>纯代码级别导致的MGC和FGC频繁。如果是这种情况，那就只能对代码进行大范围的调整，这种情况就非常 多了，而且会很糟糕。如大循环体中的new 对象，未使用合理容器进行对象托管导致对象创建频繁，不合理的 数据结构使用等等。</p>
</li>
</ol>
<p>总之，JVM的调优无非就一个目的，在系统可接受的情况下达到一个合理的MGC和FGC的频率以及可接受的回收 时间。</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2022/03/27/MySQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/">MySQL优化相关<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/2022/03/29/MySQL%E9%9D%A2%E8%AF%95%E5%A4%A7%E7%BA%B2/">MySQL面试大纲<span class="note">较新</span></a></section></div>






  <div class='related-wrap md reveal' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="eurekawm/blog-comments" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </div>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="http://example.com/">@sean</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.6.1" title="v1.6.1">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.6.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
