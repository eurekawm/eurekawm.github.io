<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰色と青</title>
  
  <subtitle>Eurekawm&#39;s Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-21T09:40:09.430Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>sean</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nacos源码分析</title>
    <link href="http://example.com/2022/03/21/Nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/21/Nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-20T16:26:41.000Z</published>
    <updated>2022-03-21T09:40:09.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos-Tutorial"><a href="#Nacos-Tutorial" class="headerlink" title="Nacos Tutorial"></a>Nacos Tutorial</h1><h2 id="Nacos总览"><a href="#Nacos总览" class="headerlink" title="Nacos总览"></a>Nacos总览</h2><h3 id="nacos服务健康探测机制与保护阈值"><a href="#nacos服务健康探测机制与保护阈值" class="headerlink" title="nacos服务健康探测机制与保护阈值"></a>nacos服务健康探测机制与保护阈值</h3><p>引入第一个问题，健康探测机制，服务注册中心都必须是要有的</p><p>nacos健康探测机制，分成两种，临时实例、持久化实例，针对不同的实例，他的健康探测机制不太一样，dubbo服务注册的时候要带上一个参数[ephemeral]，可以取值为两个，临时和持久化</p><p>默认情况下都不用去主动设置这个参数，默认都是ephemeral，临时实例</p><p>临时的话，默认每隔5s上报一次心跳，nacos如果15s没收到心跳就标记为不健康，超过30s没收到就摘除这个服务实例</p><p>持久化的话，nacos主动探测，20s探测一次，即使探测失败，也就是不健康状态，但是不会摘除这个服务实例</p><p>默认情况下，不健康的实例是不返回的，但是如果健康实例比例太低，会导致健康实例请求压力过大，被打死，引发服务雪崩，所以有保护阈值的概念</p><p>保护阈值，可以设置为0~1之间的比例，如果健康实例比例太低，则把不健康实例一起返回，此时会让很多请求走到不健康实例，会导致请求失败，但是可以避免健康实例的请求流量过大被打死，牺牲了一致性，得到了可用性 </p><h3 id="服务雪崩问题以及nacos健康保护阈值"><a href="#服务雪崩问题以及nacos健康保护阈值" class="headerlink" title="服务雪崩问题以及nacos健康保护阈值"></a>服务雪崩问题以及nacos健康保护阈值</h3><p>服务雪崩问题，nacos健康保护阈值</p><p>库存服务有10台机器，10个服务实例，订单服务会大范围的去调用库存服务，假设每个库存服务实例单机可以抗每秒500次请求，QPS 500，高峰 QPS 500 * 10 &#x3D; 5000，某一天，库存服务实例10个，里面有5个都崩溃了</p><p>5台机器都是虚拟机，部署在一个物理机，物理机故障了，就会导致5个虚拟机一起故障了这样子</p><p>每秒5000次请求，都会发送给剩下的5台健康的实例，平均每台实例会收到每秒1000次请求，远远超出了单机极限QPS，800，1000已经超过了。 </p><p>nacos有一个保护阈值， 比如设置为0.8 那么10台实例挂了两台都是没关系的，不会触发保护机制，订单服务会去请求这些剩下的8个健康实例，如果挂了4个，剩下6个，如果订单服务来请求，可能扛不住，如果设置阈值为0.6，所以nacos会返回订单服务6个健康的实例和4个挂了的实例，订单那边请求失败，但是不会把机器打垮，防止雪崩。</p><h3 id="保护阈值机制开启后的CAP问题分析"><a href="#保护阈值机制开启后的CAP问题分析" class="headerlink" title="保护阈值机制开启后的CAP问题分析"></a>保护阈值机制开启后的CAP问题分析</h3><p>一句话， 开了保护阈值机制打开了，会保障可用性，牺牲了一致性，订单看起来这些实例就不是一致。如果不打开保护阈值机制，那么请求的都是健康的服务实例，那么订单服务看起来都是一致的。</p><h3 id="自研Distro分布式一致性协议分析"><a href="#自研Distro分布式一致性协议分析" class="headerlink" title="自研Distro分布式一致性协议分析"></a>自研Distro分布式一致性协议分析</h3><p>nacos基础原理+开发实战+核心功能+数据模型，重点要给大家讲解一下nacos的内核原理</p><p>服务注册这块，允许大量的服务实例来注册，在nacos集群里管理所有的服务实例数据，针对你的nacos里管理的服务实例数据服务发现，注册（写操作），存储（nacos集群存放服务实例数据），发现（读操作），针对临时服务实例数据的存储</p><p>灵魂拷问：服务注册找nacos集群里哪个节点来发起？服务实例数据是存储在哪个nacos节点里？发现的时候找的是nacos哪个节点？</p><p>nacos集群启动之后按如下原则运作：</p><p>1、nacos每个节点都可以处理写请求，收到请求后，路由，根据ip:port路由算法，计算所属节点，把请求转发到负责这个数据的节点去，负责节点解析请求在本机里进行内存存储，定期执行同步任务，把本机负责的数据同步到其他节点，所以每个节点都有全量数据的存储</p><p>distro分布式一致性协议里，设计了一个定时sync同步机制和任务</p><p>关键点，仅仅按照这套算法来运行，会导致数据分片，data partition，每个nacos节点仅仅负责和管理了一部分的服务实例数据</p><p>提出第一种服务发现读数据的时候，nacos节点上没有你要的服务实例的数据，写路由+数据分片+读路由的架构设计，可用性的问题，优点是数据是强一致的，CAP，C，牺牲掉A，可用性就没有了，并不是nacos采用的方案，CP</p><p>nacos默认提供的AP，保证可用性</p><p>通过各个节点 定时同步数据的机制，可以确保说什么，每个节点除了处理自己负责的那部分数据写入，自己也会不断的把自己的数据同步给别的节点，定时的不断的接收到别的节点同步过来的数据</p><p>对于你的每一个节点来说，他会发现你这个节点上，会有所有节点的数据都汇总到你这里来，你这里会源源不断的接收到集群里完整的服务实例数据，保证最终一致性的概念，最终每个节点都会有集群里最新的数据</p><p>时间差问题-&gt;最终一致性，牺牲掉了一致性，AP，CP</p><p>2、新加入的nacos节点会拉取全量数据，轮询所有nacos节点，发送请求拉取全量数据，所以其实每个nacos节点上都会有所有注册上来的临时服务实例的数据</p><p>3、nacos每个节点都会定期发送心跳给其他的节点，心跳请求会进行数据校验，主要是交换数据的校验值，如果发现要是其他机器上的数据跟自己不一致，就会全量拉取数据进行补齐</p><p>4、nacos每个节点都可以处理读请求，因为有全量数据</p><p>distro协议是兼顾CAP中的AP的，在这个协议之下，所有节点通过定期数据同步，还有心跳校验实现节点数据最终一致，让每个节点都有全量数据，这样的话，如果有节点宕机崩溃都是没关系的</p><p>另外网络分区的话，也是没事的，因为不同的网络分区里就是读写分区中的nacos节点就可以了，就是没办法互相同步数据了，数据会不一致（通过MD5来校验的），但是一旦分区问题恢复了，心跳校验机制运作起来，数据会自动补齐的</p><h3 id="基于Raft协议的弱CP机制"><a href="#基于Raft协议的弱CP机制" class="headerlink" title="基于Raft协议的弱CP机制"></a>基于Raft协议的弱CP机制</h3><p>我如果是基于路由转发的这种方式， 数据集中在一个服务器上，这样是不可行的，会把机器打垮。如果是全量复制，数据也是强一致的，但是这种同步全量复制机制是很重的，写入性能非常低。</p><p>Distro这种是异步复制，保障的是最终一致性，再加上心跳机制，各个节点最终是一致的，但是有时间差问题，牺牲了一致性。即使崩溃了，也有一个机器有几乎全量数据。</p><p>首先Nacos集群通过Raft协议来选举，选举成为leader的节点才能接受读请求，然后接受读请求这一段时间服务是不可用，因为有一个raft日志同步过程（半数节点以上），但是Nacos的Raft不是标准的两阶段提交（2.0之后是标准的Raft两阶段提交），所以Nacos是有是一个弱CP机制的。有一个问题，半数节点同步了，其他节点呢？Nacos是通过注册心跳来解决，Nacos主节点发送心跳（zip）的时候附带了主节点上一些服务信息，然后从节点如果发现自己少了这些，那么就主动call注解点来拉取。</p><h3 id="临时实例和持久实例"><a href="#临时实例和持久实例" class="headerlink" title="临时实例和持久实例"></a>临时实例和持久实例</h3><ul><li>临时实例：默认情况，注册在内存注册表中，不会持久化到磁盘文件，健康检查是client模式，client主动上报，5S一次，Server 检查心跳情况，15秒没上报就设置为不健康，30S没上报就删除实例</li><li>持久化实例：注册到内存注册表之后，还会写入到磁盘文件，心跳检测是Server主动去检测client心跳是拉模式，20S检查一次，检测失败会把实例标记为不健康，但不会清除，因为持久化了</li></ul><p>使用场景：临时实例是存在突发流量横向扩展服务，适用于互联网，持久实例是相对固定的实例。</p><h2 id="Naocs-源码分析"><a href="#Naocs-源码分析" class="headerlink" title="Naocs 源码分析"></a>Naocs 源码分析</h2><h3 id="Nacos-Client源码分析"><a href="#Nacos-Client源码分析" class="headerlink" title="Nacos Client源码分析"></a>Nacos Client源码分析</h3><h4 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h4><p>Instance类，代表一个服务实例，一些基础信息，一个实例隶属于一个服务，一个集群</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instance</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">742906310567291979L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unique id of this instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String instanceId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance ip.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance weight.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">1.0D</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance health status.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">healthy</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If instance is enabled to accept request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If instance is ephemeral.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ephemeral</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cluster information of instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String clusterName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service information of instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user extended attributes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceInfo类，包含一个Instance列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInfo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">jsonFromServer</span> <span class="operator">=</span> EMPTY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLITER</span> <span class="operator">=</span> <span class="string">&quot;@@&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 服务名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String clusters; <span class="comment">// 一个服务可能有多个集群</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">cacheMillis</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Instance&gt; hosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Instance&gt;(); <span class="comment">// 当前服务所有的服务实例列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastRefTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">checksum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">allIPs</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingService 接口，它有一个实现类NacosNamingService，可以完成Client到Server的各种通信，注册&#x2F;取消注册，订阅取消等等</p><h4 id="Nacos启动流程"><a href="#Nacos启动流程" class="headerlink" title="Nacos启动流程"></a>Nacos启动流程</h4><p>Nacos启动是根据事件监听机制，监听到web服务器启动之后，就开始自动注册。自动注册之前的逻辑先跳过，直接来看到底是怎么注册的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> namingService();</span><br><span class="line"><span class="comment">// 微服务名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> registration.getServiceId();</span><br><span class="line"><span class="comment">// 分组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> nacosDiscoveryProperties.getGroup();</span><br><span class="line"><span class="comment">// 生成instance </span></span><br><span class="line"><span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用注册逻辑</span></span><br><span class="line">namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">instance.getIp(), instance.getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line"><span class="comment">// rethrow a RuntimeException if the registration is failed.</span></span><br><span class="line"><span class="comment">// issue : https://github.com/alibaba/spring-cloud-alibaba/issues/1132</span></span><br><span class="line">rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入的是NacosNamingService类的registerInstance方法，其实还是一个封装instance，然后注册的，进入到这个重载方法内部，有几步需要做的：</p><ol><li>验证instance是否合法</li><li>获取groupSerce名称 例如 my_default_group@@order_service</li><li>开始心跳  </li><li>发起注册</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="comment">// 是否是临时实例 构建Beat信息</span></span><br><span class="line">            <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            <span class="comment">// 开始心跳</span></span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看一下心跳信息有什么内容，其实就是当前实例的一些东西， 加上间隔时间。默认是5S发送一次心跳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeatInfo <span class="title function_">buildBeatInfo</span><span class="params">(String groupedServiceName, Instance instance)</span> &#123;</span><br><span class="line">        <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeatInfo</span>();</span><br><span class="line">        beatInfo.setServiceName(groupedServiceName);</span><br><span class="line">        beatInfo.setIp(instance.getIp());</span><br><span class="line">        beatInfo.setPort(instance.getPort());</span><br><span class="line">        beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">        beatInfo.setWeight(instance.getWeight());</span><br><span class="line">        beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">        beatInfo.setScheduled(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 心跳间隔 默认5秒</span></span><br><span class="line">        beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line">        <span class="keyword">return</span> beatInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码执行顺序可以看出，既然先执行发送心跳，但是此时还没注册上去，发送心跳必然找不到服务啊？其实这是一个延迟任务，点进发送心跳的源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add beat information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName service name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beatInfo    beat information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> &#123;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[BEAT] adding beat: &#123;&#125; to beat map.&quot;</span>, beatInfo);</span><br><span class="line"><span class="comment">// key的格式为 groupId@@微服务名称##ip##port</span></span><br><span class="line"><span class="comment">// 这个key是固定了主机了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> buildKey(serviceName, beatInfo.getIp(), beatInfo.getPort());</span><br><span class="line">        <span class="type">BeatInfo</span> <span class="variable">existBeat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//fix #1733 again</span></span><br><span class="line"><span class="comment">// dom2Beat是一个缓存map，key是主机，value=主机发送的心跳信息beat</span></span><br><span class="line"><span class="comment">// 前面的心跳停了才发送新的心跳</span></span><br><span class="line">        <span class="keyword">if</span> ((existBeat = dom2Beat.put(key, beatInfo)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            existBeat.setStopped(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始定时任务 5S之后开始任务 在结束之前又开始一个新的任务</span></span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">        MetricsMonitor.getDom2BeatSizeMonitor().set(dom2Beat.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看一下BeatTask的run方法，其实就是使用httpClient发起调用，然后结束之前把任务再添加今天循环调用而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nextTime</span> <span class="operator">=</span> beatInfo.getPeriod();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发送心跳 PUT 请求</span></span><br><span class="line">                <span class="type">JsonNode</span> <span class="variable">result</span> <span class="operator">=</span> serverProxy.sendBeat(beatInfo, BeatReactor.<span class="built_in">this</span>.lightBeatEnabled);</span><br><span class="line">                <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> result.get(<span class="string">&quot;clientBeatInterval&quot;</span>).asLong();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">lightBeatEnabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                    lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="built_in">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nextTime = interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> NamingResponseCode.OK;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                    code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果发现此实例在nacos server上面没有注册，那么就执行注册的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                    <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">                    instance.setPort(beatInfo.getPort());</span><br><span class="line">                    instance.setIp(beatInfo.getIp());</span><br><span class="line">                    instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                    instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                    instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                    instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                    instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                    instance.setEphemeral(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                                NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                        JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception unknownEx) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, unknown exception msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                        JacksonUtils.toJson(beatInfo), unknownEx.getMessage(), unknownEx);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 再次嵌套调用</span></span><br><span class="line">                executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入JsonNode result &#x3D; serverProxy.sendBeat(beatInfo, BeatReactor.this.lightBeatEnabled);把BeatInfo拆开放入map，发送过去，是一个PUT请求，请求url &#x3D; nacos&#x2F;v1&#x2F;ns&#x2F;instance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonNode <span class="title function_">sendBeat</span><span class="params">(BeatInfo beatInfo, <span class="type">boolean</span> lightBeatEnabled)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">            NAMING_LOGGER.debug(<span class="string">&quot;[BEAT] &#123;&#125; sending beat to server: &#123;&#125;&quot;</span>, namespaceId, beatInfo.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">8</span>);</span><br><span class="line">        Map&lt;String, String&gt; bodyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!lightBeatEnabled) &#123;</span><br><span class="line">            bodyMap.put(<span class="string">&quot;beat&quot;</span>, JacksonUtils.toJson(beatInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, beatInfo.getServiceName());</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, beatInfo.getCluster());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, beatInfo.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(beatInfo.getPort()));</span><br><span class="line">        <span class="comment">// 发送Beat心跳</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/beat&quot;</span>, params, bodyMap, HttpMethod.PUT);</span><br><span class="line">        <span class="keyword">return</span> JacksonUtils.toObj(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到上文的注册逻辑，点进去看一下注册实例是怎么做的，其实就是两件事情</p><ol><li>把instace这个对象拆开，放入parmas</li><li>发起post请求，地址为 nacos&#x2F;v1&#x2F;ns&#x2F;instance</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>, namespaceId, serviceName,</span><br><span class="line">                instance);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line">        <span class="comment">// 权重</span></span><br><span class="line">        params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">        params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">        <span class="comment">// 健康度</span></span><br><span class="line">        params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">        params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">        params.put(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.toJson(instance.getMetadata()));</span><br><span class="line">        <span class="comment">// nacos/v1/ns/instance</span></span><br><span class="line">        reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入 reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);来看一些是怎么做的，一句话总结就是 如果有多个nacos节点，那么就轮训尝试注册，直到成功或是尝试次数达到了nacos服务数量。 如果是单节点，默认尝试次数为3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span><br><span class="line"><span class="params">                         String method)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;no server available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">NacosException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>();</span><br><span class="line"><span class="comment">// domain不为空，先连接这个，默认尝试次数3</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用服务注册</span></span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是一个重要的信息如果是多个nacos节点，其实是随机找个nacos节点来注册的</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(servers.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">server</span> <span class="operator">=</span> servers.get(index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, server, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 该server连接失败 ，连接下一个</span></span><br><span class="line">                index = (index + <span class="number">1</span>) % servers.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NAMING_LOGGER.error(<span class="string">&quot;request: &#123;&#125; failed, servers: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>, api, servers, exception.getErrCode(),</span><br><span class="line">                exception.getErrMsg());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(exception.getErrCode(),</span><br><span class="line">                <span class="string">&quot;failed to req API:&quot;</span> + api + <span class="string">&quot; after all servers(&quot;</span> + servers + <span class="string">&quot;) tried: &quot;</span> + exception.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后面发送HTTP POST请求的代码就不再细看了，是使用NameServerProxy来做，里面调用的是HttpClient发送的请求，请求的地址是<a href="http://127.0.0.1:8848/nacos/v1/ns/instance%E3%80%82">http://127.0.0.1:8848/nacos/v1/ns/instance。</a></p><h4 id="Nacos获取所有服务"><a href="#Nacos获取所有服务" class="headerlink" title="Nacos获取所有服务"></a>Nacos获取所有服务</h4><p>直接说结论，是在NamingServiceProxy里面调用获取服务列表的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">queryList</span><span class="params">(String serviceName, String clusters, <span class="type">int</span> udpPort, <span class="type">boolean</span> healthyOnly)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">8</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">        params.put(<span class="string">&quot;udpPort&quot;</span>, String.valueOf(udpPort));</span><br><span class="line">        params.put(<span class="string">&quot;clientIP&quot;</span>, NetUtils.localIP());</span><br><span class="line">        params.put(<span class="string">&quot;healthyOnly&quot;</span>, String.valueOf(healthyOnly));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP请求 调用服务列表</span></span><br><span class="line">        <span class="keyword">return</span> reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/list&quot;</span>, params, HttpMethod.GET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Nacos定时更新本地服务"><a href="#Nacos定时更新本地服务" class="headerlink" title="Nacos定时更新本地服务"></a>Nacos定时更新本地服务</h4><p>容器在启动的时候创建了一个<code>NacosWatch</code> Bean，这个Bean就是和服务订阅有关的，看一下关键的方法    namingService.subscribe(properties.getService(), properties.getGroup(),这里就是订阅服务的地方了。我们看一些具体是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.running.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line"><span class="type">EventListener</span> <span class="variable">eventListener</span> <span class="operator">=</span> listenerMap.computeIfAbsent(buildKey(),</span><br><span class="line">event -&gt; <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> NamingEvent) &#123;</span><br><span class="line">List&lt;Instance&gt; instances = ((NamingEvent) event)</span><br><span class="line">.getInstances();</span><br><span class="line">Optional&lt;Instance&gt; instanceOptional = selectCurrentInstance(</span><br><span class="line">instances);</span><br><span class="line">instanceOptional.ifPresent(currentInstance -&gt; &#123;</span><br><span class="line">resetIfNeeded(currentInstance);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> nacosServiceManager</span><br><span class="line">.getNamingService(properties.getNacosProperties());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">namingService.subscribe(properties.getService(), properties.getGroup(),</span><br><span class="line">Arrays.asList(properties.getClusterName()), eventListener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;namingService subscribe failed, properties:&#123;&#125;&quot;</span>, properties, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.watchFuture = <span class="built_in">this</span>.taskScheduler.scheduleWithFixedDelay(</span><br><span class="line"><span class="built_in">this</span>::nacosServicesWatch, <span class="built_in">this</span>.properties.getWatchDelay());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用层级很深，最后来到的是HostReactor下的subscribe方法，里面有一个关键的 getServiceInfo(serviceName, clusters);这里就是过去服务信息了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceName, String clusters, EventListener eventListener)</span> &#123;</span><br><span class="line">        notifier.registerListener(serviceName, clusters, eventListener);</span><br><span class="line">        getServiceInfo(serviceName, clusters);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入这个方法内部，就是现在本地注册表中获取，如果没有这个服务那就先创建一个，然后向server发送get请求获取服务，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.debug(<span class="string">&quot;failover-mode: &quot;</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line"><span class="comment">// 构建key 请求格式为 groupId@@微服务ID@@cluster名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">        <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">            <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从当前client本地注册表中获取当前服务 本地注册表是个map </span></span><br><span class="line"><span class="comment">// key -&gt; groupId@@微服务ID@@cluster名称 value -&gt; serviceinfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="comment">// 如果为空 （第一次启动肯定是空的）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == serviceObj) &#123;</span><br><span class="line"><span class="comment">// 创建个空的服务 没有任何提供者实例</span></span><br><span class="line">            serviceObj = <span class="keyword">new</span> <span class="title class_">ServiceInfo</span>(serviceName, clusters);</span><br><span class="line">            <span class="comment">// 放入注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line">            <span class="comment">// 临时缓存 主要是使用这个缓存的key 不能重复 </span></span><br><span class="line"><span class="comment">// 只要服务名称出现在这个缓存map中，就表示这个服务正在被更新</span></span><br><span class="line">            updatingMap.put(serviceName, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"><span class="comment">// 开始更新服务</span></span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line"><span class="comment">// 更新完了 删掉</span></span><br><span class="line">            updatingMap.remove(serviceName);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line"><span class="comment">// 如果注册表中有了这个服务 而且临时缓存中有了这个服务</span></span><br><span class="line">            <span class="comment">// 那这个服务就是正在被更新 那就等一会儿</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATE_HOLD_INTERVAL &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// hold a moment waiting for update finish</span></span><br><span class="line">                <span class="keyword">synchronized</span> (serviceObj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serviceObj.wait(UPDATE_HOLD_INTERVAL);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        NAMING_LOGGER</span><br><span class="line">                                .error(<span class="string">&quot;[getServiceInfo] serviceName:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定时任务启动 定时更新本地注册表中的当前服务</span></span><br><span class="line">        scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们先来看 updateServiceNow(serviceName, clusters);这个方法就是调用了一个updateService方法，那直接来看updateService就好，里面就是获取本地注册表和远程注册表的服务，然后做一个合并操作，合并就是在processServiceJson(result);处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateService</span><span class="params">(String serviceName, String clusters)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">// 在本地注册表中获取当前服务 </span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldService</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 向server发送get请求 获取服务</span></span><br><span class="line">            <span class="comment">// 返回的serviceinfo是以json串形式出现的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> serverProxy.queryList(serviceName, clusters, pushReceiver.getUdpPort(), <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(result)) &#123;</span><br><span class="line"><span class="comment">// 将来自于server的serviceinfo更新到本地 </span></span><br><span class="line">                processServiceJson(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldService != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (oldService) &#123;</span><br><span class="line">                    oldService.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析processServiceJson(result);之前要达成一个共识，来自server的数据是一个最新的数据，其实就是合并新旧数据的过程，没什么特别的地方。至此，我们清楚了是如果请求server获取最新数据然后与本地合并了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">processServiceJson</span><span class="params">(String json)</span> &#123;</span><br><span class="line"><span class="comment">// 吧来自server的json处理为ServiceInfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> JacksonUtils.toObj(json, ServiceInfo.class);</span><br><span class="line"><span class="comment">// 本地注册表中的ServiceInfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldService</span> <span class="operator">=</span> serviceInfoMap.get(serviceInfo.getKey());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pushEmptyProtection &amp;&amp; !serviceInfo.validate()) &#123;</span><br><span class="line">            <span class="comment">//empty or error push, just ignore</span></span><br><span class="line">            <span class="keyword">return</span> oldService;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 本地注册表中存在当前服务 </span></span><br><span class="line">        <span class="keyword">if</span> (oldService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为了安全起见，默认服务器的数据是最新的</span></span><br><span class="line">            <span class="keyword">if</span> (oldService.getLastRefTime() &gt; serviceInfo.getLastRefTime()) &#123;</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;out of date data received, old-t: &quot;</span> + oldService.getLastRefTime() + <span class="string">&quot;, new-t: &quot;</span></span><br><span class="line">                        + serviceInfo.getLastRefTime());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把来自service的serviceinfo替换掉本地注册表的</span></span><br><span class="line">            serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 遍历本地注册表服务中的所有实例</span></span><br><span class="line">            Map&lt;String, Instance&gt; oldHostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Instance&gt;(oldService.getHosts().size());</span><br><span class="line">            <span class="keyword">for</span> (Instance host : oldService.getHosts()) &#123;</span><br><span class="line"><span class="comment">// ip:port 作为key，instance作为value放进去</span></span><br><span class="line">                oldHostMap.put(host.toInetAddr(), host);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历来自于server的服务的所有实例</span></span><br><span class="line">            Map&lt;String, Instance&gt; newHostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Instance&gt;(serviceInfo.getHosts().size());</span><br><span class="line">            <span class="keyword">for</span> (Instance host : serviceInfo.getHosts()) &#123;</span><br><span class="line"><span class="comment">// ip:port 作为key，instance作为value放进去</span></span><br><span class="line">                newHostMap.put(host.toInetAddr(), host);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该set存的是两个map old 与 new 都有的client </span></span><br><span class="line"><span class="comment">// 但他们的instance不同，会把来自server的instance写入</span></span><br><span class="line">            Set&lt;Instance&gt; modHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line"><span class="comment">// 只有newHostMap存在的intstance，也就是新增的</span></span><br><span class="line">            Set&lt;Instance&gt; newHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line"><span class="comment">// 只有oldHostMap有，也就是server端没有的instance</span></span><br><span class="line">            Set&lt;Instance&gt; remvHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line">            <span class="comment">// 遍历来自server的</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, Instance&gt;&gt; newServiceHosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Instance&gt;&gt;(</span><br><span class="line">                    newHostMap.entrySet());</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : newServiceHosts) &#123;</span><br><span class="line">                <span class="type">Instance</span> <span class="variable">host</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="comment">// 本地注册表中也有这个 ip:port 但是两个instance不同，就放入modMap</span></span><br><span class="line">                <span class="keyword">if</span> (oldHostMap.containsKey(key) &amp;&amp; !StringUtils</span><br><span class="line">                        .equals(host.toString(), oldHostMap.get(key).toString())) &#123;</span><br><span class="line">                    modHosts.add(host);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注册表中不存在这个ip:prot 那就写入到newMap 说明这个主机是新增的</span></span><br><span class="line">                <span class="keyword">if</span> (!oldHostMap.containsKey(key)) &#123;</span><br><span class="line">                    newHosts.add(host);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历本地注册表中服务的instane</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : oldHostMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">Instance</span> <span class="variable">host</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (newHostMap.containsKey(key)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注册表中存在  但是来自server的serviceInfo不存在</span></span><br><span class="line">                <span class="keyword">if</span> (!newHostMap.containsKey(key)) &#123;</span><br><span class="line"><span class="comment">// 加入到remvMap</span></span><br><span class="line">                    remvHosts.add(host);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增了 log</span></span><br><span class="line">            <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;new ips(&quot;</span> + newHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(newHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除了 log</span></span><br><span class="line">            <span class="keyword">if</span> (remvHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;removed ips(&quot;</span> + remvHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(remvHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发生变更了 </span></span><br><span class="line">            <span class="keyword">if</span> (modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 变更心跳 instance改了 心跳也要改才行</span></span><br><span class="line">                updateBeatInfo(modHosts);</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;modified ips(&quot;</span> + modHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(modHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            serviceInfo.setJsonFromServer(json);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span> || remvHosts.size() &gt; <span class="number">0</span> || modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 只要发生了变更，就把发生变更的serviceInfo记录到缓存队列中</span></span><br><span class="line">                NotifyCenter.publishEvent(<span class="keyword">new</span> <span class="title class_">InstancesChangeEvent</span>(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                        serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">                DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果本地注册表中没有本服务直接写入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;init new ips(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line"><span class="comment">// 将来自server的serviceInfo记录到注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">            NotifyCenter.publishEvent(<span class="keyword">new</span> <span class="title class_">InstancesChangeEvent</span>(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                    serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">           </span><br><span class="line">  serviceInfo.setJsonFromServer(json);</span><br><span class="line">            DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        MetricsMonitor.getServiceInfoMapSizeMonitor().set(serviceInfoMap.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;current ips:(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们把视线回到上面的  scheduleUpdateIfAbsent(serviceName, clusters);这是一个定时更新本地数据的任务，我们进入方法内部，主要的工作就是创建一个异步对象放入map中，注意这里是DCL，然后启动任务。要想知道这个异步任务到底是做什么的，必须看一下UpdateTask这个类的run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleUpdateIfAbsent</span><span class="params">(String serviceName, String clusters)</span> &#123;</span><br><span class="line"><span class="comment">// 这是个缓存map key为groupid@@微服务名@@cluster</span></span><br><span class="line"><span class="comment">// value 是个定时异步操作对象 </span></span><br><span class="line"><span class="comment">// private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; futureMap = new HashMap&lt;String, ScheduledFuture&lt;?&gt;&gt;();</span></span><br><span class="line"><span class="comment">// 如果有这个异步对象 就返回</span></span><br><span class="line"><span class="comment">// 这种结构称为DCL 防止并发情况下重复写入</span></span><br><span class="line">        <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (futureMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个定时异步对象</span></span><br><span class="line">            ScheduledFuture&lt;?&gt; future = addTask(<span class="keyword">new</span> <span class="title class_">UpdateTask</span>(serviceName, clusters));</span><br><span class="line"><span class="comment">// 把这个定时异步任务放入缓存map</span></span><br><span class="line">            futureMap.put(ServiceInfo.getKey(serviceName, clusters), future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>run方法的分析如下，就是更新注册表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delayTime</span> <span class="operator">=</span> DEFAULT_DELAY;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 在本地注册表获取当前服务</span></span><br><span class="line">                <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (serviceObj == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 本地不存在这个服务，从server拉取并更新到本地</span></span><br><span class="line">                    updateService(serviceName, clusters);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理本地注册表粗存在当前服务的情况</span></span><br><span class="line"><span class="comment">// lastRefTime 当前instanc最后被访问的时间</span></span><br><span class="line">                <span class="comment">// serviceObj.getLastRefTime() 当前服务最后被访问的时间 来源于这个服务里面的所有</span></span><br><span class="line">                <span class="comment">// 实例中最晚被访问的时间</span></span><br><span class="line">                <span class="keyword">if</span> (serviceObj.getLastRefTime() &lt;= lastRefTime) &#123;</span><br><span class="line">                    <span class="comment">//  当前注册表需要更新了</span></span><br><span class="line">                    updateService(serviceName, clusters);</span><br><span class="line">                    serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// if serviceName already updated by push, we should not override it</span></span><br><span class="line">                    <span class="comment">// since the push data may be different from pull through force push</span></span><br><span class="line">                    refreshOnly(serviceName, clusters);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将来自注册表的这个最后访问时间更新到当前client缓存中</span></span><br><span class="line">                lastRefTime = serviceObj.getLastRefTime();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!notifier.isSubscribed(serviceName, clusters) &amp;&amp; !futureMap</span><br><span class="line">                        .containsKey(ServiceInfo.getKey(serviceName, clusters))) &#123;</span><br><span class="line">                    <span class="comment">// abort the update task</span></span><br><span class="line">                    NAMING_LOGGER.info(<span class="string">&quot;update task is stopped, service:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isEmpty(serviceObj.getHosts())) &#123;</span><br><span class="line">                    incFailCount();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                delayTime = serviceObj.getCacheMillis();</span><br><span class="line">                resetFailCount();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                incFailCount();</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;[NA] failed to update serviceName: &quot;</span> + serviceName, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 开始下一次定时更新任务就好了 循环执行</span></span><br><span class="line">                executor.schedule(<span class="built_in">this</span>, Math.min(delayTime &lt;&lt; failCount, DEFAULT_DELAY * <span class="number">60</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Nacos定时更新本地服务的就是以上流程，我们可以用一张流程图来概括这整个步骤：</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203210117403.png" alt="Nacos Client定时更新本地服务(1)"></p><h4 id="Nacos-Client获取要调用的服务的提供者列表"><a href="#Nacos-Client获取要调用的服务的提供者列表" class="headerlink" title="Nacos Client获取要调用的服务的提供者列表"></a>Nacos Client获取要调用的服务的提供者列表</h4><p>首先说结论，客户端是需要调用的时候才懒加载进来服务提供者信息。客户端是基于Ribbon负载均衡来做的，我们进入Ribbon的配置类，关键点就是这个ZoneAwareLoadBalancer类，这是在调用的时候才会创建的一个配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ILoadBalancer <span class="title function_">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span><br><span class="line"><span class="params">ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span><br><span class="line"><span class="params">IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 只有服务真正发生调用的时候才会创建这个类</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZoneAwareLoadBalancer</span>&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在进入这个ZoneAwareLoadBalancer， 前面都是一些初始化赋值操作，后面的restOfInit(clientConfig)才是配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DynamicServerListLoadBalancer</span><span class="params">(IClientConfig clientConfig, IRule rule, IPing ping,</span></span><br><span class="line"><span class="params">                                         ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span></span><br><span class="line"><span class="params">                                         ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(clientConfig, rule, ping);</span><br><span class="line">        <span class="built_in">this</span>.serverListImpl = serverList;</span><br><span class="line">        <span class="built_in">this</span>.filter = filter;</span><br><span class="line">        <span class="built_in">this</span>.serverListUpdater = serverListUpdater;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AbstractServerListFilter) &#123;</span><br><span class="line">            ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">        &#125;</span><br><span class="line">        restOfInit(clientConfig);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入 restOfInit(clientConfig)，过滤掉不重要东西，然后我们可以观察到 updateListOfServers(); 根据方法名字我们就可以推断出来，这就是一个获取服务提供者列表的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">primeConnection</span> <span class="operator">=</span> <span class="built_in">this</span>.isEnablePrimingConnections();</span><br><span class="line">    <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">    <span class="built_in">this</span>.setEnablePrimingConnections(<span class="literal">false</span>);</span><br><span class="line">    enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">    updateListOfServers();</span><br><span class="line">    <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="built_in">this</span>.getPrimeConnections() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getPrimeConnections()</span><br><span class="line">                .primeConnections(getReachableServers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;</span>, clientConfig.getClientName(), <span class="built_in">this</span>.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进去，发现获取服务列表的是serverListImpl.getUpdatedListOfServers();这里。这其实是loadBlancer接口，里面定义了 获取服务的方法，我们如果要获取服务实例，都是要继承这个接口的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateListOfServers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="literal">null</span>) &#123;</span><br><span class="line">        servers = serverListImpl.getUpdatedListOfServers();</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>,</span><br><span class="line">                getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="literal">null</span>) &#123;</span><br><span class="line">            servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>,</span><br><span class="line">                    getIdentifier(), servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下哪些类实现了这个接口，很明显Nacos也实现了这个方法，那么我们就直接进去看看nacos具体如何做的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203211156633.png" alt="image-20220321115627566"></p><p>进入Nacos实现的这个方法内部，可以看到关键方法就是根据服务ID获取服务实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;NacosServer&gt; <span class="title function_">getServers</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> discoveryProperties.getGroup();</span><br><span class="line">            <span class="comment">// 根据服务ID获取服务实例</span></span><br><span class="line">List&lt;Instance&gt; instances = discoveryProperties.namingServiceInstance()</span><br><span class="line">.selectInstances(serviceId, group, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> instancesToServerList(instances);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;Can not get service instances from nacos, serviceId=&quot;</span> + serviceId,</span><br><span class="line">e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入方法内部，做的事情就是获取订阅的服务，然后根据返回的instance过滤出来可用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, String groupName, List&lt;String&gt; clusters, <span class="type">boolean</span> healthy,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> subscribe)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">       </span><br><span class="line">       ServiceInfo serviceInfo;</span><br><span class="line">       <span class="keyword">if</span> (subscribe) &#123;</span><br><span class="line">           <span class="comment">// 获取到要调用服务的serviceinfo</span></span><br><span class="line">           serviceInfo = hostReactor.getServiceInfo(NamingUtils.getGroupedName(serviceName, groupName),</span><br><span class="line">                   StringUtils.join(clusters, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           serviceInfo = hostReactor</span><br><span class="line">                   .getServiceInfoDirectlyFromServer(NamingUtils.getGroupedName(serviceName, groupName),</span><br><span class="line">                           StringUtils.join(clusters, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从所有服务列表中过滤出来可用的</span></span><br><span class="line">       <span class="keyword">return</span> selectInstances(serviceInfo, healthy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后进入具体的获取方法，我们之前已经解读过了，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.debug(<span class="string">&quot;failover-mode: &quot;</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line"><span class="comment">// 构建key 请求格式为 groupId@@微服务ID@@cluster名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">        <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">            <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从当前client本地注册表中获取当前服务 本地注册表是个map </span></span><br><span class="line"><span class="comment">// key -&gt; groupId@@微服务ID@@cluster名称 value -&gt; serviceinfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="comment">// 如果为空 （第一次启动肯定是空的）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == serviceObj) &#123;</span><br><span class="line"><span class="comment">// 创建个空的服务 没有任何提供者实例</span></span><br><span class="line">            serviceObj = <span class="keyword">new</span> <span class="title class_">ServiceInfo</span>(serviceName, clusters);</span><br><span class="line">            <span class="comment">// 放入注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line">            <span class="comment">// 临时缓存 主要是使用这个缓存的key 不能重复 </span></span><br><span class="line"><span class="comment">// 只要服务名称出现在这个缓存map中，就表示这个服务正在被更新</span></span><br><span class="line">            updatingMap.put(serviceName, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"><span class="comment">// 开始更新服务</span></span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line"><span class="comment">// 更新完了 删掉</span></span><br><span class="line">            updatingMap.remove(serviceName);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line"><span class="comment">// 如果注册表中有了这个服务 而且临时缓存中有了这个服务</span></span><br><span class="line">            <span class="comment">// 那这个服务就是正在被更新 那就等一会儿</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATE_HOLD_INTERVAL &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// hold a moment waiting for update finish</span></span><br><span class="line">                <span class="keyword">synchronized</span> (serviceObj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serviceObj.wait(UPDATE_HOLD_INTERVAL);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        NAMING_LOGGER</span><br><span class="line">                                .error(<span class="string">&quot;[getServiceInfo] serviceName:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定时任务启动 定时更新本地注册表中的当前服务</span></span><br><span class="line">        scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们看一下过来出来可用服务是如何做的，一句话就是过滤不健康的不可用的权重小于0的服务，返回正常的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(ServiceInfo serviceInfo, <span class="type">boolean</span> healthy)</span> &#123;</span><br><span class="line">    List&lt;Instance&gt; list;</span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="literal">null</span> || CollectionUtils.isEmpty(list = serviceInfo.getHosts())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Instance&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代这个服务的所有instance</span></span><br><span class="line">    Iterator&lt;Instance&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="comment">// 服务非健康的 非可用 权重&lt;=0，从列表中去除</span></span><br><span class="line">        <span class="keyword">if</span> (healthy != instance.isHealthy() || !instance.isEnabled() || instance.getWeight() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回可用instance列表</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nacos-Server源码分析"><a href="#Nacos-Server源码分析" class="headerlink" title="Nacos Server源码分析"></a>Nacos Server源码分析</h3><h4 id="重要API介绍"><a href="#重要API介绍" class="headerlink" title="重要API介绍"></a>重要API介绍</h4><ol><li><p>InstanceController 处理客户端请求例如订阅 心跳</p></li><li><p>Service 代表了一个服务 （Service of Nacos server side） 引入了一个Service Cluster Instance模型，也就是一个实例集合，类似客户端的ServiceInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3470985546826874460L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * protect threshold.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 保护阈值 默认是0.8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">protectThreshold</span> <span class="operator">=</span> <span class="number">0.0F</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * application name of this service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group to classify services into different sets.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>RecordListener 数据监听接口 实现了这个接口Service就是一个监听器 范型指定正在监听的数据类型 Record instance也是继承了这个，所以 RecordListener 监听的各个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecordListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Record</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the listener was registered with this key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key candidate key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the listener was registered with this key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 判断监听器是否监听了这个key</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">interests</span><span class="params">(String key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the listener is to be removed by matching the &#x27;key&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if match success</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 判断监听器是否已经移除了这个key</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matchUnlistenKey</span><span class="params">(String key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Action to do if data of target key has changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   target key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value data of the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// key变化触发这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(String key, T value)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Action to do if data of target key has been removed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key target key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 指定key的数据被删除 触发这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDelete</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Record Nacos集群中传递的记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Record</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get the checksum of this record, usually for record comparison.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> checksum of record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getChecksum</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ServiceManager 是RecordListener<Intance>的实现类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceManager</span> <span class="keyword">implements</span> <span class="title class_">RecordListener</span>&lt;Service&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map(namespace, Map(group::serviceName, Service)).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 就是注册表了 外层是namespace 内层map key-&gt;serviceId value-&gt;service对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 来自于其他nacos变更数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingDeque&lt;ServiceKey&gt; toBeUpdatedServicesQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 同步器 service状态同步器 nacos集群同步用的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Synchronizer</span> <span class="variable">synchronizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceStatusSynchronizer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 一致性服务 基于raft数据同步的</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;consistencyDelegate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ConsistencyService consistencyService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SwitchDomain switchDomain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DistroMapper distroMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerMemberManager memberManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PushService pushService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RaftPeerSet raftPeerSet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxFinalizeCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">putServiceLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.auto-clean:false&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> emptyServiceAutoClean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.clean.initial-delay-ms:60000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cleanEmptyServiceDelay;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.clean.period-time-ms:20000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cleanEmptyServicePeriod;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Cluster 集群的实现，里面有两个集合为临时实例集合和持久实例集合，然后它属于一个Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cluster</span> <span class="keyword">extends</span> <span class="title class_">com</span>.alibaba.nacos.api.naming.pojo.Cluster <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLUSTER_NAME_SYNTAX</span> <span class="operator">=</span> <span class="string">&quot;[0-9a-zA-Z-]+&quot;</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8940123791150907510L</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * a addition for same site routing, can group multiple sites into a region, like Hangzhou, Shanghai, etc.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sitegroup</span> <span class="operator">=</span> StringUtils.EMPTY;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">defCkport</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">defIpPort</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> HealthCheckTask checkTask;</span><br><span class="line"><span class="comment">// 持久实例集合</span></span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Set&lt;Instance&gt; persistentInstances = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 临时实例集合</span></span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Set&lt;Instance&gt; ephemeralInstances = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Service service;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">inited</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>Instance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instance</span> <span class="keyword">extends</span> <span class="title class_">com</span>.alibaba.nacos.api.naming.pojo.Instance <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MAX_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">10000.0D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MIN_POSITIVE_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">0.01D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MIN_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">0.00D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6527721638428975306L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastBeat</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JsonIgnore</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">mockValid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 不健康状态的标记 为true的时候就表示实例为不健康 当前实例被标记</span></span><br><span class="line">    <span class="comment">// 对于临时实例，永久为false 即该属性对临时实例没有意义</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String tenant;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String app;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ONLY_DIGIT_AND_DOT</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d|\\.)+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLITER</span> <span class="operator">=</span> <span class="string">&quot;_&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Server-处理client注册请求"><a href="#Server-处理client注册请求" class="headerlink" title="Server 处理client注册请求"></a>Server 处理client注册请求</h4><p>InstanceController就是处理和实例相关的信息，我们定位到这个类直接根据方法名找到对应方法就可以阅读源码了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos-Tutorial&quot;&gt;&lt;a href=&quot;#Nacos-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;Nacos Tutorial&quot;&gt;&lt;/a&gt;Nacos Tutorial&lt;/h1&gt;&lt;h2 id=&quot;Nacos总览&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
    <category term="SpringCloud Alibaba" scheme="http://example.com/tags/SpringCloud-Alibaba/"/>
    
  </entry>
  
</feed>
