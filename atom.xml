<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰色と青</title>
  
  <subtitle>Eurekawm&#39;s Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-29T11:45:36.725Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>sean</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM面试大纲</title>
    <link href="http://example.com/2022/03/28/JVM%E9%9D%A2%E8%AF%95%E5%A4%A7%E7%BA%B2/"/>
    <id>http://example.com/2022/03/28/JVM%E9%9D%A2%E8%AF%95%E5%A4%A7%E7%BA%B2/</id>
    <published>2022-03-28T09:50:14.000Z</published>
    <updated>2022-03-29T11:45:36.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM面试大纲"><a href="#JVM面试大纲" class="headerlink" title="JVM面试大纲"></a>JVM面试大纲</h1><h3 id="JVM-类加载的整体流程"><a href="#JVM-类加载的整体流程" class="headerlink" title="JVM 类加载的整体流程"></a>JVM 类加载的整体流程</h3><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。(初次获取Class文件字节流)  —加载 loader.findClass()</li><li>Class文件验证            —链接 –验证—文件格式验证</li><li>将这个字节流所代表的**静态存储(class文件本身)**结构转化为方法区的运行时数据结构。 – 加载</li><li>在Java堆里面生成这个类的java.lang.Class对象 作为方法区这个类的各种数据的访问入口 – 加载</li><li>元数据验证      <strong>– 链接-验证-元数据验证</strong></li><li>字节码验证   <strong>– 链接-验证-元数据验证</strong></li><li>准备              – 链接-准备</li><li>解析              链接–解析 符号引用-</li><li>初始化       – 初始化 <cinit></li></ol><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203281801537.png" alt="image-20220328180131499"></p><h3 id="加载阶段JVM具体做的什么操作"><a href="#加载阶段JVM具体做的什么操作" class="headerlink" title="加载阶段JVM具体做的什么操作"></a>加载阶段JVM具体做的什么操作</h3><p>“加载”是类加载的一个最初始的阶段，在加载阶段JVM需要完成以下三件事情：</p><ol><li>根据一个全限定类名来获取这个类的二进制流数据（初次获取Class文件字节流）</li><li>把这个字节流所代表的静态存储（class文件本身）转为方法区的运行时数据结构</li><li>在Java堆里面生成一个java.lang.Class，作为方法去这个类的各种数据的访问入口 比如Method。</li></ol><p>一般我们弄接触到的就是获取类的二进制流数据，开发人员自己写类加载器重写一下findClass() loadClass()自定义获取二进制流的行为</p><h3 id="加载数据和加载类有什么区别"><a href="#加载数据和加载类有什么区别" class="headerlink" title="加载数据和加载类有什么区别"></a>加载数据和加载类有什么区别</h3><p>对于数据而言，数据本身不是通过类加载器来创建的，而是在内存中动态构造出来的，但是数据的元素类型是需要类加载器来完成的，一个数据类创建过程遵循以下规则：</p><ol><li>如果数组的元素是引用类型的，那就先遵循类加载过程去加载这个组件，然后数据C将会被标志在加载该组件的类型的类加载器的类名称空间上（一个类型必须与类加载器一起确定唯一性）</li><li>如果数组的组件类型不是引用类型的，比如int[]，那么JVM会把数组C标记为与引导类加载器关联</li><li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访 问性将默认为public，可被所有的类和接口访问到。</li></ol><h3 id="验证阶段做了什么"><a href="#验证阶段做了什么" class="headerlink" title="验证阶段做了什么"></a>验证阶段做了什么</h3><p>验证是链接的第一步，这一步的目的是保障Class文件的字节流中包含的信息符合JVM规范，保障这些信息不会危害JVM。</p><p>验证阶段是很重要的，决定了JVM会不会收到恶意代码的攻击，从代码量和耗时的执行性能角度上讲，这一阶段在类加载过程中是相对比较耗时</p><p>从整体来看验证阶段是以下四个检验动作</p><ol><li><p>文件格式验证：要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能 包括下面这些验证点。</p><ol><li>以魔数0xCAFEBABE开头。 </li><li>主、次版本号是否在当前Java虚拟机接受范围之内。 ·常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 </li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li></ol><p>这个阶段是保证了二进制流是可以进入JVM内部去存储的，后面三个验证阶段是基于方法区的存储结构上进行的，不会再读取操作字节流了。</p></li><li><p>元数据验证：对字节码进行语义分析，保障他的描述信息符合《Java语言规范》的要求，比如这个类是否有父类（所有类应该都有父类），这个类是否继承了不应该被继承的父类等等，一句话说就是这个类是否是一个语义正确的类</p></li><li><p>字节码验证：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合 法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体**(Class文 件中的Code属性)进行校验分析**，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。比如操作数栈上面不能放一个long</p></li><li><p>符号引用验证： 把符号引用转位直接引用的时候，是在解析阶段中发生，符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下<br>列内容:</p><ol><li>符号引用通过字符串描述的全限定类名能否找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li></ol></li></ol><p>符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一 个java.lang.IncompatibleClassChangeError的子类异常，典型的如:java.lang.IllegalAccessError、 java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p><h3 id="JVM在准备阶段做了什么"><a href="#JVM在准备阶段做了什么" class="headerlink" title="JVM在准备阶段做了什么"></a>JVM在准备阶段做了什么</h3><p>将类变量也就是静态变量赋初始值，初始值就是类型的零值比如int的的零值是0，boolean的零值是false。final变量是在编译期就确定了的。</p><h3 id="JVM在解析阶段做了什么"><a href="#JVM在解析阶段做了什么" class="headerlink" title="JVM在解析阶段做了什么"></a>JVM在解析阶段做了什么</h3><p>解析就是把JVM常量池中符号引用替换为直接引用的过程</p><p><strong>符号引用</strong>(Symbolic References):符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面 量，只要使用时能无歧义地定位到目标即可。<br> <strong>直接引用</strong>(Direct References):直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位 到目标的句柄。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p><h3 id="类加载的初始化阶段做了什么"><a href="#类加载的初始化阶段做了什么" class="headerlink" title="类加载的初始化阶段做了什么"></a>类加载的初始化阶段做了什么</h3><p>初始化是类加载的最后一个阶段，之前介绍的几个类加载的动作里，除了在加载阶段用户 应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p><p>在准备阶段，类变量已经有一次初始赋值了，在初始化阶段，JVM收集静态变量的赋值动作，然后进行一次赋值，内容就是我们代码中的想赋予的值。这是由<cinit> 完成的，这是一个类构造器，他是自动生成的。</p><h3 id="什么时候JVM立即会对类进行初始化操作"><a href="#什么时候JVM立即会对类进行初始化操作" class="headerlink" title="什么时候JVM立即会对类进行初始化操作"></a>什么时候JVM立即会对类进行初始化操作</h3><ol><li>遇到了new getstatic putstatic invokestatic这几个字节码操作的时候，且没有加载类<ul><li>new 创建对象</li><li>获取设置一个静态变量</li><li>调用静态方法</li></ul></li><li>使用反射调用的时候java.lang.reflect，如果类没初始化，那么要先加载</li><li>虚拟机启动的时候加载一些默认的类</li><li>初始化类的时候发现父类还没初始化，优先初始化父类</li><li>一个接口定义了JDK8 的默认方法，如果这个类接口的实现类发生了初始化，那么接口要在之前初始化</li></ol><h3 id="什么情况下一个类才是相同的"><a href="#什么情况下一个类才是相同的" class="headerlink" title="什么情况下一个类才是相同的"></a>什么情况下一个类才是相同的</h3><p><strong>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共 同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个 独立的类名称空间。这句话可以表达得更通俗一些:比较两个类是 否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有 意义，否则，即使这两个类来源于同一个Class文件，被同一个 Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必 定不相等。</strong></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>启动类加载器(Bootstrap Class Loader):这个类加载器负责加载存放在 <JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的， 而且是Java虚拟机能够识别的(按照文件名识别，如rt.jar、tools.jar，名字不符 合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机的内存中。启动 类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要 把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</p><p>扩展类加载器(Extension Class Loader):这个类加载器是在类 sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载 <JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所 有的类库。</p><p>应用程序类加载器(Application Class Loader):这个类加载器由 sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是 ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也 称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库， 开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义 过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>除了引导类加载器，其他加载器都是有父类，他们的关系是组合而不是继承。</p><p>双亲委派机制的工作流程：一个类加载器收到加载请求，他自己不会加载这个类，而是交给父类加载器去。每层加载都是如此，直到把加载请求传递到顶级也就是系统类加载器。只有当父类无法加载的时候这个加载请求(它的搜索范围中没有找到所 需的类)时，子加载器才会尝试自己去完成加载。</p><p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。(<strong>翻看上一题 190, 想要确定一个加载一个类的唯一性，是需要由类加载器和类共同验证才能生 效的。</strong>)</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282044338.png" alt="image-20220328204450296"></p><h3 id="运行时栈结构"><a href="#运行时栈结构" class="headerlink" title="运行时栈结构"></a>运行时栈结构</h3><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”(Stack Frame)则是用 于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运 行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储 了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一 个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面 从入栈到出栈的过程。</p><p>在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的 操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。 换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的 影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p><p>对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的， 只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”(Current Stack Frame)，与这个栈帧所关联的方法被称为“当前方法”(Current Method)。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操 作。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282049654.png" alt="image-20220328204933615"></p><h3 id="什么是局部变量表"><a href="#什么是局部变量表" class="headerlink" title="什么是局部变量表"></a>什么是局部变量表</h3><p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。 在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量 表的最大容量。</p><p>局部变量表的容量以变量槽(Variable Slot)为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应 占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、byte、char、short、int、 float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储，但这 种描述与明确指出“每个变量槽应占用32位长度的内存空间”是有本质差别的，它允许变量槽的长度可以随着处理 器、操作系统或虚拟机实现的不同而发生变化。</p><p>对于64位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java语言中明确的64位 的数据类型只有long和double两种。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两 个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282057356.png" alt="image-20220328205727324"></p><h3 id="栈帧的局部变量表是如何定位变量的-是如何完成实参到形参传递的"><a href="#栈帧的局部变量表是如何定位变量的-是如何完成实参到形参传递的" class="headerlink" title="栈帧的局部变量表是如何定位变量的?是如何完成实参到形参传递的?"></a><strong>栈帧的局部变量表是如何定位变量的?是如何完成实参到形参传递的?</strong></h3><p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如 果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说 明会同时使用第N和N+1两个变量槽。对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用 任何方式单独访问其中的某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟 机就应该在类加载的校验阶段中抛出异常。</p><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的 传递。如果执行的是实例方法(没有被static修饰的方法)，那局部变量表中第0位索引的变量槽默认是用于传递 方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序 排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 变量槽。</p><h3 id="说说栈帧中的操作数栈"><a href="#说说栈帧中的操作数栈" class="headerlink" title="说说栈帧中的操作数栈"></a><strong>说说栈帧中的操作数栈</strong></h3><p>操作数栈(Operand Stack)也常被称为操作栈，它是一个后入先出(Last In First Out，LIFO)栈。同局部变 量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每 一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类 型所占的栈容量为2。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令 往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作 数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传 递。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个 元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新 入栈。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282106139.png" alt="image-20220328210644102"></p><h3 id="栈帧中的动态链接和返回地址有什么作用"><a href="#栈帧中的动态链接和返回地址有什么作用" class="headerlink" title="栈帧中的动态链接和返回地址有什么作用"></a><strong>栈帧中的动态链接和返回地址有什么作用</strong></h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段 或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在<strong>每一次运行期间都转化为直接引用，这部分就称为动态连接</strong>。</p><p>当一个方法开始执行后，只有两种方式退出这个方法。一个是正常退出，另外一个是异常退出。无论 采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行， 方法返回时<strong>可能需要</strong>在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说， 方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。 而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有:恢复上层方法的局部 变量表和操作数栈，把返回值(如果有的话)压入调用者栈帧的操作数栈中，调整PC计数器的值以指 向方法调用指令后面的一条指令等。</p><h3 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h3><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282131886.png" alt="image-20220328213132846"></p><h3 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h3><p>PCR(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执 行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这 个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、 跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何 一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指 令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数 器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，<strong>这个计数器记录的是正在执行的虚拟机字节码指令的地 址</strong>;如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。此内存区 域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="方法区主要是存储什么数据的"><a href="#方法区主要是存储什么数据的" class="headerlink" title="方法区主要是存储什么数据的"></a><strong>方法区主要是存储什么数据的</strong></h3><p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开 发、部署程序，很多人都更愿意把方法区称呼为“永久代”(Permanent Generation)，或将两者混为一谈。本质上 这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说 使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门 为方法区编写内存管理代码的工作。</p><p>到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来 代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。</p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者 可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非 数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型 的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的 回收有时又确实是必要的。</p><h3 id="运行时常量池和Class的文件结构的常量池有什么区别和联系"><a href="#运行时常量池和Class的文件结构的常量池有什么区别和联系" class="headerlink" title="运行时常量池和Class的文件结构的常量池有什么区别和联系"></a>运行时常量池和Class的文件结构的常量池有什么区别和联系</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接 口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间 也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OOM异常。</p><h3 id="什么是直接内存"><a href="#什么是直接内存" class="headerlink" title="什么是直接内存"></a>什么是直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地 使用，而且也可能导致OutOfMemoryError异常出现。</p><p>在JDK 1.4中新加入了NIO(New Input&#x2F;Output)类，引入了一种基于通 道(Channel)与缓冲区(Buffer)的I&#x2F;O方式，它可以使用Native函数库 直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。</p><h3 id="说说下JVM堆内存中对象的内存布局"><a href="#说说下JVM堆内存中对象的内存布局" class="headerlink" title="说说下JVM堆内存中对象的内存布局"></a>说说下JVM堆内存中对象的内存布局</h3><p>三大数据区域：</p><ol><li>对象头</li><li>实例数据</li><li>对其填充</li></ol><p>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码 (HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在 32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它为“Mark Word”。对象需要存 储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自 身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结 构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟 机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4 个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。对象头的另外一部分是类型指针， 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><p>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内 容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到 虚拟机分配策略参数(-XX:FieldsAllocationStyle参数)和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops (Ordinary Object Pointers，OOPs)，从以上默认的分配策略中可以看到，相同宽度的字段总是被分 配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot 虚拟机的+XX:CompactFields参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类 变量的空隙之中，以节省出一点点空间。</p><p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何 对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者2 倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h3 id="64位Jvm，new-Object-新创建的对象在Java中占用多少内存"><a href="#64位Jvm，new-Object-新创建的对象在Java中占用多少内存" class="headerlink" title="64位Jvm，new Object()新创建的对象在Java中占用多少内存"></a>64位Jvm，new Object()新创建的对象在Java中占用多少内存</h3><p>markword 8 字节，因为 java 默认使用了calssPointer 压缩，classpointer 4 字节，对象实例0字节， padding 4 字节 因此是 16 字节 如果没开启 classpointer 默认压缩，markword 8 字节，classpointer 8 字节，对象实例0字节，padding 0 字节 也是 16 字节。</p><h3 id="对象是如何定位的"><a href="#对象是如何定位的" class="headerlink" title="对象是如何定位的"></a>对象是如何定位的</h3><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由 于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过 什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式 主要有使用句柄和直接指针两种。</p><p>如果使用<strong>句柄访问</strong>的话， Java堆中将可能会划分 出一块内存来作为句柄 池，reference中存储的 就是对象的句柄地址， 而句柄中包含了对象实 例数据与类型数据各自 具体的地址信息</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282253667.png" alt="image-20220328225345585"></p><p>如果使用直接指针访问 的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的 相关信息，reference中 存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282257462.png" alt="image-20220328225739429"></p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象 被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需 要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中 非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就虚拟机HotSpot而言，它主要使用第二种 方式进行对象访问。</p><h3 id="JVM如何判断对象是否存活"><a href="#JVM如何判断对象是否存活" class="headerlink" title="JVM如何判断对象是否存活"></a>JVM如何判断对象是否存活</h3><p>可达性分析算法</p><p>这个算法的基本思路就是通过 一系列称为“GC Roots”的根对 象作为起始节点集，从这些节点开始，根据引用关系向下搜 索，搜索过程所走过的路径称 为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282303272.png" alt="image-20220328230353232"></p><h3 id="什么是GC-Roots"><a href="#什么是GC-Roots" class="headerlink" title="什么是GC Roots"></a>什么是GC Roots</h3><ul><li>在虚拟机<strong>栈</strong>(栈帧中的本地变量表)<strong>中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用 到的参数、局部变量、临时变量等。</li><li>在<strong>方法区中类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</li><li>在<strong>方法区中常量引用的对象</strong>，譬如字符串常量池(String Table)里的引用。</li><li>在<strong>本地方法栈中JNI</strong>(即通常所说的Native方法)<strong>引用的对象</strong>。</li><li><strong>Java虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象(比如 NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器</li><li>所有被同步<strong>锁</strong>(synchronized关键字)<strong>持有的对象</strong></li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><h3 id="Java中的那些引用类型"><a href="#Java中的那些引用类型" class="headerlink" title="Java中的那些引用类型"></a>Java中的那些引用类型</h3><p>强软弱虚</p><ul><li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的 对象。 </li><li>·<strong>软引用</strong>是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常 前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出 异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 </li><li>·<strong>弱引用</strong>也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下 一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对 象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 ·</li><li><strong>虚引用</strong>也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全 不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目 的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来 实现虚引用。</li></ul><h3 id="对象不可达的时候JVM会立即回收吗"><a href="#对象不可达的时候JVM会立即回收吗" class="headerlink" title="对象不可达的时候JVM会立即回收吗"></a>对象不可达的时候JVM会立即回收吗</h3><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段， 要真正宣告一个对象死亡，至少要经历两次标记过程:</p><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之 中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p><p>如果不重写 说明这个对象已经寄了没挽回的余地 然后就让jvm清除</p><p>唯一挽回的余地就是重写的方法内部 让他重新被引用，然而这种挽回有且只有一次</p><h3 id="方法区有垃圾回收吗"><a href="#方法区有垃圾回收吗" class="headerlink" title="方法区有垃圾回收吗"></a>方法区有垃圾回收吗</h3><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，方法区垃圾收 集的“性价比”通常也是比较低的:在Java堆中，尤其是在新生代中，对常规应用进行一次 垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条 件，其区域垃圾收集的回收成果往往远低于此。</p><p> 方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型。</p><h3 id="几种垃圾回收算法和利弊"><a href="#几种垃圾回收算法和利弊" class="headerlink" title="几种垃圾回收算法和利弊"></a>几种垃圾回收算法和利弊</h3><ol><li><p>标记-清除算法</p><p>算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。 最基础的收集算法，是因为后续的收集算法大多 都是以标记-清除算法为基础，对其缺点进行改 进而得到的。它的主要缺点有两个:第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程 的执行效率都随对象数量增长而降低;第二个是内存空间的碎片化问题，标记、清除之后会产生 大量不连续的内存碎片，空间碎片太多可能会导 致当以后在程序运行过程中需要分配较大对象时 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282353093.png" alt="image-20220328235347049"></p></li><li><p>标记-复制算法</p><p>常被简称为复制算法。为了解决标记-清除 算法面对大量可回收对象时执行效率低的 问题，1969年Fenichel提出了一种称为“半 区复制”(Semispace Copying)的垃圾收集 算法，它将可用内存按容量划分为大小相 等的两块，每次只使用其中的一块。当这 一块的内存用完了，就将还存活着的对象 复制到另外一块上面，然后再把已使用过 的内存空间一次清理掉。如果内存中多数 对象都是存活的，这种算法将会产生大量 的内存间复制的开销，但对于多数对象都 是可回收的情况，算法需要复制的就是占 少数的存活对象，而且每次都是针对整个 半区进行内存回收，分配内存时也就不用 考虑有空间碎片的复杂情况，只要移动堆 顶指针，按顺序分配即可。这样实现简单， 运行高效，不过其缺陷也显而易见，这种 复制回收算法的代价是将可用内存缩小为 了原来的一半，空间浪费未免太多了一点。</p><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公 司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代 中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生 代的内存空间。</p><p>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化 的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、 ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel式 回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空 间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden 和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接 清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor 的大小比例是8∶1</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282355988.png" alt="image-20220328235504943"></p></li><li><p>标记-整理算法</p><p>标记-复制算法在对象存活率 较高时就要进行较多的复制操作，效率将会降低。更关键的 是，如果不想浪费50%的空间， 就需要有额外的空间进行分配 担保，以应对被使用的内存中 所有对象都100%存活的极端情 况，所以在老年代一般不能直 接选用这种算法。</p><p>针对老年代对象的存亡特征， 1974年Edward Lueders提出了另外一种有针对性的“标记-整理”(Mark-Compact)算法， 其中的标记过程仍然与“标记- 清除”算法一样，但后续步骤 不是直接对可回收对象进行清理，而是让所有存活的对象都 向内存空间一端移动，然后直 接清理掉边界以外的内存</p><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203282356934.png" alt="image-20220328235637888"></p></li></ol><h3 id="根节点枚举有了解过吗"><a href="#根节点枚举有了解过吗" class="headerlink" title="根节点枚举有了解过吗?"></a><strong>根节点枚举有了解过吗?</strong></h3><p>根节点枚举：就是找出所有的GC Roots 也就是STW</p><p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能<strong>保障一致性的快照</strong>中才得以进 行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中， 根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致 垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者(几乎)不会发生停顿 的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。</p><p>由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检 查完所有执行上下文和全局的引用位置，虚拟机是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决 方案里，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的。一旦类加载动作完成的时候，<strong>HotSpot就会把对象 内什么偏移量上是什么类型的数据计算出来</strong>，<strong>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位 置是引用</strong>。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查 找。</p><h3 id="什么是JVM的安全点"><a href="#什么是JVM的安全点" class="headerlink" title="什么是JVM的安全点"></a><strong>什么是JVM的安全点</strong></h3><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来:可能导致引用关 系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的 额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</p><p>实际上HotSpot也的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置被称为安全 点(Safepoint)。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开 始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待 时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。<strong>安全点位置的选取基本上是以“是否具有让程序长时 间执行的特征”为标准进行选定的</strong>，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的 原因而长时间执行，<strong>“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于 指令序列复用，所以只有具有这些功能的指令才会产生安全点。</strong></p><h3 id="如何在垃圾收集发生时让所有线程都跑到最近的安全点"><a href="#如何在垃圾收集发生时让所有线程都跑到最近的安全点" class="headerlink" title="如何在垃圾收集发生时让所有线程都跑到最近的安全点"></a>如何在垃圾收集发生时让所有线程都跑到最近的安全点</h3><p>有两种方案可供选择:<strong>抢先式中断(Preemptive Suspension)<strong>和</strong>主动式中断(Voluntary Suspension)<strong>，</strong>抢先 式中断</strong>不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有 用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在<strong>几乎 没有虚拟机</strong>实现<strong>采用抢先式中断来</strong>暂停线程响应GC事件。</p><p>而<strong>主动式中断</strong>的思想是当垃圾收集需要中断线程的时候，<strong>不直接对线程操作，仅仅简单地设置一个标志位</strong>，各个 <strong>线程</strong>执行过程时会不停地主动去轮询这个标志，一旦<strong>发现中断标志为真时就自己在最近的安全点上主动中断挂起</strong>。 <strong>轮询标志的地方和安全点是重合的</strong>，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为 了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p><h3 id="程序“不执行”的时候线程如何达到安全点"><a href="#程序“不执行”的时候线程如何达到安全点" class="headerlink" title="程序“不执行”的时候线程如何达到安全点?"></a><strong>程序“不执行”的时候线程如何达到安全点?</strong></h3><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行” 的时候呢?所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状 态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续 等待线程重新被激活分配处理器时间。对于这种情况，就必须<strong>引入安全区域(Safe Region)来解决</strong>。</p><p><strong>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化</strong>，因此，在这个区域中任意地方开始垃圾 收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p><p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发<br>起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是<br>否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，那线程就当作没<br>事发生过，继续执行;否则它就必须一直等待，直到收到可以离开安全区域的信号为止</p><h3 id="垃圾回收是如何处理跨代引用问题的"><a href="#垃圾回收是如何处理跨代引用问题的" class="headerlink" title="垃圾回收是如何处理跨代引用问题的?"></a><strong>垃圾回收是如何处理跨代引用问题的?</strong></h3><p><strong>跨代引用举例</strong>:假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可 能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中 所有对象来确保可达性分析结果的正确性，反过来也是一样。</p><p>并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(Partial GC)行为的垃圾收集器，典 型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，JVM 为了用尽量少的资源消耗解决跨代引用下的垃 圾回收问题，引入了<strong>记忆集</strong>。记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p><p>在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可 以了，并不需要了解这些跨代指针的全部细节。目前最常用的一种记忆集实现形式种称为“卡表”,卡表中的每个记 录精确到一块内存区域(每块内存区域称之为卡页)，该区域内有对象含有跨代指针。</p><p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个(或更多)对象的字段存在着跨代指针，那就将对 应卡表的数组元素的值标识为1，称为这个元素变脏(Dirty)，没有则标识为0。在垃圾收集发生时，只要筛选出 卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p><h3 id="说说垃圾回收器的三色标记理论"><a href="#说说垃圾回收器的三色标记理论" class="headerlink" title="说说垃圾回收器的三色标记理论"></a><strong>说说垃圾回收器的三色标记理论</strong></h3><p>了当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理 论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。 在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技 巧(如OopMap)的加持下，它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了。</p><p>“标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影 响就会波及几乎所有的垃圾收集器。</p><p>·<strong>白色</strong>:表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在 分析结束的阶段，仍然是白色的对象，即代表不可达。</p><p>·<strong>黑色</strong>:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过， 它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接(不经过灰 色对象)指向某个白色对象。</p><p>·<strong>灰色</strong>:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</p><h3 id="说说你所知道的垃圾回收器的种类"><a href="#说说你所知道的垃圾回收器的种类" class="headerlink" title="说说你所知道的垃圾回收器的种类"></a><strong>说说你所知道的垃圾回收器的种类</strong></h3><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291751151.png" alt="image-20220329175118105"></p><h3 id="说说Serial收集器的特点及使用场景"><a href="#说说Serial收集器的特点及使用场景" class="headerlink" title="说说Serial收集器的特点及使用场景"></a><strong>说说Serial收集器的特点及使用场景</strong></h3><p>该收集器是一个<strong>单线程工作的收集器</strong>，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程 去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必<strong>须暂停其他所有工作线程，直到它收集结束。</strong></p><p>迄今为止，它依然是HotSpot虚拟机运行在<strong>客户端模式</strong>下的<strong>默认新生代收集器</strong>，有着优于其他收集器的地方，那就是 简单而高效(与其他收集器的单线程相比)，对于内存资源受限的环境，它是所有收集器里<strong>额外内存消耗(Memory Footprint)最小</strong>的;对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心 做垃圾收集自然可以获得最高的单线程收集效率。在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配 给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代(仅仅是指新生代使用的内存，桌面 应用甚少超过这个容量)，垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频 繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以，Serial收集器对于运行在客户端模式下的虚拟 机来说是一个很好的选择。</p><h3 id="ParNew收集器是如何进行垃圾回收的"><a href="#ParNew收集器是如何进行垃圾回收的" class="headerlink" title="ParNew收集器是如何进行垃圾回收的"></a><strong>ParNew收集器是如何进行垃圾回收的</strong></h3><p>ParNew收集器<strong>实质上是Serial收集器的多线程并行版本</strong>，除了同时使用多条线程进行垃圾收集之外，其余的行为 包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器 完全一致，在实现上这两种收集器也共用了相当多的代码。</p><p>ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行 在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性 能无关但其实很重要的原因是:除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>在JDK 5发布时，HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器——CMS收集器。 这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线 程(基本上)同时工作。</p><p>遗憾的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作[1]， 所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器 是激活CMS后(使用-XX:+UseConcMarkSweepGC选项)的默认新生代收集器，也可以使用-XX:+&#x2F;- UseParNewGC选项来强制指定或者禁用它。</p><p>ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销， 该收集器在通过超线程(Hyper-Threading)技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集 器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好 处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多(譬如32个，现在CPU都是多核 加超线程设计，服务器达到或超过32个逻辑核心的情况非常普遍)的环境中，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291801259.png" alt="image-20220329180102218"></p><h3 id="Paralle-Scavenge垃圾收集器"><a href="#Paralle-Scavenge垃圾收集器" class="headerlink" title="Paralle Scavenge垃圾收集器"></a>Paralle Scavenge垃圾收集器</h3><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够<strong>并行收 集</strong>的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢?</p><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收 集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即:</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX: MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p><p>-XX:MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变 得更快，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的:系统把新生代调得小一些，收集 300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100 毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p><p>-XX:GCTimeRatio参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞 吐量的倒数。譬如把此参数设置为<strong>19</strong>，那允许的最大垃圾收集时间就占总时间的5%(<strong>即1&#x2F;(1+19)</strong>)，默认值为<strong>99</strong>， 即允许最大1%(<strong>即1&#x2F;(1+99)</strong>)的垃圾收集时间。</p><p>由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。除上述两个参数之外， Parallel Scavenge收集器还有一个参数-XX:+<strong>UseAdaptiveSizePolicy</strong>值得我们关注。这是一个开关参数，当这个 参数被激活之后，就不需要人工指定新生代的大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRatio)、 晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性 能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适 应的调节策略(GC Ergonomics)</p><h3 id="说说Serial-Old收集器的特点及使用场景"><a href="#说说Serial-Old收集器的特点及使用场景" class="headerlink" title="说说Serial Old收集器的特点及使用场景"></a><strong>说说Serial Old收集器的特点及使用场景</strong></h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法。这个收集器的主 要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途:一种是在 JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后 备预案，在并发收集发生Concurrent Mode Failure时使用。</p><p>需要说明一下，Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非直接调 用Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现几乎是一样的，所以在官方的许多资 料中都是直接以Serial Old代替PS MarkSweep进行讲解</p><h3 id="说说Parallel-Old收集器的特点及使用场景"><a href="#说说Parallel-Old收集器的特点及使用场景" class="headerlink" title="说说Parallel Old收集器的特点及使用场景"></a><strong>说说Parallel Old收集器的特点及使用场景</strong></h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器 是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果 新生代选择了Parallel Scavenge收集器，老年代除了Serial Old(PS MarkSweep)收集器以外别无选择，其他表现良 好的老年代收集器，如CMS无法与它配合工作。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用 Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分 利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总 吞吐量甚至不一定比ParNew加CMS的组合来得优秀。</p><p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器 资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p><h3 id="说说CMS收集器的特点"><a href="#说说CMS收集器的特点" class="headerlink" title="说说CMS收集器的特点"></a><strong>说说CMS收集器的特点</strong></h3><p>CMS(<strong>Concurrent Mark Sweep</strong>)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java 应用集中在互联网网站或者基于浏览器的B&#x2F;S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字(包含“Mark Sweep”)上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几 种收集器来说要更复杂一些，整个过程分为<strong>四个步骤</strong>，包括:<br> 1)初始标记(CMS initial mark)</p><p>2)并发标记(CMS concurrent mark)</p><p>3)重新标记(CMS remark)</p><p>4)并发清除(CMS concurrent sweep)</p><p>其中<strong>初始标记、重新标记这两个步骤仍然需要“Stop The World”</strong>。初始标记仅仅只是标记一下GC Roots能直接关联 到的对象，速度很快;并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较 长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行;而重新标记阶段则是为了修正并发标记期间，因 用户程序继续运作而导致标记产生变动的那一部分对象的标记记录(详见220题中关于增量更新的讲解)，这个阶 段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短;最后是并发清除阶段，清理删除 掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291854073.png" alt="image-20220329185456029"></p><h3 id="CMS收集器有什么缺点吗"><a href="#CMS收集器有什么缺点吗" class="headerlink" title="CMS收集器有什么缺点吗"></a><strong>CMS收集器有什么缺点吗</strong></h3><p>CMS是一款优秀的收集器，它最主要的优点在名字上已经体现出来:并发收集、低停顿，一些官方公开文档里面 也称之为“并发低停顿收集器”(Concurrent Low Pause Collector)。CMS收集器是HotSpot虚拟机追求低停顿的第 一次成功尝试，但是它还远达不到完美的程度，至少有以下<strong>三个明显的缺点</strong>:</p><p>首先，CMS收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段， 它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢， 降低总吞吐量。<strong>CMS默认启动的回收线程数是(处理器核心数量+3)&#x2F;4</strong>，也就是说，如果处理器核心数在四个或 以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。 但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高， 还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。为了缓解这种情况， 虚拟机提供了一种称为“<strong>增量式并发收集器</strong>”(Incremental Concurrent Mark Sweep&#x2F;i-CMS)的CMS收集器变种，所 做的事情和以前单核处理器年代PC机操作系统靠抢占式多任务来模拟多核并行多任务的思想一样，是在并发标记、 清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间，这样整个垃圾收集的 过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变慢的时间更多了，但速度下降幅度就没 有那么明显。实践证明增量式的CMS收集器效果很一般，从JDK 7开始，i-CMS模式已经被声明为“deprecated”， 即已过时不再提倡用户使用，<strong>到JDK 9发布后i-CMS模式被完全废弃</strong>。</p><p>然后，由于CMS收集器无法处理“浮动垃圾”(Floating Garbage)，有可能出现“Con-current Mode Failure”失败进 而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运 行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样 也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此 CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集 时的程序运作使用。在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保 守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX:CMSInitiatingOccu-pancyFraction 的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已 经默认提升至92%。但这又会更容易面临另一种风险:要是CMS运行期间预留的内存无法满足程序分配新对象的需 要，就会出现一次“并发失败”(Concurrent Mode Failure)，这时候虚拟机将不得不启动后备预案:冻结用户线程 的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数-XX: CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产 环境中根据实际应用情况来权衡设置。</p><p>还有最后一个缺点，在本节的开头曾提到，CMS是一款基于“标记-清除”算法实现的收集器，如 果对前面对垃圾回收器算法讲解还有印象的话，就可能想到这意味着收集结束时会有大量空间 碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩 余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的 情况。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMS-CompactAtFullCollection开 关参数(默认是开启的，此参数从JDK 9开始废弃)，用于在CMS收集器不得不进行Full GC时开 启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，(在Shenandoah和ZGC出 现前)是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者 们还提供了另外一个参数-XX:CMSFullGCsBefore-Compaction(此参数从JDK 9开始废弃)，这 个参数的作用是要求CMS收集器在执行过若干次(数量由参数值决定)不整理空间的Full GC之 后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整 理)。<strong>只能预防，不能根治。</strong></p><h3 id="说说你对-G1-垃圾回收器的了解"><a href="#说说你对-G1-垃圾回收器的了解" class="headerlink" title="说说你对 G1 垃圾回收器的了解"></a><strong>说说你对 G1 垃圾回收器的了解</strong></h3><p>Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器<strong>面向局部收 集</strong>的设计思路和<strong>基于Region的内存布局</strong>形式。</p><p>G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是(在比较长期的)未来可 以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用 (Deprecate)的收集器。如果对JDK 9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来 开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p><p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代(Minor GC)， 要么就是整个老年代(Major GC)，再要么就是整个Java堆(FullGC)。而G1跳出了这个樊笼，它可以面向堆 内存任何部分来组成回收集(Collection Set，一般简称CSet)进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的<strong>Mixed GC模式</strong>。</p><h3 id="G1收集器为什么能够建立可预测的停顿时间模型"><a href="#G1收集器为什么能够建立可预测的停顿时间模型" class="headerlink" title="G1收集器为什么能够建立可预测的停顿时间模型"></a><strong>G1收集器为什么能够建立可预测的停顿时间模型</strong></h3><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集 到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p><p>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空 间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿 时间(使用参数-XX:MaxGCPauseMillis指定，默认值是200毫秒)，优先处理回收价值收益最大的那些 Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收 方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p><h3 id="在并发标记阶段如何保证收集线程与用户线程互不干扰地运"><a href="#在并发标记阶段如何保证收集线程与用户线程互不干扰地运" class="headerlink" title="在并发标记阶段如何保证收集线程与用户线程互不干扰地运"></a><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运</strong></h3><p>CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照(SATB)算法来实现的。此外， 垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定 会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS(Top at Mark Start)的指针，把 Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址 都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认 它们是存活的，不纳入回收范围。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似， 如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而 产生长时间“Stop The World”。</p><h3 id="G1收集器回收步骤"><a href="#G1收集器回收步骤" class="headerlink" title="G1收集器回收步骤"></a>G1收集器回收步骤</h3><p>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下 一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而 且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p><p>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图， 找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB 记录下的在并发时有引用变动的对象。</p><p>最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少 量的SATB记录。</p><p>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成 本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决 定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉 及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p><p>从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291911230.png" alt="image-20220329191104180"></p><h3 id="JVM堆内存结构"><a href="#JVM堆内存结构" class="headerlink" title="JVM堆内存结构"></a>JVM堆内存结构</h3><p>把新生代分为一块较大的Eden空间和两块较小的Survivor 空间，每次分配内存只使用Eden和其中一块Survivor。发 生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次 性复制到另外一块Survivor空间上，然后直接清理掉Eden 和已用过的那块Survivor空间。HotSpot虚拟机默认Eden 和Survivor的大小比例是8∶1。</p><p>还有一个老年代</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291912776.png" alt="image-20220329191258730"></p><h3 id="新创建的对象可能直接分配到老年代吗"><a href="#新创建的对象可能直接分配到老年代吗" class="headerlink" title="新创建的对象可能直接分配到老年代吗"></a><strong>新创建的对象可能直接分配到老年代吗</strong></h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p>对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量 很庞大的数组。大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏 的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。</p><p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就<strong>提前触 发垃圾收集，以获取足够的连续空间才能安置好它们</strong>，而当复制对象时，大对象就意味着高额的内存复 制开销。<strong>HotSpot虚拟机提供了-XX:PretenureSizeThreshold参数，指定大于该设置值的对象直接在 老年代分配</strong>，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操 作。</p><h3 id="老年代存放的都是什么对象"><a href="#老年代存放的都是什么对象" class="headerlink" title="老年代存放的都是什么对象"></a><strong>老年代存放的都是什么对象</strong></h3><p>HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当 放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数 器，存储在对象头中。</p><p>对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移 动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁， 当它的年龄增加到一定程度(<strong>默认为15</strong>)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参 数**-XX:MaxTenuringThreshold**设置。</p><h3 id="JVM中对象的年龄必须达到-XX-MaxTenuringThreshold才能晋升老年-代吗-绝对吗"><a href="#JVM中对象的年龄必须达到-XX-MaxTenuringThreshold才能晋升老年-代吗-绝对吗" class="headerlink" title="JVM中对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年 代吗?绝对吗?"></a>JVM中对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年 代吗?绝对吗?</h3><p>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX: MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中<strong>相同年龄所有对象大小的总和</strong>大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX: MaxTenuringThreshold中要求的年龄。</p><h3 id="什么是空间分配担保"><a href="#什么是空间分配担保" class="headerlink" title="什么是空间分配担保"></a><strong>什么是空间分配担保</strong></h3><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查 看-XX:HandlePromotionFailure参数的设置值是否允许担保失败(Handle Promotion Failure); 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的;如果小于，或者-XX: HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</p><h3 id="什么是内存泄漏，与内存溢出有什么关系"><a href="#什么是内存泄漏，与内存溢出有什么关系" class="headerlink" title="什么是内存泄漏，与内存溢出有什么关系"></a><strong>什么是内存泄漏，与内存溢出有什么关系</strong></h3><p>内存泄漏:是指创建的对象已经没有用处，正常情况下应该会被垃圾收集器回收，但是由于该对象仍然被其他对象进行了无效引用，导致不能够被垃圾收集器及时清理，这种现象称之为内存泄漏。</p><p>内存泄漏会导致内存堆积，最终发生内存溢出，导致OOM。</p><p>发生内存泄漏大部分是由于程序代码导致的，排查方法一般是使用 visualVM 进行heap dump，查看占用 空间比较多的 class 对象，然后检查该对象的instances 以及 reference引用，最终定位到程序代码。</p><p>如果堆内存比较大，进行head dump 产生的资源消耗不可接受，可以尝试使用轻量级的jmap生成堆转储快照 分析，思路与使用可视化工具一样。</p><h3 id="什么对象逃逸-对象逃逸分析优化"><a href="#什么对象逃逸-对象逃逸分析优化" class="headerlink" title="什么对象逃逸 对象逃逸分析优化"></a>什么对象逃逸 对象逃逸分析优化</h3><p>逃逸分析的基本原理是:分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，<br>例如作为调用参数传递到其他方法中，这种称为方法逃逸;甚至还有可能被外部线程访问到，譬如赋值给可<br>以在其他线程中访问的实例变量，这种称为线程逃逸;从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。<br>优化有三种:栈上分配;标量替换;锁消除(或称同步消除)。</p><p>·<strong>栈上分配</strong>(Stack Allocations):在Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道 的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储 的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象， 还是回收和整理内存，都需要耗费大量资源。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分 配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会 逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着 方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线 程逃逸。</p><p>·<strong>标量替换</strong>(Scalar Replacement):若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型 (int、long等数值类型及reference类型等)都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果 一个数据可以继续分解，那它就被称为聚合量(Aggregate)，Java中的对象就是典型的聚合量。如果把一个Java对象 拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析 能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对 象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈 上(栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储)分配和读写之外，还可以为后续进一 步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单(不用考虑整个对象完整结构的分配)， 但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</p><p>·<strong>同步消除</strong>(Synchronization Elimination):线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不 会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以 安全地消除掉。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203291930936.png" alt="image-20220329193034885"></p><h3 id="JVM调优经验"><a href="#JVM调优经验" class="headerlink" title="JVM调优经验"></a>JVM调优经验</h3><p>VM调优情况十分复杂，各种情况都可能导致垃圾回收不能够达到预想的效果。对于场景问题，可以从如下几个 大方向进行设计:</p><ol><li><p>在大访问压力下，MinorGC 频繁，MinorGC 是针对新生代进行回收的，每次在MGC 存活下来的对象，会移动 到Survivor1区。先到这里为止，大访问压力下，MGC 频繁一些是正常的，只要MGC 延迟不导致停顿时间过长或 者引发FGC ，那可以适当的增大Eden 空间大小，降低频繁程度，同时要保证，空间增大对垃圾回收时间产生的 停顿时间增长也是可以接受的。继续说，如果MinorGC 频繁，且容易引发 Full GC。需要从如下几个角度进行分析。a:每次MGC存活的对象的 大小，是否能够全部移动到 S1区，如果S1 区大小 &lt; MGC 存活的对象大小，这批对象会直接进入老年代。注意 了，这批对象的年龄才1岁，很有可能再多等1次MGC 就能被回收了，可是却进入了老年代，只能等到Full GC 进 行回收，很可怕。这种情况下，应该在系统压测的情况下，实时监控MGC存活的对象大小，并合理调整eden和s 区的大小以及比例。还有一种情况会导致对象在未达到15岁之前，直接进入老年代，就是S1区的对象，相同年 龄的对象所占总空间大小&gt;s1区空间大小的一半，所以为了应对这种情况，对于S区的大小的调整就要考虑:尽 量保证峰值状态下，S1区的对象所占空间能够在MGC的过程中，相同对象年龄所占空间不大于S1区空间的一半， 因此对于S1空间大小的调整，也是十分重要的。</p></li><li><p>由于大对象创建频繁，导致Full GC 频繁。对于大对象，JVM专门有参数进行控制，-XX: PretenureSizeThreshold。超过这个参数值的对象，会直接进入老年代，只能等到full GC 进行回收，所以在系统 压测过程中，要重点监测大对象的产生。如果能够优化对象大小，则进行代码层面的优化，优化如:根据业务 需求看是否可以将该大对象设置为单例模式下的对象，或者该大对象是否可以进行拆分使用，或者如果大对象 确定使用完成后，将该对象赋值为null，方便垃圾回收。如果代码层面无法优化，则需要考虑:调高-XX: PretenureSizeThreshold参数的大小，使对象有机会在eden区创建，有机会经历MGC以被回收。但是这个参数的 调整要结合MGC过程中Eden区的大小是否能够承载，包括S1区的大小承载问题。b:这是最不希望发生的情况， 如果必须要进入老年代，也要尽量保证，该对象确实是长时间使用的对象，放入老年代的总对象创建量不会造 成老年代的内存空间迅速长满发生Full GC，在这种情况下，可以通过定时脚本，在业务系统不繁忙情况下，主动触发full gc。</p></li><li><p>MGC 与 FGC 停顿时间长导致影响用户体验。其实对于停顿时间长的问题无非就两种情况:a gc 真实回收过 程时间长，即real time时间长。这种时间长大部分是因为内存过大导致，导致从标记到清理的过程中需要对很大 的空间进行操作，导致停顿时间长。b:gc真实回收时间 real time 并不长，但是user time(用户态执行时间) 和 sys time(核心态执行时间)时间长，导致从客户角度来看，停顿时间过长。对于a情况，要考虑减少堆内存大 小，包括新生代和老年代，比如之前使用16G的堆内存，可以考虑将16G 内存拆分为4个4G的内存区域，可以单 台机器部署JVM逻辑集群，也可以为了降低GC回收时间进行4节点的分布式部署，这里的分布式部署是为了降低 GC垃圾回收时间。对于b情况，要考虑线程是否及时达到了安全点，通过-XX:+PrintSafepointStatistics和-XX: PrintSafepointStatisticsCount&#x3D;1去查看安全点日志，如果有长时间未达到安全点的线程，再通过参数-XX: +SafepointTimeout和-XX:SafepointTimeoutDelay&#x3D;2000两个参数来找到大于2000ms到达安全点的线程，这里 的2000ms可以根据情况自己设置，然后对代码进行针对的调整。除了安全点问题，也有可能是操作系统本身负 载比较高，导致处理速度过慢，线程达到安全点时间长，因此需要同时检测操作系统自身的运行情况。</p></li><li><p>内存泄漏导致的MGC和FGC频繁，最终引发oom。内存泄漏的排查参见面试题247.</p></li><li><p>纯代码级别导致的MGC和FGC频繁。如果是这种情况，那就只能对代码进行大范围的调整，这种情况就非常 多了，而且会很糟糕。如大循环体中的new 对象，未使用合理容器进行对象托管导致对象创建频繁，不合理的 数据结构使用等等。</p></li></ol><p>总之，JVM的调优无非就一个目的，在系统可接受的情况下达到一个合理的MGC和FGC的频率以及可接受的回收 时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM面试大纲&quot;&gt;&lt;a href=&quot;#JVM面试大纲&quot; class=&quot;headerlink&quot; title=&quot;JVM面试大纲&quot;&gt;&lt;/a&gt;JVM面试大纲&lt;/h1&gt;&lt;h3 id=&quot;JVM-类加载的整体流程&quot;&gt;&lt;a href=&quot;#JVM-类加载的整体流程&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化相关</title>
    <link href="http://example.com/2022/03/27/MySQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/03/27/MySQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/</id>
    <published>2022-03-27T09:56:07.000Z</published>
    <updated>2022-03-27T10:41:01.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="explain执行计划的几种坏情况"><a href="#explain执行计划的几种坏情况" class="headerlink" title="explain执行计划的几种坏情况"></a>explain执行计划的几种坏情况</h2><ol><li>Using join buffer (Block Nested Loop) 关联查询的时候没加索引</li><li>Using filesort 用了文件排序 数据是无序的，在文件或者是内存中作了排序 这种情况用覆盖索引来解决</li><li>Using temporary 使用了临时表，去重复，排序，DISTINCT GROUP BY ORDER BY 如果是无序的 要一个临时表来做这些东西 所以加一个索引就好了</li></ol><h2 id="索引注意事项"><a href="#索引注意事项" class="headerlink" title="索引注意事项"></a>索引注意事项</h2><ol><li>全值匹配</li><li>最左前缀</li><li>字段函数处理 索引失效</li><li>where条件上对加了索引的字段各种计算</li><li>类型转换导致索引失效     数据转到字符串要失效的 而字符转数字不会</li><li>范围查询右侧的列索引失效     这种情况把确定的放在前面，范围的放在后面</li><li>不等于操作 索引失效     这种相当于扫描了一大片</li><li>IS     NULL可以使用索引 IS NOT NULL不可以使用 IS NULL可以直接在b+树上面找，所以一般加一个非空约束     LIKE NOT LIKE同理</li><li>LIKE查询以%开头的，开头无法确定就无法走b+树     严禁左模糊或全模糊</li><li>OR前后存在非索引列，索引失效     比如前面用了索引，后面的全表扫描了，那不如不用</li><li>字符集的转换会导致索引失效     因此要统一字符集</li></ol><p>一般性建议：</p><ol><li>如果使用的是单列索引，尽量选择对当前query过滤性比较好的索引</li><li>使用组合索引，当前query过滤性越好的放在越前面</li><li>使用组合索引，使用包含了where子句中更多字段的索引</li><li>使用组合索引，有范围查询的时候，把查询字段放在索引最后面</li></ol><h2 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h2><ol><li>在左外连接关联查询的时候如果是不加索引，执行计划的extra里面会有一个Using join buffer，此时我们需要在被驱动表（右边的表）的条件上加上一个索引，来提升效率</li><li>对于内连接来说，查询优化器是可以决定谁作为驱动谁作为被驱动的，如果表的连接条件中，只能有一个字段作为索引，那么这个字段所在的表会被作为被驱动表，     如果连接条件都是有索引的，那么把小表作为驱动表</li><li>出现了Using join buffer(Blocked nested loop)给数据量大的表的连接条件加一个索引，不能加索引的时候，调整join buffer的大小，越大越好</li></ol><p>一般性建议：</p><ol><li>被驱动表的JOIN字段加了索引</li><li>需要JOIN的字段数据类型是一样的</li><li>LEFT JOIN的时候  选择小表为驱动表</li><li>INNER  JOIN的时候会MySQL会自己选择小表</li><li>能关联就不用子查询</li><li>衍生表不能建立索引</li></ol><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><p>子查询为什么效率不高</p><ol><li>子查询的时候会为内层查询结果建立一个临时表，然后外层查询从其中获得记录，查询完毕之后又销毁这些临时表，这样造成了大量的磁盘IO和CPU开销，产生大量的慢查询</li><li>子查询内层查询的临时表无论是在内存还是在磁盘都是没有索引的</li><li>对返回结果集比较大的子查询，对其查询性能的影响也比较大</li></ol><p>子查询优化</p><ol><li>优化成连接查询</li></ol><h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><p>MySQL中有两种排序方式 index 和 filesort</p><p>index方式是索引保证了有序性，不需要在排序了，效率更高</p><p>filesort一般是在内存中进行排序，占用更多cpu，如果排序的量比较大可能还要落盘，效率低</p><p>优化建议：</p><ol><li>在where 和 order by 子句中使用索引，目的是在where的时候避免全表扫描，order by 的时候避免使用filesort</li><li>尽量使用index完成order     by，如果where 和 order by是相同的列就用单索引，如果是不同就使用联合索引</li><li>无法使用index就要优化filesort</li></ol><p>ORDER BY的几种索引失效的情况</p><ol><li>order by的时候不加limit限制。这种情况优化器觉得是你大量的回表，然后在取数据，这种还不如全表走一遍然后再用filesort。优化方式就是不select *，而是用覆盖索引</li><li>order by 顺序错误</li><li>order by     规则不一致 比如实际上是以升序做的索引，但是order by的时候是降序（要反都反）</li></ol><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271813099.png" alt="未命名图片" style="zoom:50%;" /><ul><li><p>index不绝对比filesort快</p></li><li><p><strong>场景</strong>:<strong>查询年龄为</strong>30<strong>岁的，且学生编号小于</strong>101000<strong>的学生，按用户名称排序</strong> </p></li><li><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271815745.png" alt="未命名图片"></p></li></ul><p>Type是all，而且用了filesort， 全表扫描加文件排序，最差的一种情况，是需要优化的</p><p>方案1:为了去掉filesort我们在age和name上面建立一个索引</p><p>方案2:尽量让where的过滤条件和排序使用上索引，在age stuno name上建立联合索引</p><p>在这里第二种更快，虽然是用了filesort，但是条件范围已经过了了很多数据，然后即使再排序也是没关系的，只有很少的数据是需要排序的</p><p>结论：</p><ol><li>两个索引同时存在，MySQL自动选择最佳方案，随着数据量变化，索引也是会变化的</li><li>当范围条件和group     by和order by字段二选一的时候优先观察条件字段过滤的数据量，当过滤的数据量多，且需要排序的字段不多时，优先把索引放在条件字段上面</li></ol><h2 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a>分组优化</h2><p>分组和排序其实优化原理差不多</p><ol><li>group by是先排序再分组，按照左前缀法则</li><li>无法使用索引的时候，增大max_length_for_sort_data和sort_buffer_size</li><li>where效率高于having，能写在where的限定条件就不用having了</li><li>减少使用group by，order by，distinct这些操作，因为很耗cpu资源，可以放在业务中</li><li>包含了以上的查询的语句，where过滤出来的数量集在1000以内</li></ol><h2 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h2><p>一般分页查询的时候，通过创建索引可以比较好提升查询性能，但是有一个问题如果是limit 20000,10</p><p>那么MySQL实际查询的时候是丢弃了前面20000个记录，只返回了10个，代价是很大的</p><p>优化思路：</p><ol><li>在索引上面完成分页操作然后回表取值 EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id &#x3D; a.id</li><li>该方案适用于主键自增的情况，把limit转化为某个位置的查询 EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</li></ol><h2 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h2><p>什么是覆盖索引</p><p>一个索引包含了满足查询结果的数据就是覆盖索引</p><p>覆盖索引的利弊</p><p>优点：</p><ol><li>避免了回表。在覆盖索引上面就获取了所需的数据，避免了对主键的二次查询，减少了IO操作，提高了效率</li><li>随机IO变成了顺序IO。由于覆盖索引是按照值顺序来存储的，对于IO密集的范围查询，对比从磁盘读取每一行数据的IO要少很多（回表的时候，可能主键对应的数据是不在同一个页上面的，所以要进行多次IO加载数据页），因此是把随机IO变成了顺序IO</li></ol><p>缺点：</p><ol><li>索引字段的维护是有代价的，不好的索引既浪费了空间又不能加速查询</li></ol><h2 id="如何给字符串加索引"><a href="#如何给字符串加索引" class="headerlink" title="如何给字符串加索引"></a>如何给字符串加索引</h2><p>一般方法是前缀索引：</p><p>原因：</p><ol><li>如果一个字段很长，加索引的话就浪费了太多空间了</li></ol><p>前缀索引长度：</p><ol><li>如果长度不够可能出现重复的情况，那么就要判断多次，区分度越高，重复的键值就更少。区分度计算方法 count(distinct left(column,lent)) &#x2F; count(8)。按照阿里巴巴的规则一般20个字符长度的前缀索引区分度在90%以上</li><li>使用前缀索引的时候，定义好长度，既节约了空间也可以减少查询的成本。</li></ol><p>注意点：前缀索引会影响到覆盖索引的使用。</p><p>因为前缀索引截断了字符串，你无法通过这样的索引来获取整个列的值。就算你的前缀索引包含了所有的值，InnoDB还是会回表查询一次的。</p><p>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><p>场景：如何对身份证来做前缀索引</p><ol><li>前面6位是区号，重复的概率是很大的，因此如果要在做前缀索引的话，至少是要12位的。但是这样的浪费了太多空间，一个数据页存放的数据就变少了。</li><li>存储身份证的时候倒过来，这样后6位的区分度就很高了</li><li>加一个字段来存身份证的hash值     查询的时候SQL可以这样写：select userinfo from t where id_card_crc &#x3D;     crc32(‘user_id_card_number’) and id_card &#x3D; ‘user_id_card_number’，这样的话，索引就只占了4字节</li></ol><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优 化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数</p><p>例子：SELECT * FROM T WHERE key &gt; ‘a’ AND key LIKE ‘%b’</p><ol><li>如果没有ICP，这种查询是先找到满足key &gt; ‘a’ 的数据，然后回表判断，把符合条件LIKE ‘%b’的数据返回。这种可能需要回表的数据为100，然后筛选出来满足条件的数据为10个</li><li>开启了ICP的话，在查询的时候先找到key &gt;     ‘a’的数据，然后先不回表，再在索引里面判断一下是否满足LIKE ‘%b’这个条件，然后回表。这样操作可能回表的次数就只有10次了。</li></ol><p>使用ICP的话就先筛选了一些不满足条件的数据，然后在回表，这样就减少了回表的次数，也就减少了随机IO的发生。</p><p>案例：SELECT * FROM user WHERE name LIKE ‘张%’ AND age &#x3D;10 AND ismale &#x3D; 1</p><ol><li><p>不使用ICP的情况</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271824683.png" alt="1ds"></p></li><li><p>使用了ICP的情况<img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271825969.png" alt="121"></p></li></ol><p>ICP的使用条件</p><ol><li>只能用于二级索引，因为聚集索引这种情况，完整的记录已经被读入到innoDB缓冲区，这种情况ICP不能减少回表</li><li>explain     的type类型应该是range ref eq_ref ref_or_null</li><li>where条件的字段必须在索引列中才能用ICP筛选</li><li>ICP可以用于InnoDB和MyISAM引擎</li><li>当SQL使用覆盖索引的时候不能使用ICP优化（既然都不回表了当然不用ICP优化了）</li></ol><p>总结：ICP就是为了优化回表的</p><h2 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h2><p>案例：维护一个居民系统， 每个人都有唯一的身份证，业务端保证写入的身份证是唯一的</p><p>那么我们从性能角度考虑用唯一索引还是普通索引呢？<br> 建立一个表：</p><p>mysql&gt; create table test(</p><p>id int primary key,</p><p>k int not null,</p><p>name varchar(16),</p><p>index (k)</p><p>)engine&#x3D;InnoDB;</p><p>查询过程： select id from test where k&#x3D;5</p><ol><li>普通索引查询过程，查到第一个满足条件k&#x3D;5的继续找下一条，直到不满足条件</li><li>唯一索引，查到第一个满足条件k&#x3D;5，直接返回结果</li></ol><p>其实查询过程的性能差距很小，InnoDB是以数据页为单位的，因为两条数据是极大可能在一个页中，在内存中比较是很快的所以这两种索引，在查询的时候性能是差不多的</p><p>插入过程：</p><p>先介绍一下change buffer。如果要更新一个数据页的时候，如果这个数据页是没有在内存中，那么在不影响一致性的情况下，InnoDB会把这次更新写入到change buffer中，下次你要读这个页的时候，把这个页加载到内存中，然后进行一个merge 操作，把change buffer中和这个页有关的数据合并起来。这样做的原因一是减少了磁盘IO，而是每次插入记录如果要加载页到buffer pool，这其实是要占用内存的。change buffer是buffer pool里面的一部分，是不能无限增大的，可以通过innodb_change_buffer_size来限制。</p><p>唯一索引是不能使用change buffer的。原因是本身他已经是唯一约束了，比如我插入一个（4，400），先要判断一下是否有这个数据，这设计到加载一个页到内存中，既然你已经加载数据页到内存中了，那么就没必要把更新操作写在changebuffer中了。</p><p>现在开始分析插入数据的情况下两种索引的性能区别：</p><ol><li><p>要更新的目标页就在内存中： </p></li><li><ol><li>唯一索引：找到3，5之间的位置，判断是否有冲突，然后插入</li><li>普通索引：找到3，5之间的位置，直接插入</li></ol></li><li><p>要更新的页在磁盘中</p></li><li><ol><li>唯一索引：将数据页读人到内存中，判断有无冲突，插入</li><li>普通索引：将插入数据记录在change buffer中</li></ol></li></ol><p>将数据页读取到内存中是很重的操作，因此唯一索引在插入操作的时候是比普通索引性能低的，而普通索引插入数据的时候，使用了change buffer，减少了很多的磁盘IO。</p><p>change buffer的使用场景：</p><ol><li>change buffer只限于普通索引，不适用于唯一索引</li><li>对于写多读少的业务来说 change     buffer是很有用的，因为merge操作是要读取数据的时候才会进行的，在这之前写操作相当于是缓存到了change     buffer，那么尽量的少merge，也就是尽量缓存多点写操作是更好的（账单，日志）</li><li>如果是一个业务是写入后立即就要查询的，更新记录先写在change     buffer中然后立马加载数据页到内存然后merge，这样随机访问IO不会降低，还要维护change buffer，这种情况change     buffer起了反作用</li></ol><p>总结：</p><ol><li>唯一索引和普通索引在查询的时候性能是差不多的，在更新上建议使用普通索引，普通索引在和change buffer配合的时候，对于大数据量的写入是很好的。</li><li>如果写入伴随查询，建议关闭changebuffer。</li><li>由于唯一索引用不上change     buffer的优化，我们可以在业务上保证唯一性，然后使用索引的时候还是使用普通索引，如果碰上了大量插入行为， 系统性能下降，可以通过唯一索引这方面来排查。</li></ol><h2 id="其他优化点"><a href="#其他优化点" class="headerlink" title="其他优化点"></a>其他优化点</h2><h3 id="EXISTS-和-IN的区分"><a href="#EXISTS-和-IN的区分" class="headerlink" title="EXISTS 和 IN的区分"></a>EXISTS 和 IN的区分</h3><p>优化的时候还是要遵循小表驱动大表来的</p><p>例如：SELECT * FROM A WHERE A.id IN (SELECT code FROM B)</p><p>这种情况B的数据量小，就是一个小表驱动大表的例子。如果A表的数据量小，那么这个SQL就可以改为<br> SELECT * FROM A WHERE EXISTS (SELECT code FROM B WHERE B.code &#x3D; A.id)</p><p>优化的关键在于AB两表谁大谁小</p><h3 id="COUNT相关"><a href="#COUNT相关" class="headerlink" title="COUNT相关"></a>COUNT相关</h3><ol><li>count(*) count(1)是差不多的</li><li>使用MyISAM统计行数是O(1)的复杂度，InnoDB是O(n)级别。MyISAM表中有一个meta信息，里面有一个row_count来记录行数。     InnoDB只能全表扫描</li><li>count(具体字段)尽量来采取二级索引，如果是使用了聚集索引，就相当于把数据都在加载到内存中了，使用二级索引占用空间更小。count(*)     count(1)也是自动选一个占用空间更小的二级索引来统计的。</li></ol><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT(*)"></a>SELECT(*)</h3><p>尽量不使用这个原因如下：</p><ol><li>转换的时候会查询数据字典为把*转换为所有列名，大大耗费时间和资源</li><li>无法使用覆盖索引</li></ol><h3 id="LIMIT-1-优化"><a href="#LIMIT-1-优化" class="headerlink" title="LIMIT 1 优化"></a>LIMIT 1 优化</h3><ol><li>普通索引的情况，全表扫描的时候确定结果集只有一条，那么加上LIMIT 1，找到一条就不继续找了， 这样就加快了查询的时间</li><li>如果是使用的唯一索引就无效了</li></ol><h3 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h3><p>只要有可能，在代码中多使用COMMIT，这会释放这些资源：</p><ol><li>回滚段用于恢复数据的信息</li><li>被程序获取的锁</li><li>redo &#x2F; undo     log buffer 中的空间</li><li>管理上述3种资源的花费</li></ol><h2 id="MySQL-ACID特性"><a href="#MySQL-ACID特性" class="headerlink" title="MySQL ACID特性"></a>MySQL ACID特性</h2><ol><li>原子性：事务里面的操作要么都成功，要么都失败</li><li>一致性：一个事务执行前后从一个合法性状态到另一个合法性状态，语意上的合法性，而不是语法性的，和具体的业务是有关的 比如     A余额200 向B转账300，A的余额为-100，这时数据是不一致的，因为你定义了一个状态，余额必须&gt;&#x3D;0。A向B转了50，但是B没有增加，这时数据也是不一致的，因为你定义了一个状态，总额是不变的。</li><li>一个事务的执行是不能被其他事务干扰，一个事务内部的操作和使用的数据对并发的其他事务是隔离的，并发的事务是互不干扰的。</li><li>持久性：事务提交的时候，他对数据库中数据的改变是永久性的。</li></ol><p>总结：原子性是基础，隔离性是手段，一致性是约束条件，持久性是目的。</p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271830719.png" alt="21" style="zoom: 33%;" /><h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><h3 id="没有redo-log的时候两个问题"><a href="#没有redo-log的时候两个问题" class="headerlink" title="没有redo log的时候两个问题"></a>没有redo log的时候两个问题</h3><ol><li>修改量和刷盘的工作量不成正比，修改几条数据，但是刷盘的时候是以页为单位的，一次刷16KB</li><li>刷盘是一个随机IO过程</li></ol><p>一个优化的思路就是，修改数据之后先不刷盘，先记录一下修改了那些内容，比如把XX表空间XX页的XX行数据从XX修改为XX。InnoDB采用了WAL技术，也就是先写日志再写磁盘，只有日志写成功了，才算事务执行成功了。日志就是redo log，然后未刷盘的脏数据在MySQL崩溃的时候会丢失，没关系的，redo log可以恢复。</p><p>好处：</p><ol><li>降低了刷盘频率</li><li>redo log占用的空间小</li></ol><p>特点：</p><ol><li>redo log 是顺序写入的</li><li>事务执行的时候，redo     log是不断记录的</li></ol><p>redo log的组成</p><p>可以简单分为两个部分</p><ol><li>redo log buffer保存在内存中，是易失性的，服务启动的时候申请的一大片空间，是由多个redo log block组成的，一个block512kb，可以通过innodb_log_buffer_size设置redo     log buffer大小，默认16m，最大4GB，最小1m。 </li><li>redo log     file是在磁盘的，是持久的</li></ol><h3 id="更新数据redo-log的流转过程"><a href="#更新数据redo-log的流转过程" class="headerlink" title="更新数据redo log的流转过程"></a>更新数据redo log的流转过程</h3><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271834659.png" alt="12121"></p><ol><li>加载磁盘的数据页到内存buffer pool中</li><li>更新数据</li><li>WAL 先在内存中写redo log</li><li>把redo log     buffer写入到redo log file</li><li>定期刷脏数据</li></ol><p>redo log的刷盘策略：</p><p>redo log buffer 刷盘不是真的刷到磁盘中去，而是刷入到文件缓存中page cache中。真正的写入是由操作系统来决定的。redo log日志有3种策略刷盘。innodb_flush_log_ad_trx_commit来配置。</p><ol><li>设置为0，提交事务的时候不刷盘，系统默认 master thread 线程每秒一次同步</li><li>设置为1，提交事务立即刷盘 默认值</li><li>设置为2，提交事务的时候把redo log     buffer 写入到page cache中，然后由os决定刷盘时机</li></ol><p>redo log block 由日志头 数据区 日志尾3部分组成，分别为12 492 8字节，总计512字节。机械磁盘一个扇区也是512字节，所以磁盘对一个block的写入是原子性的。</p><p>redo log file相关参数设置：</p><ol><li>innodb_log_group_home_dir，redo log file存放的路径，这个路径有两个文件     ib_logfile0 ib_logfile1</li><li>innodb_log_files_in_group     redo log 文件个数</li><li>innodb_log_file_size     单个redo log文件大小，默认48M，如果写满了从头覆盖</li></ol><p>总结：redo log保证了事务的持久性</p><h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>undo log是事务原子性和一致性的保证，在事务更新数据的前置操作是写入到一个undo log的。</p><p>事务要保证原子性，要么都完成，要么都失败，但是有时候会出现执行到一半的情况。</p><ol><li>服务器本身的错误，比如操作系统错误，断电等等</li><li>输入rollback指令</li></ol><p> 针对这些情况，我们需要回滚数据，具体怎么回滚我们需要记录一下操作执行之前的数据情况。比如insert的时候，记录一下这个数据的主键，然后回滚的时候根据这个主键去删除数据。MySQL把这些为了回滚记录的内容称为撤销日志（undo log）。undo log的产生，会让redo log 产生，因为undo log也要持久化的保证。</p><p>Undo Log的作用：</p><ol><li>回滚数据，只是逻辑层面来恢复数据</li><li>MVCC，用户读取一行数据的时候，如果数据被其他线程锁定了，通过读取undo log之前的行信息，来做到非锁定读取</li></ol><p>Undo Log的生命周期，假如有两个值A&#x3D;1，B&#x3D;2，修改为3，4</p><ol><li>start transaction</li><li>记录A&#x3D;1到undo log</li><li>修改数据 A&#x3D;3</li><li>记录A&#x3D;3到redo log</li><li>记录B&#x3D;2到undo log</li><li>修订B&#x3D;4</li><li>记录B&#x3D;4到redo log</li><li>把redo log刷入磁盘</li><li>commit</li></ol><p>1-8任意时刻宕机都不会影响，因为事务没提交，事务不会影响到磁盘的数据</p><p>8-9之间宕机，恢复之后可以回滚，也可继续完成事务的提交，因为redo log已经持久化了</p><p>在9之后宕机，没关系，可以根据redo log恢复数据，刷到磁盘</p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271838881.png" alt="2121" style="zoom:50%;" /><h2 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a>MVCC实现</h2><h3 id="MVCC的核心：隐藏字段-undo-log-readview"><a href="#MVCC的核心：隐藏字段-undo-log-readview" class="headerlink" title="MVCC的核心：隐藏字段 undo log readview"></a>MVCC的核心：隐藏字段 undo log readview</h3><p>两个隐藏字段 trx_id roll_pointer，undo log串成链</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271839807.png" alt="2121111"></p><p>什么是readview？就是事务A在使用MVCC的时候进行快照读的时候产生的读试图。事务启动的时候，会产生当前数据库的快照，InnoDB为每个事务构建了一个数组用来放置所有的活跃的事务ID（启动了，但没起胶）</p><h3 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h3><ol><li>读未提交的时候， 直接读取最新的数据</li><li>串行化的时候用锁来访问记录</li><li>使用可重复读和读已提交，都必须保证可以读到已经提交的事务修改的数据，核心问题是版本链中的数据哪些是对当前事务可见的</li></ol><h3 id="ReadView组成："><a href="#ReadView组成：" class="headerlink" title="ReadView组成："></a>ReadView组成：</h3><ol><li>creator_trx_id     创建这个ReadView的事务ID</li><li>trx_ids，当前活跃的事务id，是个数组</li><li>up_limit_trx_id 活跃事务最小的ID</li><li>low_limit_trx_id 系统分配给下一个事务的id</li></ol><h3 id="ReadView的规则-："><a href="#ReadView的规则-：" class="headerlink" title="ReadView的规则 ："></a>ReadView的规则 ：</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见 </p><ol><li><p>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问     它自己修改过的记录，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id     值，表明生成该版本的事务在当前     事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id     值，表明生成该版本的事     务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值在ReadView的 up_limit_id     和 low_limit_id     之间，那就需要判     断一下trx_id属性值是不是在 trx_ids 列表中。 </p></li><li><ol><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ol></li></ol><h3 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h3><ol><li>获取自己的事务ID</li><li>获取ReadView</li><li>查询得到的数据，和ReadView中的事务版本号比较</li><li>不符合ReadView规则，从undo     log链中获取数据</li><li>返回数据</li></ol><p>MVCC是通过undo log链+ReadView进行数据读取，ReadView规则帮助我们判断当前版本的数据是否可见，undo log链是保存了历史数据。</p><p>读已提交隔离级别的时候，每一次读取是重新获取一次ReadView。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271840516.png" alt="111131"></p><p>因此每次获取到的ReadView可能是不同的，那么就可能会出现不可重复读和幻读。</p><p>可重复读的时候，事务在第一次SELECT的时候生成一个ReadView，这样的话，在这个事务的生命期间，后面所有的SELECT都是用的这个ReadView。</p><h3 id="MVCC带来了什么"><a href="#MVCC带来了什么" class="headerlink" title="MVCC带来了什么"></a>MVCC带来了什么</h3><ol><li>解决了读写互斥问题，提高了并发能力</li><li>降低了死锁概率，读取不加锁，写加行锁</li><li>解决了快照读问题，查询某个时间点的数据，只能查看这个时间点之前提交的事务的数据</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;explain执行计划的几种坏情况&quot;&gt;&lt;a href=&quot;#explain执行计划的几种坏情况&quot; class=&quot;headerlink&quot; title=&quot;explain执行计划的几种坏情况&quot;&gt;&lt;/a&gt;explain执行计划的几种坏情况&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Usin</summary>
      
    
    
    
    <category term="DB" scheme="http://example.com/categories/DB/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码分析</title>
    <link href="http://example.com/2022/03/25/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/25/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-24T16:54:01.000Z</published>
    <updated>2022-03-25T09:19:08.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="容器和Bean"><a href="#容器和Bean" class="headerlink" title="容器和Bean"></a>容器和Bean</h2><h3 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h3><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BaanFacroty是什么</p><ol><li>是ApplicationContext的父接口</li><li>他才是Spring的核心容器，ApplicationContext「实现」组合了他的功能，也就是ApplicationContext组合了BeanFactory</li></ol><p>BeanFactory的功能</p><ol><li>表面上看只有一个getBean</li><li>实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能, 都由它的实现类提供</li></ol><h4 id="ApplicationContext的拓展功能"><a href="#ApplicationContext的拓展功能" class="headerlink" title="ApplicationContext的拓展功能"></a>ApplicationContext的拓展功能</h4><p>ApplicationContext是BeanFactory的实现，然后还实现了其他的几个接口，这相当于在BeanFactory的基础上拥有了其他的能力，ApplicationContext实现了这些接口之后就有了以下的能力。</p><ol><li>处理国际化资源能力</li><li>对通配符匹配资源「类路径磁盘路径等」的能力</li><li>事件发布能力</li><li>环境信息读取能力</li></ol><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203251131753.png" alt="image-20220325113157729"></p><h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><h4 id="BeanFactory实现的特点"><a href="#BeanFactory实现的特点" class="headerlink" title="BeanFactory实现的特点"></a>BeanFactory实现的特点</h4><p>DefaultListableBeanFactory，BeanFacroty的核心实现，通过Bean的描述信息BeanDefination类「class，scope，初始化，销毁」来创建Bean，管理Bean的整个生命周期。</p><p>可是对DefaultListableBeanFactory增加一些Bean工厂的后置处理器补充一下 Bean定义，针对Bean有一些Bean的后置，给Bean的生命周期个个阶段提供扩展，例如InternalAutowiredAnnotationProcessor 给Bean自动填充。</p><p>BeanFactory不会做的事情：</p><ol><li>不会主动调用 BeanFactory 后处理器</li><li>不会主动添加Bean后置处理器</li><li>不会主动解析单例 也就是不会提前创建 只有用的时候才会创建</li><li>不会解析beanFactory 还不会解析 ${} 与 #{}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// bean 的定义（class, scope, 初始化, 销毁）</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">                BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(<span class="string">&quot;singleton&quot;</span>).getBeanDefinition();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给 BeanFactory 添加一些常用的后处理器</span></span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanFactory 后处理器主要功能，补充了一些 bean 定义</span></span><br><span class="line">        beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -&gt; &#123;</span><br><span class="line">            beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bean 后处理器, 针对 bean 的生命周期的各个阶段提供扩展, 例如 @Autowired @Resource ...</span></span><br><span class="line">        beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream()</span><br><span class="line">                .sorted(beanFactory.getDependencyComparator())</span><br><span class="line">                .forEach(beanPostProcessor -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&quot;</span> + beanPostProcessor);</span><br><span class="line">            beanFactory.addBeanPostProcessor(beanPostProcessor);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beanFactory.preInstantiateSingletons(); <span class="comment">// 准备好所有单例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span></span><br><span class="line">        System.out.println(beanFactory.getBean(Bean1.class).getInter());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            学到了什么:</span></span><br><span class="line"><span class="comment">            a. beanFactory 不会做的事</span></span><br><span class="line"><span class="comment">                  bu</span></span><br><span class="line"><span class="comment">                   2. 不会主动添加 Bean 后处理器</span></span><br><span class="line"><span class="comment">                   3. 不会主动初始化单例</span></span><br><span class="line"><span class="comment">                   4. 不会解析beanFactory 还不会解析 $&#123; &#125; 与 #&#123; &#125;</span></span><br><span class="line"><span class="comment">            b. bean 后处理器会有排序的逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Common:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Autowired:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext的常见实现和特点"><a href="#ApplicationContext的常见实现和特点" class="headerlink" title="ApplicationContext的常见实现和特点"></a>ApplicationContext的常见实现和特点</h4><ol><li><p>ClassPathXmlApplicationContext基于 classpath 下 xml 格式的配置文件来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassPathXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;a02.xml&quot;</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">           System.out.println(name);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>FileSystemXmlApplicationContext 基于磁盘路径下 xml 格式的配置文件来创建 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(</span><br><span class="line">                       <span class="string">&quot;src\\main\\resources\\a02.xml&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">           System.out.println(name);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>AnnotationConfigApplicationContext 较为经典的容器, 基于 java 配置类来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>AnnotationConfigServletWebServerApplicationContext较为经典的容器, 基于 java 配置类来创建, 用于 web 环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">      <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">          System.out.println(name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>一个受 Spring 管理的 bean，生命周期主要阶段有</p><ol><li>创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象</li><li>依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系</li><li>初始化：回调各种 Aware 接口，调用对象的各种初始化方法</li><li>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）<ul><li>prototype 对象也能够销毁，不过需要容器这边主动调用</li></ul></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码分析&quot;&gt;&lt;a href=&quot;#Spring源码分析&quot; class=&quot;headerlink&quot; title=&quot;Spring源码分析&quot;&gt;&lt;/a&gt;Spring源码分析&lt;/h1&gt;&lt;h2 id=&quot;容器和Bean&quot;&gt;&lt;a href=&quot;#容器和Bean&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud OpenFeign源码分析</title>
    <link href="http://example.com/2022/03/24/SpringCloud-OpenFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/24/SpringCloud-OpenFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-24T03:56:36.000Z</published>
    <updated>2022-03-24T16:46:14.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud-OpenFeign源码分析"><a href="#SpringCloud-OpenFeign源码分析" class="headerlink" title="SpringCloud OpenFeign源码分析"></a>SpringCloud OpenFeign源码分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="OpenFeign简介"><a href="#OpenFeign简介" class="headerlink" title="OpenFeign简介"></a>OpenFeign简介</h3><h4 id="官网说明"><a href="#官网说明" class="headerlink" title="官网说明"></a>官网说明</h4><p>Declarative REST Client: Feign creates a dynamic implementation of an interface decorated with JAX-RS or Spring MVC annotations</p><p>声明式 REST 客户端：Feign 通过 JAX-RS 或 Spring MVC 注解装饰的方式，生成接口的动态实现</p><h4 id="综合说明"><a href="#综合说明" class="headerlink" title="综合说明"></a>综合说明</h4><p>官网这段话什么意思？OpenFeign可以将提供者的Restful服务伪装成为接口进行消费，消费者只需要使用 feign接口+注解即可调用提供者的服务，无需RestTemplate。</p><p>注意： OpenFeign只和消费者有关，和提供者没有任何关系。</p><h4 id="Ribbon和OpenFeign"><a href="#Ribbon和OpenFeign" class="headerlink" title="Ribbon和OpenFeign"></a>Ribbon和OpenFeign</h4><p>OpenFeign默认集成了Ribbon作为负载均衡组件，OpenFeign是工作在客户端的使用，在发起RPC使用的就是Ribbon的负载均衡功能。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="重要注解解析"><a href="#重要注解解析" class="headerlink" title="重要注解解析"></a>重要注解解析</h3><h4 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h4><p>在SpringBoot中存在大量的@EnableXxx这种注解。它们的作用是，开启某项功能。其实它们本质上是为了导入某个类来完成某项功能。所以这个注解一般会组合一个@Import注解用于导入类。导入的类一般有三种：</p><ol><li>配置类：一般以Configuration结尾，完成自动配置</li><li>选择器：一般以Selector结尾，完成自动选择</li><li>注册器：一般以Registrar结尾，完成自动注册</li></ol><p>这里的@EnableFeignClients就是扫描那些申明为@FeignClient的接口，然后import一个自动注册Bean，把@FeignClient的类注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans for interfaces that declare they are feign clients (via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.cloud.openfeign.FeignClient&#125; &lt;code&gt;<span class="doctag">@FeignClient</span>&lt;/code&gt;).</span></span><br><span class="line"><span class="comment"> * Configures component scanning directives for use with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.annotation.Configuration&#125;</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;<span class="doctag">@Configuration</span>&lt;/code&gt; classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 导入一个类</span></span><br><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment"> * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(&quot;org.my.pkg&quot;)&#125; instead of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages=&quot;org.my.pkg&quot;)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array of &#x27;basePackages&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages to scan for annotated components.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #value()&#125; is an alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment"> * package names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array of &#x27;basePackages&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 扫描的基本包</span></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment"> * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment"> * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array of &#x27;basePackageClasses&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 扫描某个Bean所在包下所有的FeignClients</span></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A custom &lt;code&gt;<span class="doctag">@Configuration</span>&lt;/code&gt; for all feign clients. Can contain override</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;<span class="doctag">@Bean</span>&lt;/code&gt; definition for the pieces that make up the client, for instance</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> feign.codec.Decoder&#125;, &#123;<span class="doctag">@link</span> feign.codec.Encoder&#125;, &#123;<span class="doctag">@link</span> feign.Contract&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FeignClientsConfiguration for the defaults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list of default configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 导入一些自定义的 Feign需要的配置类</span></span><br><span class="line">Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List of classes annotated with <span class="doctag">@FeignClient</span>. If not empty, disables classpath</span></span><br><span class="line"><span class="comment"> * scanning.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list of FeignClient classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 指定有@FeignClient注解的接口，可以是多个，启用后不再包扫描</span></span><br><span class="line">Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h4><p>详细见注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FeignClient &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of the service with optional protocol prefix. Synonym for &#123;<span class="doctag">@link</span> #name()</span></span><br><span class="line"><span class="comment"> * name&#125;. A name must be specified for all clients, whether or not a url is provided.</span></span><br><span class="line"><span class="comment"> * Can be specified as property key, eg: $&#123;propertyKey&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the name of the service with optional protocol prefix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// value 就是要消费的微服务提供者的名称 默认是HTTP 必须指定</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The service id with optional protocol prefix. Synonym for &#123;<span class="doctag">@link</span> #value() value&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> use &#123;<span class="doctag">@link</span> #name() name&#125; instead</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the service id with optional protocol prefix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">String <span class="title function_">serviceId</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This will be used as the bean name instead of name if present, but will not be used</span></span><br><span class="line"><span class="comment"> * as a service id.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bean name instead of name if present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">//  优先级高于 name value serviceId 其实也是指定服务名称</span></span><br><span class="line">String <span class="title function_">contextId</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The service id with optional protocol prefix. Synonym for &#123;<span class="doctag">@link</span> #value()</span></span><br><span class="line"><span class="comment"> * value&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the &lt;code&gt;<span class="doctag">@Qualifier</span>&lt;/code&gt; value for the feign client.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 给FeignClient指定一个名字 避免多个FeignClient存在的时候因为同名 注入失败</span></span><br><span class="line">String <span class="title function_">qualifier</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an absolute URL or resolvable hostname (the protocol is optional).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 要访问的服务的Host，这里就是直连而不是负载均衡了</span></span><br><span class="line">String <span class="title function_">url</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether 404s should be decoded instead of throwing FeignExceptions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">decode404</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A custom configuration class for the feign client. Can contain override</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;<span class="doctag">@Bean</span>&lt;/code&gt; definition for the pieces that make up the client, for instance</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> feign.codec.Decoder&#125;, &#123;<span class="doctag">@link</span> feign.codec.Encoder&#125;, &#123;<span class="doctag">@link</span> feign.Contract&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FeignClientsConfiguration for the defaults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list of configurations for feign client</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] configuration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fallback class for the specified Feign client interface. The fallback class must</span></span><br><span class="line"><span class="comment"> * implement the interface annotated by this annotation and be a valid spring bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> fallback class for the specified Feign client interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// fallback类</span></span><br><span class="line">Class&lt;?&gt; fallback() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a fallback factory for the specified Feign client interface. The fallback</span></span><br><span class="line"><span class="comment"> * factory must produce instances of fallback classes that implement the interface</span></span><br><span class="line"><span class="comment"> * annotated by &#123;<span class="doctag">@link</span> FeignClient&#125;. The fallback factory must be a valid spring bean.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> feign.hystrix.FallbackFactory for details.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> fallback factory for the specified Feign client interface</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">Class&lt;?&gt; fallbackFactory() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> path prefix to be used by all method-level mappings. Can be used with or</span></span><br><span class="line"><span class="comment"> * without &lt;code&gt;<span class="doctag">@RibbonClient</span>&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 用path就不用@RequestMapping 方法级别的mapping</span></span><br><span class="line">String <span class="title function_">path</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether to mark the feign proxy as a primary bean. Defaults to true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 如果一个FeignClient有多个实现类，用这个来标记就会优先注入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">primary</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要API解析"><a href="#重要API解析" class="headerlink" title="重要API解析"></a>重要API解析</h3><h4 id="FeignClientSpecification类"><a href="#FeignClientSpecification类" class="headerlink" title="FeignClientSpecification类"></a>FeignClientSpecification类</h4><p>FeignClientSpecification是一个FeignClient生成规范，他是NamedContextFactory.Specification的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specification with name and configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// SpringCloud的规范</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span> &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] getConfiguration();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BeanDefination接口"><a href="#BeanDefination接口" class="headerlink" title="BeanDefination接口"></a>BeanDefination接口</h4><p>是一个Bean定义器，是一个Bean的定义，描述了一个Bean的各种属性，可以根据它生成一个Bean。</p><h4 id="BeanDefinationRegistry接口"><a href="#BeanDefinationRegistry接口" class="headerlink" title="BeanDefinationRegistry接口"></a>BeanDefinationRegistry接口</h4><p>BeanDefinationRegistry是BeanDefination的注册器，把BeanDefination注册到map，通过名称获取BeanDefination。</p><h4 id="FeignContext"><a href="#FeignContext" class="headerlink" title="FeignContext"></a>FeignContext</h4><p>一个典型的上下文，是一个子容器，每个FeignClient有一个子容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignContext</span> <span class="keyword">extends</span> <span class="title class_">NamedContextFactory</span>&lt;FeignClientSpecification&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FeignContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(FeignClientsConfiguration.class, <span class="string">&quot;feign&quot;</span>, <span class="string">&quot;feign.client.name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstanceWithoutAncestors</span><span class="params">(String name, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BeanFactoryUtils.beanOfType(getContext(name), type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Map&lt;String, T&gt; <span class="title function_">getInstancesWithoutAncestors</span><span class="params">(String name, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getContext(name).getBeansOfType(type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add javadoc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">NamedContextFactory</span>&lt;C <span class="keyword">extends</span> <span class="title class_">NamedContextFactory</span>.Specification&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">DisposableBean</span>, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertyName;</span><br><span class="line"><span class="comment">// 该map的key我FeignClient名称 其所要调用的微服务名</span></span><br><span class="line">    <span class="comment">// value为组装这个FeignClient所必须的组件所在的Spring子容器</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 这个map是存放@EnableFeignClients和@FeignClient两个注解中的Configuration属性值</span></span><br><span class="line">    <span class="comment">// 这个属性值只有两类 第一类只有一个其key为字符串 default+当前启动类全限定类名</span></span><br><span class="line">    <span class="comment">// 例如default.com.abc.Comsumer8080 value为@EnableFeignClients的default Configuration属性值</span></span><br><span class="line">    <span class="comment">// 第二类有多个key = 当前@FeignClient名称，value为这个client的注解的configuration属性值</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FeignClient创建"><a href="#FeignClient创建" class="headerlink" title="FeignClient创建"></a>FeignClient创建</h3><h4 id="FeignClient自动注册"><a href="#FeignClient自动注册" class="headerlink" title="FeignClient自动注册"></a>FeignClient自动注册</h4><p>在@EnableFeignClients里面有一个@Import(FeignClientsRegistrar.class)，导入了这个注册类，他是ImportBeanDefinitionRegistrar接口实现类，里面有一个registerBeanDefinations方法，也就是把FeignClient注册到Spring的map中，交给容器来管理。我们看一下怎么做的</p><ol><li>将@EnableFeignClients直接中的defaultConfiguration注册到一个缓存map</li><li>完成了3项工作<ol><li>扫描所有的带了@FeignClient的接口</li><li>将每个@FeignClient注解的defaultConfiguration注册到一个map</li><li>根据@FeignClient注解元数据生成一个FeignClientFactoryBean的BeanDefination 并将这个BeanDefination放入一个map</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">       </span><br><span class="line">registerDefaultConfiguration(metadata, registry);</span><br><span class="line">registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RegisterDefaultConfiguration方法分析"><a href="#RegisterDefaultConfiguration方法分析" class="headerlink" title="RegisterDefaultConfiguration方法分析"></a>RegisterDefaultConfiguration方法分析</h5><p> 进入这个方法内部先分析参数metadata和registry</p><ul><li>metadata 包含了@EnableFeignClients和@SpringBootApplication两个注解的元数据</li><li>registry  BeanDefination注册器</li></ul><p>经过registerDefaultConfiguration方法，FeignClientSpecification的BeanDefination就被注册到了map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取到EnableFeignClients注解的属性值 </span></span><br><span class="line">Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">           <span class="comment">// 第二个属性把class类变为了string属性</span></span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defaultAttrs != <span class="literal">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line">           <span class="comment">// 如果当前注解所标注的类为闭合类</span></span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 注册这个defaultConfiguration的属性</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体如何注册</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span><br><span class="line"><span class="params">Object configuration)</span> &#123;</span><br><span class="line">       <span class="comment">// 先生成一个Builder 然后利用这个Builder生成一个FeignClientSpecification 的BeanDefination</span></span><br><span class="line">       <span class="comment">// 也就是一个FeignClient的生成规范 为将来的FeignClient生成提供规范</span></span><br><span class="line"><span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">builder.addConstructorArgValue(name);</span><br><span class="line">builder.addConstructorArgValue(configuration);</span><br><span class="line">       <span class="comment">// 把这个BeanDefination注册到Map中去 </span></span><br><span class="line">registry.registerBeanDefinition(</span><br><span class="line">name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RegisterFeignClients方法分析"><a href="#RegisterFeignClients方法分析" class="headerlink" title="RegisterFeignClients方法分析"></a>RegisterFeignClients方法分析</h5><p>第一步注册了FeignClient的定义信息，接下来就开始分析注册FeignClient。 就是扫描标记了@FeignClient的接口放入候选组件集合中，如果@EnableFeignClients注解里面有clients属性，就把这些接口添加进去，不进行包扫描了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个扫描器</span></span><br><span class="line"><span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">scanner</span> <span class="operator">=</span> getScanner();</span><br><span class="line">scanner.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; basePackages;</span><br><span class="line"><span class="comment">// 获取到@EnableFeignClient的属性</span></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">    <span class="comment">// 为扫描器添加一个扫描@FeignClient的过滤器</span></span><br><span class="line"><span class="type">AnnotationTypeFilter</span> <span class="variable">annotationTypeFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">FeignClient.class);</span><br><span class="line">   <span class="comment">// 获取里面的clients属性 如果不为空就禁用类路径扫描</span></span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="literal">null</span> ? <span class="literal">null</span></span><br><span class="line">: (Class&lt;?&gt;[]) attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (clients == <span class="literal">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">            <span class="comment">// 获取@EnableFeignClients直接指定的基本包 就是那几个指定FeignClient所在包的属性 （value basePackages）</span></span><br><span class="line">            <span class="comment">// 获取的结果就是注解中指定的FeignClient所在包的path，并用Set装起来</span></span><br><span class="line">            <span class="comment">// 如果都没有的话 则添加当前注解标注的类所在的包添加进去</span></span><br><span class="line">basePackages = getBasePackages(metadata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 指定了clients属性 不进行包扫描 直接放入</span></span><br><span class="line"><span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">basePackages = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">AbstractClassTestingTypeFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractClassTestingTypeFilter</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(ClassMetadata metadata)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">cleaned</span> <span class="operator">=</span> metadata.getClassName().replaceAll(<span class="string">&quot;\\$&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">scanner.addIncludeFilter(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AllTypeFilter</span>(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历这些基本包 将其中的@FeignClient标记的接口找到 放入候选组件里面</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">.findCandidateComponents(basePackage);</span><br><span class="line">            <span class="comment">// 遍历这些候选组件 放入map中</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="comment">// 只处理由@FeignClient标注的</span></span><br><span class="line"><span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// verify annotated class is an interface</span></span><br><span class="line"><span class="type">AnnotatedBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    <span class="comment">// 获取注解元数据</span></span><br><span class="line"><span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">                    <span class="comment">// 断言是一个接口 </span></span><br><span class="line">Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line"><span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line"><span class="comment">// 获取注解属性</span></span><br><span class="line">Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">.getAnnotationAttributes(</span><br><span class="line">FeignClient.class.getCanonicalName());</span><br><span class="line"><span class="comment">// 获取client name 比如微服务名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getClientName(attributes);</span><br><span class="line">                    <span class="comment">//  注册接口的configuration属性对应的配置类到map</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line"><span class="comment">// 将FeignClientFactoryBean的BeanDefination注册到map</span></span><br><span class="line">registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FeignClient自动配置"><a href="#FeignClient自动配置" class="headerlink" title="FeignClient自动配置"></a>FeignClient自动配置</h4><p>前面自动注册的代码我们是从注解下手，接下来我们要从spring.factories下手，因为OpenFeign作为一个SpringBoot程序，一定是有自动配置类的，我们通过这个自动配置类就可以研究出来OpenFeign是怎么完成自动配置的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241951955.png" alt="image-20220324195148905"></p><p>我们先看FeignAutoConfiguration自动配置类，首先是创建Feign的上下文， 里面有一个容器，容器里面是两个Map，第一个是存放Feign需要的组件，用的是子容器，另一个是放配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是创建Feign的上下文</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FeignContext <span class="title function_">feignContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">FeignContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FeignContext</span>();</span><br><span class="line">context.setConfigurations(<span class="built_in">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这两个就是要用的的容器</span></span><br><span class="line"><span class="comment">// key -&gt; FeignClient名字 value -&gt; 子容器</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">// 这个map是存放@EnableFeignClients和@FeignClient两个注解中的Configuration属性值</span></span><br><span class="line">   <span class="comment">// 这个属性值只有两类 第一类只有一个其key为字符串 default+当前启动类全限定类名</span></span><br><span class="line">   <span class="comment">// 例如default.com.abc.Comsumer8080 value为@EnableFeignClients的default Configuration属性值</span></span><br><span class="line">   <span class="comment">// 第二类有多个key = 当前@FeignClient名称，value为这个client的注解的configuration属性值</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>我们启动之后，创建好context之后，configurations就会有两个配置。name为default+启动类的全限定类名和name为微服务名称的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203242022931.png" alt="image-20220324202236900"></p><h4 id="FeignClient创建-1"><a href="#FeignClient创建-1" class="headerlink" title="FeignClient创建"></a>FeignClient创建</h4><p>我们之前把FeignClientFactoryBean的DefinationBean注册到了map中，所以这个工厂Bean就可以为我们生产FeignClient了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context</span></span><br><span class="line"><span class="comment"> * information</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">// org.springframework.cloud.openfeign.FeignClientFactoryBean#getTarget</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 启动的时候已经有FeignContext了</span></span><br><span class="line"><span class="type">FeignContext</span> <span class="variable">context</span> <span class="operator">=</span> applicationContext.getBean(FeignContext.class);</span><br><span class="line">       <span class="comment">// 从子容器中获取一个Builder</span></span><br><span class="line">Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> feign(context);</span><br><span class="line"><span class="comment">// 如果URL属性为空说明要采用负载均衡方式调用</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(url)) &#123;</span><br><span class="line">           <span class="comment">// 不是以http开头的加上http</span></span><br><span class="line"><span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">url = <span class="string">&quot;http://&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">url = name;</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 获得一个规范的url</span></span><br><span class="line">           <span class="comment">// 不是以/开头的path加上/ 以/结尾的path删除末尾的/</span></span><br><span class="line">url += cleanPath();</span><br><span class="line">           <span class="comment">// 返回一个负载均衡调用</span></span><br><span class="line"><span class="keyword">return</span> (T) loadBalance(builder, context,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(type, name, url));</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">// 不为空采用直连方式 直接调用提供者</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(url) &amp;&amp; !url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">url = <span class="string">&quot;http://&quot;</span> + url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="built_in">this</span>.url + cleanPath();</span><br><span class="line">       <span class="comment">// 从子容器中获取Client</span></span><br><span class="line"><span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> getOptional(context, Client.class);</span><br><span class="line"><span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line"><span class="comment">// not load balancing because we have a url,</span></span><br><span class="line"><span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">client = ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> FeignBlockingLoadBalancerClient) &#123;</span><br><span class="line"><span class="comment">// not load balancing because we have a url,</span></span><br><span class="line"><span class="comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span></span><br><span class="line">client = ((FeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line">&#125;</span><br><span class="line">builder.client(client);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Targeter</span> <span class="variable">targeter</span> <span class="operator">=</span> get(context, Targeter.class);</span><br><span class="line"><span class="keyword">return</span> (T) targeter.target(<span class="built_in">this</span>, builder, context,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(type, name, url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从子容器中获取组件</span></span><br><span class="line"><span class="keyword">protected</span> Feign.Builder <span class="title function_">feign</span><span class="params">(FeignContext context)</span> &#123;</span><br><span class="line"><span class="type">FeignLoggerFactory</span> <span class="variable">loggerFactory</span> <span class="operator">=</span> get(context, FeignLoggerFactory.class);</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> loggerFactory.create(type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @formatter:off</span></span><br><span class="line">Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> get(context, Feign.Builder.class)</span><br><span class="line"><span class="comment">// required values</span></span><br><span class="line">.logger(logger)</span><br><span class="line">.encoder(get(context, Encoder.class))</span><br><span class="line">.decoder(get(context, Decoder.class))</span><br><span class="line">.contract(get(context, Contract.class));</span><br><span class="line"><span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从当前FeignClient的子容器中获取指定类型的实例</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(FeignContext context, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">       <span class="comment">// 从FeignClient的上下文中的context中的contexts中指定feign名称contextId的子容器中获取指定type实例</span></span><br><span class="line"><span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> context.getInstance(contextId, type);</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;No bean found of type &quot;</span> + type + <span class="string">&quot; for &quot;</span> + contextId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们分析FeignClient是怎么被创建出来的，也就是上面代码段的第25行，我们接着进入内部方法可以找到feign.Feign.Builder#target(feign.Target<T>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">target</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">    <span class="comment">// key 方法名 value 方法处理器 有几个方法就有几个处理器</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">    <span class="comment">// key 方法 value方法处理器 </span></span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Method, MethodHandler&gt;();</span><br><span class="line">    <span class="comment">// 默认的方法处理器 </span></span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123; <span class="comment">// 如果是默认方法 就放入这个集合</span></span><br><span class="line">      <span class="type">DefaultMethodHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodHandler</span>(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 网络请求就是这里发出</span></span><br><span class="line">  <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> factory.create(target, methodToHandler);</span><br><span class="line">    <span class="comment">// 反射机制创建的Feign JDK动态代理</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">proxy</span> <span class="operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FeignClient发送请求"><a href="#FeignClient发送请求" class="headerlink" title="FeignClient发送请求"></a>FeignClient发送请求</h3><p>上面有个关键信息，FeignClient是通过JDK动态代理创建出来的，然后看到这个InvocationHandler，我们这里肯定是创建了一个和Feign有关的InvocationHandler，所以我们要清楚这个factory.create(target, methodToHandler)到底是创建的什么。</p><p>这里是FeignInvocationHandler的创建方法，dispatch就是上面的methodToHandler，就是一个map key&#x3D;method value&#x3D;方法处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Default</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandlerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> InvocationHandler <span class="title function_">create</span><span class="params">(Target target, Map&lt;Method, MethodHandler&gt; dispatch)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectiveFeign</span>.FeignInvocationHandler(target, dispatch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是FeignInvocationHandler他是InvocationHandler接口的实现类，必然有一个invoke方法来真正调用我们的业务逻辑。这里做的事情就是过滤一些没有必要代理的方法之后，用那个方法处理器map根据具体method选出来的方法处理器来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Target target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map &lt; Method,</span><br><span class="line">    MethodHandler &gt; dispatch;</span><br><span class="line">    FeignInvocationHandler(Target target, Map &lt; Method, MethodHandler &gt; dispatch) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = checkNotNull(target, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.dispatch = checkNotNull(dispatch, <span class="string">&quot;dispatch for %s&quot;</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">otherHandler</span> <span class="operator">=</span> args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="literal">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排除一些基本方法，然后从dispatch发出请求</span></span><br><span class="line">        <span class="comment">// dispatch就是方法处理器map，根据这个method选出一个方法处理器执行就好了</span></span><br><span class="line">        <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入invoke方法，因为是OpenFeign实现的方法所以我们应该找到feign.SynchronousMethodHandler#invoke，这里首先是通过参数构建出一个请求模版，里面的参数是请求方式，URL之类的调用executeAndDecode方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123; </span><br><span class="line">    <span class="comment">// 通过参数构建一个请求模版 </span></span><br><span class="line">    <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br><span class="line">    <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> findOptions(argv);</span><br><span class="line">    <span class="type">Retryer</span> <span class="variable">retryer</span> <span class="operator">=</span> <span class="built_in">this</span>.retryer.clone();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发起调用</span></span><br><span class="line">            <span class="keyword">return</span> executeAndDecode(template, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RetryableException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                retryer.continueOrPropagate(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(RetryableException th) &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> th.getCause();</span><br><span class="line">                <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> th;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">                logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入executeAndDecode内部，找到关键一行代码 response &#x3D; client.execute(request, options)，这里的Client就是我们要要使用的负载均衡器，如果@FeignClient声明的时候指定了URL，那就是直连方法请求，我们默认是使用的Ribbon的C负载均衡。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203250029330.png" alt="image-20220325002936288"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">executeAndDecode</span><span class="params">(RequestTemplate template, Options options)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> targetRequest(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.execute(request, options);</span><br><span class="line">        <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 12</span></span><br><span class="line">        response = response.toBuilder().request(request).requestTemplate(template).build();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">            logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decoder != <span class="literal">null</span>) <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line"></span><br><span class="line">    CompletableFuture &lt; Object &gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span> &lt; &gt;();</span><br><span class="line">    asyncResponseHandler.handleResponse(resultFuture, metadata.configKey(), response, metadata.returnType(), elapsedTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resultFuture.isDone()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Response handling not done&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultFuture.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CompletionException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="literal">null</span>) <span class="keyword">throw</span> cause;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入response &#x3D; client.execute(request, options)内部，feign.Client.Default#execute方法，因为指定了URL那么就不使用负载均行，而是起一个HTTP连接然后发送请求，获取应答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> convertAndSend(request, options);</span><br><span class="line">    <span class="keyword">return</span> convertResponse(connection, request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h3><p>上面发起请求是直连的情况下，如果要用到Ribbon那么在 response &#x3D; client.execute(request, options)这里使用的Client就不再是默认的Client了，而是 org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient#execute。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URI</span> <span class="variable">asUri</span> <span class="operator">=</span> URI.create(request.url());</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientName</span> <span class="operator">=</span> asUri.getHost();</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uriWithoutHost</span> <span class="operator">=</span> cleanUrl(request.url(), clientName);</span><br><span class="line">        FeignLoadBalancer.<span class="type">RibbonRequest</span> <span class="variable">ribbonRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FeignLoadBalancer</span>.RibbonRequest(<span class="built_in">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line"></span><br><span class="line">        <span class="type">IClientConfig</span> <span class="variable">requestConfig</span> <span class="operator">=</span> getClientConfig(options, clientName);</span><br><span class="line">        <span class="comment">// 发起负载均行模式请求</span></span><br><span class="line">        <span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClientException e) &#123;</span><br><span class="line">        <span class="type">IOException</span> <span class="variable">io</span> <span class="operator">=</span> findIOException(e);</span><br><span class="line">        <span class="keyword">if</span> (io != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> io;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException &#123;</span><br><span class="line">    LoadBalancerCommand &lt; T &gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 选择一个主机发起请求</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(<span class="keyword">new</span> <span class="title class_">ServerOperation</span> &lt; T &gt; () &#123;<span class="meta">@Override</span> <span class="keyword">public</span> Observable &lt; T &gt; call(Server server) &#123;</span><br><span class="line">                <span class="type">URI</span> <span class="variable">finalUri</span> <span class="operator">=</span> reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                <span class="type">S</span> <span class="variable">requestForServer</span> <span class="operator">=</span> (S) request.replaceUri(finalUri);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="built_in">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).toBlocking().single();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ClientException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (ClientException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud-OpenFeign源码分析&quot;&gt;&lt;a href=&quot;#SpringCloud-OpenFeign源码分析&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud OpenFeign源码分析&quot;&gt;&lt;/a&gt;SpringCloud</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="RPC" scheme="http://example.com/tags/RPC/"/>
    
    <category term="SpringCloud" scheme="http://example.com/tags/SpringCloud/"/>
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud GateWay源码分析</title>
    <link href="http://example.com/2022/03/23/SpringCloud-GateWay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/23/SpringCloud-GateWay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-23T08:03:20.000Z</published>
    <updated>2022-03-24T03:34:43.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GateWay工作原理"><a href="#GateWay工作原理" class="headerlink" title="GateWay工作原理"></a>GateWay工作原理</h1><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="Route-路由"><a href="#Route-路由" class="headerlink" title="Route 路由"></a>Route 路由</h3><p>一个请求路径经过网关的一系列的转换得到真正的请求路径，由后面的Predicate和Filter组成。</p><h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p>类似Java8的断言函数，一个请求路径经过一个断言函数，判断出来它是否匹配我们设定好的predicate条件，返回一个Bool。</p><h3 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h3><p>通过断言之后，有一系列的Filter构建成一个Filter Chain进行后置的处理。</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>请求发到网关，先通过处理器映射器找到对应的处理器，然后处理器组装后面一系列的过滤器，然后经过处理器链执行。</p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203232104728.png" alt="image-20220323210445662" style="zoom: 50%;" /><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="配置类解析"><a href="#配置类解析" class="headerlink" title="配置类解析"></a>配置类解析</h3><p>GateWay作为一个SpringBoot程序直接供我们使用，肯定是有一个自动配置类的，我们直接找到GateWay的自动配置类。按照SpringBoot的规定，直接看spring.factories里面的自动配置类。下图标红的第一个是一些警告信息，第二个就是真正的自动配置了，先来观察第一个配置类。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203232213138.png" alt="image-20220323221303108"></p><p>GateWay是基于WebFlux的，如果我们引入的Spring MVC的依赖是会报错的，下面的代码就是原因。我们可以看到第一个方法有一个@ConditionalOnClass(name &#x3D; “org.springframework.web.servlet.DispatcherServlet”)，这个条件注解说明了，如果有DispatcherServlet这个类，就会发出警告信息 和Gateway不兼容，然后看第二个方法@ConditionalOnMissingClass(“org.springframework.web.reactive.DispatcherHandler”)，他的意思就是如果缺少了这个类，那么也会发出警告 这个组件是必须的。其实这个类就是GateWay的一个关键组件，处理器映射器！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(GatewayAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayClassPathWarningAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory</span><br><span class="line">.getLog(GatewayClassPathWarningAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BORDER</span> <span class="operator">=</span> <span class="string">&quot;\n\n**********************************************************\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.springframework.web.servlet.DispatcherServlet&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SpringMvcFoundOnClasspathConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringMvcFoundOnClasspathConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">log.warn(BORDER</span><br><span class="line">+ <span class="string">&quot;Spring MVC found on classpath, which is incompatible with Spring Cloud Gateway at this time. &quot;</span></span><br><span class="line">+ <span class="string">&quot;Please remove spring-boot-starter-web dependency.&quot;</span> + BORDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;org.springframework.web.reactive.DispatcherHandler&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebfluxMissingFromClasspathConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WebfluxMissingFromClasspathConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">log.warn(BORDER + <span class="string">&quot;Spring Webflux is missing from the classpath, &quot;</span></span><br><span class="line">+ <span class="string">&quot;which is required for Spring Cloud Gateway at this time. &quot;</span></span><br><span class="line">+ <span class="string">&quot;Please add spring-boot-starter-webflux dependency.&quot;</span> + BORDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再看GatewayDiscoveryClientAutoConfiguration这个配置类，做的事情就是从配置文件中初始化Predicate，Filter，初始化定位器等等。在启动的时候就吧配置文件里面的东西读取过来注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(GatewayAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(CompositeDiscoveryClientAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DispatcherHandler.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayDiscoveryClientAutoConfiguration</span> &#123;</span><br><span class="line"><span class="comment">// 获取断言</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;PredicateDefinition&gt; <span class="title function_">initPredicates</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;PredicateDefinition&gt; definitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add a predicate that matches the url at /serviceId?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add a predicate that matches the url at /serviceId/**</span></span><br><span class="line">        <span class="comment">// 断言是放在PredicateDefinition里面的</span></span><br><span class="line"><span class="type">PredicateDefinition</span> <span class="variable">predicate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PredicateDefinition</span>();</span><br><span class="line">predicate.setName(normalizeRoutePredicateName(PathRoutePredicateFactory.class));</span><br><span class="line">predicate.addArg(PATTERN_KEY, <span class="string">&quot;&#x27;/&#x27;+serviceId+&#x27;/**&#x27;&quot;</span>);</span><br><span class="line">definitions.add(predicate);</span><br><span class="line"><span class="keyword">return</span> definitions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;FilterDefinition&gt; <span class="title function_">initFilters</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;FilterDefinition&gt; definitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a filter that removes /serviceId by default</span></span><br><span class="line"><span class="type">FilterDefinition</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDefinition</span>();</span><br><span class="line">filter.setName(normalizeFilterFactoryName(RewritePathGatewayFilterFactory.class));</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;&#x27;/&#x27; + serviceId + &#x27;/(?&lt;remaining&gt;.*)&#x27;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replacement</span> <span class="operator">=</span> <span class="string">&quot;&#x27;/$&#123;remaining&#125;&#x27;&quot;</span>;</span><br><span class="line">filter.addArg(REGEXP_KEY, regex);</span><br><span class="line">filter.addArg(REPLACEMENT_KEY, replacement);</span><br><span class="line">definitions.add(filter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> definitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DiscoveryLocatorProperties <span class="title function_">discoveryLocatorProperties</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">DiscoveryLocatorProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscoveryLocatorProperties</span>();</span><br><span class="line">properties.setPredicates(initPredicates());</span><br><span class="line">properties.setFilters(initFilters());</span><br><span class="line"><span class="keyword">return</span> properties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.cloud.discovery.reactive.enabled&quot;,</span></span><br><span class="line"><span class="meta">matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReactiveDiscoveryClientRouteDefinitionLocatorConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.discovery.locator.enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DiscoveryClientRouteDefinitionLocator <span class="title function_">discoveryClientRouteDefinitionLocator</span><span class="params">(</span></span><br><span class="line"><span class="params">ReactiveDiscoveryClient discoveryClient,</span></span><br><span class="line"><span class="params">DiscoveryLocatorProperties properties)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiscoveryClientRouteDefinitionLocator</span>(discoveryClient, properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> In favor of the native reactive service discovery capability.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.cloud.discovery.reactive.enabled&quot;,</span></span><br><span class="line"><span class="meta">havingValue = &quot;false&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BlockingDiscoveryClientRouteDefinitionLocatorConfiguration</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化资源定位器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.discovery.locator.enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DiscoveryClientRouteDefinitionLocator <span class="title function_">discoveryClientRouteDefinitionLocator</span><span class="params">(</span></span><br><span class="line"><span class="params">DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiscoveryClientRouteDefinitionLocator</span>(discoveryClient, properties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于Gateway真正的配置类其实就是一些组件的注入而已。</p><h3 id="DispatcherHandler分析"><a href="#DispatcherHandler分析" class="headerlink" title="DispatcherHandler分析"></a>DispatcherHandler分析</h3><p>一个请求发送到Gateway的时候，先触发NioEventLoop#processSelectKey()，这是一个读取请求，所以Key是READ，请求调度器负责请求分发，将请求参数封装成为<code>ServerWebExchange</code> 它的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServerWebExchange</span> <span class="keyword">implements</span> <span class="title class_">ServerWebExchange</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;HttpMethod&gt; SAFE_METHODS = Arrays.asList(HttpMethod.GET, HttpMethod.HEAD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ResolvableType</span> <span class="variable">FORM_DATA_TYPE</span> <span class="operator">=</span></span><br><span class="line">ResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ResolvableType</span> <span class="variable">MULTIPART_DATA_TYPE</span> <span class="operator">=</span> ResolvableType.forClassWithGenerics(</span><br><span class="line">MultiValueMap.class, String.class, Part.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, String&gt;&gt; EMPTY_FORM_DATA =</span><br><span class="line">Mono.just(CollectionUtils.unmodifiableMultiValueMap(<span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String, String&gt;(<span class="number">0</span>)))</span><br><span class="line">.cache();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; EMPTY_MULTIPART_DATA =</span><br><span class="line">Mono.just(CollectionUtils.unmodifiableMultiValueMap(<span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String, Part&gt;(<span class="number">0</span>)))</span><br><span class="line">.cache();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerHttpRequest request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerHttpResponse response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Mono&lt;WebSession&gt; sessionMono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LocaleContextResolver localeContextResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, String&gt;&gt; formDataMono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; multipartDataMono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> notModified;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Function&lt;String, String&gt; urlTransformer = url -&gt; url;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Object logId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">logPrefix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装好了参数之后，请求交给了<code>org.springframework.web.reactive.DispatcherHandler#handle</code> 方法来处理，从这里就开始对应上面的图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> createNotFoundError();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 1.遍历所有的 handlerMapping</span></span><br><span class="line"><span class="keyword">return</span> Flux.fromIterable(<span class="built_in">this</span>.handlerMappings)</span><br><span class="line">  <span class="comment">// 2.获取对应的handlerMapping ，比如常用的 RequestMappingHandlerMapping、RoutePredicateHandlerMapping</span></span><br><span class="line">.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">.next()</span><br><span class="line">.switchIfEmpty(createNotFoundError())</span><br><span class="line"><span class="comment">// 3.获取对应的适配器，调用对应的处理器</span></span><br><span class="line">.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line"><span class="comment">// 4.返回处理结果</span></span><br><span class="line">.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，可以带入SpringMVC的DispatcherServlet#doDispatch来了解。类似MVC，我们在这里会依次调用HandlerMapping，HandlerAdapter，HandlerResultHandler。</p><table><thead><tr><th>框架</th><th>SpringCloud Gateway</th><th>SpringMVC</th></tr></thead><tbody><tr><td>请求分发</td><td>DispatcherHandler</td><td>DispatcherServlet</td></tr><tr><td>请求映射</td><td>HandlerMapping</td><td>HandlerMapping</td></tr><tr><td>请求适配</td><td>HanderAdapter</td><td>HanderAdapter</td></tr><tr><td>请求处理</td><td>WebHandler</td><td>Handler</td></tr></tbody></table><p>HandlerMapping是处理路径到handler的映射，我们点到mapping.getHandler(exchange)内部看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Object&gt; <span class="title function_">getHandler</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getHandlerInternal(exchange).map(handler -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(exchange.getLogPrefix() + <span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"><span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line"><span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (<span class="built_in">this</span>.corsConfigurationSource != <span class="literal">null</span> ? <span class="built_in">this</span>.corsConfigurationSource.getCorsConfiguration(exchange) : <span class="literal">null</span>);</span><br><span class="line"><span class="type">CorsConfiguration</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> getCorsConfiguration(handler, exchange);</span><br><span class="line">config = (config != <span class="literal">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.corsProcessor.process(config, exchange) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line"><span class="keyword">return</span> REQUEST_HANDLED_HANDLER;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class="line"><span class="comment">// don&#x27;t handle requests on management port if set and different than server port</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.managementPortType == DIFFERENT &amp;&amp; <span class="built_in">this</span>.managementPort != <span class="literal">null</span></span><br><span class="line">&amp;&amp; exchange.getRequest().getURI().getPort() == <span class="built_in">this</span>.managementPort) &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上下文设置网关处理mapper这个映 射属性</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class="line"><span class="comment">// 寻找并匹配路由</span></span><br><span class="line"><span class="keyword">return</span> lookupRoute(exchange)</span><br><span class="line"><span class="comment">// .log(&quot;route-predicate-handler-mapping&quot;, Level.FINER) //name this</span></span><br><span class="line">.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(</span><br><span class="line"><span class="string">&quot;Mapping [&quot;</span> + getExchangeDesc(exchange) + <span class="string">&quot;] to &quot;</span> + r);</span><br><span class="line">&#125;</span><br><span class="line">exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class="line"><span class="keyword">return</span> Mono.just(webHandler);</span><br><span class="line">&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No RouteDefinition found for [&quot;</span></span><br><span class="line">+ getExchangeDesc(exchange) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Mono&lt;Route&gt; <span class="title function_">lookupRoute</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.routeLocator.getRoutes()</span><br><span class="line"><span class="comment">// 获取所有路由信息（配置文件）</span></span><br><span class="line">.concatMap(route -&gt; Mono.just(route).filterWhen(r -&gt; &#123;</span><br><span class="line"><span class="comment">// 遍历路由信息</span></span><br><span class="line"><span class="comment">// 根据url和断言条件匹配路由</span></span><br><span class="line"><span class="comment">// gatewayPredicateRouteAttr -&gt; order_route</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());</span><br><span class="line"><span class="comment">// 调用断言工厂，进行路由匹配 这里是断言处理 然后过滤一下 返回一个匹配的路由</span></span><br><span class="line"><span class="keyword">return</span> r.getPredicate().apply(exchange);</span><br><span class="line">&#125;)</span><br><span class="line">.doOnError(e -&gt; logger.error(</span><br><span class="line"><span class="string">&quot;Error applying predicate for route: &quot;</span> + route.getId(),</span><br><span class="line">e))</span><br><span class="line">.onErrorResume(e -&gt; Mono.empty()))</span><br><span class="line">.next()</span><br><span class="line">.map(route -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Route matched: &quot;</span> + route.getId());</span><br><span class="line">&#125;</span><br><span class="line">validateRoute(route, exchange);</span><br><span class="line"><span class="keyword">return</span> route;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值Route的结构如下，其实也就是我yml里面配置的路由。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Route</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URI uri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPredicate&lt;ServerWebExchange&gt; predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; gatewayFilters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置路由：路由id、路由到微服务的uri、断言</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order_route</span>  <span class="comment">#路由ID，全局唯一，建议配合服务名</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://mall-order</span>  <span class="comment">#lb 整合负载均衡器ribbon,loadbalancer</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-color,</span> <span class="string">red</span>  <span class="comment">#添加请求头</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestParameter=color,</span> <span class="string">blue</span>   <span class="comment"># 添加请求参数</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PrefixPath=/mall-order</span>  <span class="comment"># 添加前缀 对应微服务需要配置context-path</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CheckAuth=fox,男</span>  <span class="comment">#配置自定义的过滤器工厂</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://mall-user</span>  <span class="comment">#lb 整合负载均衡器ribbon,loadbalancer</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br></pre></td></tr></table></figure><p>上面那行获取所有路由信息的方法this.routeLocator.getRoutes()，一句话就是利用PropertiesRouteDifinationLocator(因为我们是写在配置文件的，所有定位器是基于配置文件)来根据配置文件获取路由定义，然后把路由定义转化为路由信息。</p><p>然后protected Mono<Route> lookupRoute(ServerWebExchange exchange)方法做的事情就是通过RouteLocator找到所有的路由信息，遍历，然后给请求绑定上下文，然后进入org.springframework.cloud.gateway.handler.AsyncPredicate.AndAsyncPredicate#apply异步断言。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241130614.png" alt="11"></p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241131277.png" alt="Untitled"></p><p>来到org.springframework.cloud.gateway.handler.AsyncPredicate.AndAsyncPredicate#apply方法我们看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Publisher&lt;Boolean&gt; <span class="title function_">apply</span><span class="params">(T t)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.just(delegate.test(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入test方法，这里是最终进行断言的地方，也就是调用路由断言工厂开始进行路由断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;PathPattern&gt; pathPatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.pathPatternParser) &#123;</span><br><span class="line">pathPatternParser.setMatchOptionalTrailingSeparator(</span><br><span class="line">config.isMatchOptionalTrailingSeparator());</span><br><span class="line">config.getPatterns().forEach(pattern -&gt; &#123;</span><br><span class="line"><span class="type">PathPattern</span> <span class="variable">pathPattern</span> <span class="operator">=</span> <span class="built_in">this</span>.pathPatternParser.parse(pattern);</span><br><span class="line">pathPatterns.add(pathPattern);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayPredicate</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="comment">// path = /order/findByUserId/1</span></span><br><span class="line"><span class="type">PathContainer</span> <span class="variable">path</span> <span class="operator">=</span> parsePath(</span><br><span class="line">exchange.getRequest().getURI().getRawPath());</span><br><span class="line"><span class="comment">// pathPatterns = /order/** 然后这里正则匹配</span></span><br><span class="line">Optional&lt;PathPattern&gt; optionalPathPattern = pathPatterns.stream()</span><br><span class="line">.filter(pattern -&gt; pattern.matches(path)).findFirst();</span><br><span class="line"><span class="comment">// 如果匹配到了一个就返回一个true </span></span><br><span class="line"><span class="keyword">if</span> (optionalPathPattern.isPresent()) &#123;</span><br><span class="line"><span class="type">PathPattern</span> <span class="variable">pathPattern</span> <span class="operator">=</span> optionalPathPattern.get();</span><br><span class="line">traceMatch(<span class="string">&quot;Pattern&quot;</span>, pathPattern.getPatternString(), path, <span class="literal">true</span>);</span><br><span class="line"><span class="type">PathMatchInfo</span> <span class="variable">pathMatchInfo</span> <span class="operator">=</span> pathPattern.matchAndExtract(path);</span><br><span class="line">putUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">traceMatch(<span class="string">&quot;Pattern&quot;</span>, config.getPatterns(), path, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> String.format(<span class="string">&quot;Paths: %s, match trailing slash: %b&quot;</span>,</span><br><span class="line">config.getPatterns(), config.isMatchOptionalTrailingSeparator());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此结束寻找并匹配路由方法，现在回到getHandlerInternal方法内部，在匹配到了一个路由之后，开始下一步操作，先删掉之前我们设置的旧的路由信息gatewayPredicateRouteAttr，然后添加一个网关路由属性，绑定的就是之前匹配上的那个路由信息 route。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class="line"><span class="comment">// don&#x27;t handle requests on management port if set and different than server port</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.managementPortType == DIFFERENT &amp;&amp; <span class="built_in">this</span>.managementPort != <span class="literal">null</span></span><br><span class="line">&amp;&amp; exchange.getRequest().getURI().getPort() == <span class="built_in">this</span>.managementPort) &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.empty();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 上下文设置网关处理mapper这个映射属性</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class="line">  <span class="comment">// 寻找并匹配路由</span></span><br><span class="line"><span class="keyword">return</span> lookupRoute(exchange)</span><br><span class="line"><span class="comment">// .log(&quot;route-predicate-handler-mapping&quot;, Level.FINER) //name this</span></span><br><span class="line">.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class="line">    <span class="comment">//移除上下文中旧的属性 gatewayPredicateRouteAttr -&gt; order_route</span></span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(</span><br><span class="line"><span class="string">&quot;Mapping [&quot;</span> + getExchangeDesc(exchange) + <span class="string">&quot;] to &quot;</span> + r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定一个网关路由信息 将来会用来做负载均衡。</span></span><br><span class="line"><span class="comment">// gatewayPredicateRouteAttr -&gt; </span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class="line"><span class="comment">// 最后返回一个处理器对象webHandler 交给适配器来处理</span></span><br><span class="line"><span class="keyword">return</span> Mono.just(webHandler);</span><br><span class="line">&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line"><span class="comment">// 如果没找到任何的路由就返回一个空</span></span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No RouteDefinition found for [&quot;</span></span><br><span class="line">+ getExchangeDesc(exchange) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由信息绑定好了如下：</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241132877.png" alt="22"></p><h3 id="调用Handler处理请求"><a href="#调用Handler处理请求" class="headerlink" title="调用Handler处理请求"></a>调用Handler处理请求</h3><p>回到最初的起点，既然已经找到了handler那么就开始处理了，具体的处理逻辑是在invokeHandler()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> createNotFoundError();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 1.遍历所有的 handlerMapping</span></span><br><span class="line"><span class="keyword">return</span> Flux.fromIterable(<span class="built_in">this</span>.handlerMappings)</span><br><span class="line">  <span class="comment">// 2.获取对应的handlerMapping ，比如常用的 RequestMappingHandlerMapping、RoutePredicateHandlerMapping</span></span><br><span class="line">.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">.next()</span><br><span class="line">.switchIfEmpty(createNotFoundError())</span><br><span class="line"><span class="comment">// 3.获取对应的适配器，调用对应的处理器</span></span><br><span class="line">.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line"><span class="comment">// 4.返回处理结果</span></span><br><span class="line">.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入方法内部，可以看到这段代码首先是拿到所有Adapter，这里我们需要的是一个支持WebHandler的SimpleHandlerAdapter来处理。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241132430.png" alt="33"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Mono&lt;HandlerResult&gt; <span class="title function_">invokeHandler</span><span class="params">(ServerWebExchange exchange, Object handler)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter handlerAdapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (handlerAdapter.supports(handler)) &#123;</span><br><span class="line"><span class="keyword">return</span> handlerAdapter.handle(exchange, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No HandlerAdapter: &quot;</span> + handler));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">****<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> WebHandler.class.isAssignableFrom(handler.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;HandlerResult&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange, Object handler)</span> &#123;</span><br><span class="line"><span class="type">WebHandler</span> <span class="variable">webHandler</span> <span class="operator">=</span> (WebHandler) handler;</span><br><span class="line">Mono&lt;Void&gt; mono = webHandler.handle(exchange);</span><br><span class="line"><span class="keyword">return</span> mono.then(Mono.empty());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入SimpleHandlerAdapter#handle的方法内部，真正处理的方法是Mono<Void> mono &#x3D; webHandler.handle(exchange);由于我们是gateway场景，所有使用的是org.springframework.cloud.gateway.handler.FilteringWebHandler#handle方法。找到这个方法点进去看看。</p><p>这个方法有几个重点：</p><ol><li>获取路由信息</li><li>获取filter</li><li>获取全局filter 适配器模式 把GlobalFilter包装成为GateWayFilter</li><li>合并filter，生成一个过滤器链</li><li>执行filter链  责任链模式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="comment">// 获取之前设置好的路由属性，一个Route对象，里面包括了</span></span><br><span class="line"><span class="comment">// &#123;&#x27;id&#x27;:&#x27;order_route&#x27;,&#x27;uri&#x27;:&#x27;lb://mall-order&#x27;,&#x27;predicate&#x27;:[&#x27;/order/**&#x27;],&#x27;filters&#x27;:[]&#125;</span></span><br><span class="line"><span class="type">Route</span> <span class="variable">route</span> <span class="operator">=</span> exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line"><span class="comment">// 获取Filter 比如在路由里面加上的添加请求头的Filter </span></span><br><span class="line"><span class="comment">// geteway的过滤器是添加了才有</span></span><br><span class="line"> List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();</span><br><span class="line">  <span class="comment">// 获取全局过滤器</span></span><br><span class="line">List&lt;GatewayFilter&gt; combined = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.globalFilters);</span><br><span class="line">combined.addAll(gatewayFilters);</span><br><span class="line"><span class="comment">// 排序并生产过滤器链</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(combined);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Sorted gatewayFilterFactories: &quot;</span> + combined);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultGatewayFilterChain</span>(combined).filter(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始进入到Filter链的内部看一下这个责任链执行的时候到底是做了什么逻辑，责任链模式不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultGatewayFilterChain</span> <span class="keyword">implements</span> <span class="title class_">GatewayFilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">DefaultGatewayFilterChain(List&lt;GatewayFilter&gt; filters) &#123;</span><br><span class="line"><span class="built_in">this</span>.filters = filters;</span><br><span class="line"><span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">DefaultGatewayFilterChain</span><span class="params">(DefaultGatewayFilterChain parent, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.filters = parent.getFilters();</span><br><span class="line"><span class="built_in">this</span>.index = index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;GatewayFilter&gt; <span class="title function_">getFilters</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> filters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.defer(() -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; filters.size()) &#123;</span><br><span class="line"><span class="type">GatewayFilter</span> <span class="variable">filter</span> <span class="operator">=</span> filters.get(<span class="built_in">this</span>.index);</span><br><span class="line"><span class="type">DefaultGatewayFilterChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultGatewayFilterChain</span>(<span class="built_in">this</span>,</span><br><span class="line"><span class="built_in">this</span>.index + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> filter.filter(exchange, chain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.empty(); <span class="comment">// complete</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于每个chain做的是什么任务，比如我们是一个添加请求头的Filter，那么我们就会调用这个链，我们链调用完了是会向下传递的，但是这里还不是最终的发起请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddRequestHeaderGatewayFilterFactory</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractNameValueGatewayFilterFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(NameValueConfig config)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange,</span></span><br><span class="line"><span class="params">GatewayFilterChain chain)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ServerWebExchangeUtils.expand(exchange, config.getValue());</span><br><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest().mutate()</span><br><span class="line">.header(config.getName(), value).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange.mutate().request(request).build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> filterToStringCreator(AddRequestHeaderGatewayFilterFactory.<span class="built_in">this</span>)</span><br><span class="line">.append(config.getName(), config.getValue()).toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们此时请求的uri还是没变的，我们需要在某个地方改变这个请求uri，发起调用。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241133165.png" alt="44"></p><p>实际上要到了<code>LoadBalancerClientFilter</code> 才开始真正构建实际请求。主要的步骤是：</p><ol><li>获取url也就是根据上一个filter处理后加入的新的GATEWAY_REQUEST_URL_ATTR属性。</li><li>获取服务实例</li><li>构建实际的请求uri，旧的uri和服务实例的IP port整合</li><li>绑定新的uri到上下文</li><li>交给下游处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;Duplicates&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line"><span class="comment">// 获取 url ==&gt; lb://mall-order/order/findOrderByUserId/1</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">url</span> <span class="operator">=</span> exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);</span><br><span class="line"><span class="type">String</span> <span class="variable">schemePrefix</span> <span class="operator">=</span> exchange.getAttribute(GATEWAY_SCHEME_PREFIX_ATTR);</span><br><span class="line"><span class="keyword">if</span> (url == <span class="literal">null</span></span><br><span class="line">|| (!<span class="string">&quot;lb&quot;</span>.equals(url.getScheme()) &amp;&amp; !<span class="string">&quot;lb&quot;</span>.equals(schemePrefix))) &#123;</span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line">addOriginalRequestUrl(exchange, url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;LoadBalancerClientFilter url before: &quot;</span> + url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择一个服务实例 拿到他的IP端口等等信息</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> choose(exchange);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> NotFoundException.create(properties.isUse404(),</span><br><span class="line"><span class="string">&quot;Unable to find instance for &quot;</span> + url.getHost());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原始的uri &lt;http://localhost:8888/order/findOrderByUserId/1&gt;</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> exchange.getRequest().getURI();</span><br><span class="line"><span class="type">String</span> <span class="variable">overrideScheme</span> <span class="operator">=</span> instance.isSecure() ? <span class="string">&quot;https&quot;</span> : <span class="string">&quot;http&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (schemePrefix != <span class="literal">null</span>) &#123;</span><br><span class="line">overrideScheme = url.getScheme();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建新的uri </span></span><br><span class="line"><span class="type">URI</span> <span class="variable">requestUrl</span> <span class="operator">=</span> loadBalancer.reconstructURI(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">DelegatingServiceInstance</span>(instance, overrideScheme), uri);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;LoadBalancerClientFilter url chosen: &quot;</span> + requestUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定信息到上下文中</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);</span><br><span class="line"><span class="comment">// 执行下一个操作 </span></span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> ServiceInstance <span class="title function_">choose</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> loadBalancer.choose(</span><br><span class="line">         ((URI)exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR)).getHost());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面第三部替换uri的结果</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241134716.png" alt="55"></p><p>来到下游过滤器也就是<code>NettyRoutingFilter</code> ，已经在上游filter设置好了uri，我们在这里直接发起请求就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;Duplicates&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line"><span class="comment">// 获取请求uri</span></span><br><span class="line">   <span class="type">URI</span> <span class="variable">requestUrl</span> <span class="operator">=</span> exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">scheme</span> <span class="operator">=</span> requestUrl.getScheme();</span><br><span class="line"><span class="keyword">if</span> (isAlreadyRouted(exchange)</span><br><span class="line">|| (!<span class="string">&quot;http&quot;</span>.equals(scheme) &amp;&amp; !<span class="string">&quot;https&quot;</span>.equals(scheme))) &#123;</span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line">setAlreadyRouted(exchange);</span><br><span class="line"><span class="comment">// 构建请求</span></span><br><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">HttpMethod</span> <span class="variable">method</span> <span class="operator">=</span> HttpMethod.valueOf(request.getMethodValue());</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> requestUrl.toASCIIString();</span><br><span class="line"></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">filtered</span> <span class="operator">=</span> filterRequest(getHeadersFilters(), exchange);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">DefaultHttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpHeaders</span>();</span><br><span class="line">filtered.forEach(httpHeaders::set);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">preserveHost</span> <span class="operator">=</span> exchange</span><br><span class="line">.getAttributeOrDefault(PRESERVE_HOST_HEADER_ATTRIBUTE, <span class="literal">false</span>);</span><br><span class="line"><span class="type">Route</span> <span class="variable">route</span> <span class="operator">=</span> exchange.getAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line"></span><br><span class="line">Flux&lt;HttpClientResponse&gt; responseFlux = getHttpClient(route, exchange)</span><br><span class="line">.headers(headers -&gt; &#123;</span><br><span class="line">headers.add(httpHeaders);</span><br><span class="line"><span class="comment">// Will either be set below, or later by Netty</span></span><br><span class="line">headers.remove(HttpHeaders.HOST);</span><br><span class="line"><span class="keyword">if</span> (preserveHost) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> request.getHeaders().getFirst(HttpHeaders.HOST);</span><br><span class="line">headers.add(HttpHeaders.HOST, host);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发起请求</span></span><br><span class="line">&#125;).request(method).uri(url).send((req, nettyOutbound) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">nettyOutbound</span><br><span class="line">.withConnection(connection -&gt; log.trace(<span class="string">&quot;outbound route: &quot;</span></span><br><span class="line">+ connection.channel().id().asShortText()</span><br><span class="line">+ <span class="string">&quot;, inbound: &quot;</span> + exchange.getLogPrefix()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nettyOutbound.send(request.getBody().map(<span class="built_in">this</span>::getByteBuf));</span><br><span class="line">&#125;).responseConnection((res, connection) -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Defer committing the response until all route filters have run</span></span><br><span class="line"><span class="comment">// Put client response as ServerWebExchange attribute and write</span></span><br><span class="line"><span class="comment">// response later NettyWriteResponseFilter</span></span><br><span class="line">exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);</span><br><span class="line">exchange.getAttributes().put(CLIENT_RESPONSE_CONN_ATTR, connection);</span><br><span class="line"></span><br><span class="line"><span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line"><span class="comment">// put headers and status so filters can modify the response</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line"></span><br><span class="line">res.responseHeaders().forEach(</span><br><span class="line">entry -&gt; headers.add(entry.getKey(), entry.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">contentTypeValue</span> <span class="operator">=</span> headers.getFirst(HttpHeaders.CONTENT_TYPE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(contentTypeValue)) &#123;</span><br><span class="line">exchange.getAttributes().put(ORIGINAL_RESPONSE_CONTENT_TYPE_ATTR,</span><br><span class="line">contentTypeValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setResponseStatus(res, response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure headers filters run after setting status so it is</span></span><br><span class="line"><span class="comment">// available in response</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">filteredResponseHeaders</span> <span class="operator">=</span> HttpHeadersFilter.filter(</span><br><span class="line">getHeadersFilters(), headers, exchange, Type.RESPONSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!filteredResponseHeaders</span><br><span class="line">.containsKey(HttpHeaders.TRANSFER_ENCODING)</span><br><span class="line">&amp;&amp; filteredResponseHeaders</span><br><span class="line">.containsKey(HttpHeaders.CONTENT_LENGTH)) &#123;</span><br><span class="line"><span class="comment">// It is not valid to have both the transfer-encoding header and</span></span><br><span class="line"><span class="comment">// the content-length header.</span></span><br><span class="line"><span class="comment">// Remove the transfer-encoding header in the response if the</span></span><br><span class="line"><span class="comment">// content-length header is present.</span></span><br><span class="line">response.getHeaders().remove(HttpHeaders.TRANSFER_ENCODING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exchange.getAttributes().put(CLIENT_RESPONSE_HEADER_NAMES,</span><br><span class="line">filteredResponseHeaders.keySet());</span><br><span class="line"></span><br><span class="line">response.getHeaders().putAll(filteredResponseHeaders);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Mono.just(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">responseTimeout</span> <span class="operator">=</span> getResponseTimeout(route);</span><br><span class="line"><span class="keyword">if</span> (responseTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">responseFlux = responseFlux</span><br><span class="line">.timeout(responseTimeout, Mono.error(<span class="keyword">new</span> <span class="title class_">TimeoutException</span>(</span><br><span class="line"><span class="string">&quot;Response took longer than timeout: &quot;</span> + responseTimeout)))</span><br><span class="line">.onErrorMap(TimeoutException.class,</span><br><span class="line">th -&gt; <span class="keyword">new</span> <span class="title class_">ResponseStatusException</span>(HttpStatus.GATEWAY_TIMEOUT,</span><br><span class="line">th.getMessage(), th));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> responseFlux.then(chain.filter(exchange));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GateWay工作原理&quot;&gt;&lt;a href=&quot;#GateWay工作原理&quot; class=&quot;headerlink&quot; title=&quot;GateWay工作原理&quot;&gt;&lt;/a&gt;GateWay工作原理&lt;/h1&gt;&lt;h2 id=&quot;重要概念&quot;&gt;&lt;a href=&quot;#重要概念&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="SpringCloud" scheme="http://example.com/tags/SpringCloud/"/>
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="GateWay" scheme="http://example.com/tags/GateWay/"/>
    
  </entry>
  
  <entry>
    <title>Nacos源码分析</title>
    <link href="http://example.com/2022/03/21/Nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/21/Nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-20T16:26:41.000Z</published>
    <updated>2022-03-23T08:04:12.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos-Tutorial"><a href="#Nacos-Tutorial" class="headerlink" title="Nacos Tutorial"></a>Nacos Tutorial</h1><h2 id="Nacos总览"><a href="#Nacos总览" class="headerlink" title="Nacos总览"></a>Nacos总览</h2><h3 id="nacos服务健康探测机制与保护阈值"><a href="#nacos服务健康探测机制与保护阈值" class="headerlink" title="nacos服务健康探测机制与保护阈值"></a>nacos服务健康探测机制与保护阈值</h3><p>引入第一个问题，健康探测机制，服务注册中心都必须是要有的</p><p>nacos健康探测机制，分成两种，临时实例、持久化实例，针对不同的实例，他的健康探测机制不太一样，dubbo服务注册的时候要带上一个参数[ephemeral]，可以取值为两个，临时和持久化</p><p>默认情况下都不用去主动设置这个参数，默认都是ephemeral，临时实例</p><p>临时的话，默认每隔5s上报一次心跳，nacos如果15s没收到心跳就标记为不健康，超过30s没收到就摘除这个服务实例</p><p>持久化的话，nacos主动探测，20s探测一次，即使探测失败，也就是不健康状态，但是不会摘除这个服务实例</p><p>默认情况下，不健康的实例是不返回的，但是如果健康实例比例太低，会导致健康实例请求压力过大，被打死，引发服务雪崩，所以有保护阈值的概念</p><p>保护阈值，可以设置为0~1之间的比例，如果健康实例比例太低，则把不健康实例一起返回，此时会让很多请求走到不健康实例，会导致请求失败，但是可以避免健康实例的请求流量过大被打死，牺牲了一致性，得到了可用性 </p><h3 id="服务雪崩问题以及nacos健康保护阈值"><a href="#服务雪崩问题以及nacos健康保护阈值" class="headerlink" title="服务雪崩问题以及nacos健康保护阈值"></a>服务雪崩问题以及nacos健康保护阈值</h3><p>服务雪崩问题，nacos健康保护阈值</p><p>库存服务有10台机器，10个服务实例，订单服务会大范围的去调用库存服务，假设每个库存服务实例单机可以抗每秒500次请求，QPS 500，高峰 QPS 500 * 10 &#x3D; 5000，某一天，库存服务实例10个，里面有5个都崩溃了</p><p>5台机器都是虚拟机，部署在一个物理机，物理机故障了，就会导致5个虚拟机一起故障了这样子</p><p>每秒5000次请求，都会发送给剩下的5台健康的实例，平均每台实例会收到每秒1000次请求，远远超出了单机极限QPS，800，1000已经超过了。 </p><p>nacos有一个保护阈值， 比如设置为0.8 那么10台实例挂了两台都是没关系的，不会触发保护机制，订单服务会去请求这些剩下的8个健康实例，如果挂了4个，剩下6个，如果订单服务来请求，可能扛不住，如果设置阈值为0.6，所以nacos会返回订单服务6个健康的实例和4个挂了的实例，订单那边请求失败，但是不会把机器打垮，防止雪崩。</p><h3 id="保护阈值机制开启后的CAP问题分析"><a href="#保护阈值机制开启后的CAP问题分析" class="headerlink" title="保护阈值机制开启后的CAP问题分析"></a>保护阈值机制开启后的CAP问题分析</h3><p>一句话， 开了保护阈值机制打开了，会保障可用性，牺牲了一致性，订单看起来这些实例就不是一致。如果不打开保护阈值机制，那么请求的都是健康的服务实例，那么订单服务看起来都是一致的。</p><h3 id="自研Distro分布式一致性协议分析"><a href="#自研Distro分布式一致性协议分析" class="headerlink" title="自研Distro分布式一致性协议分析"></a>自研Distro分布式一致性协议分析</h3><p>nacos基础原理+开发实战+核心功能+数据模型，重点要给大家讲解一下nacos的内核原理</p><p>服务注册这块，允许大量的服务实例来注册，在nacos集群里管理所有的服务实例数据，针对你的nacos里管理的服务实例数据服务发现，注册（写操作），存储（nacos集群存放服务实例数据），发现（读操作），针对临时服务实例数据的存储</p><p>灵魂拷问：服务注册找nacos集群里哪个节点来发起？服务实例数据是存储在哪个nacos节点里？发现的时候找的是nacos哪个节点？</p><p>nacos集群启动之后按如下原则运作：</p><p>1、nacos每个节点都可以处理写请求，收到请求后，路由，根据ip:port路由算法，计算所属节点，把请求转发到负责这个数据的节点去，负责节点解析请求在本机里进行内存存储，定期执行同步任务，把本机负责的数据同步到其他节点，所以每个节点都有全量数据的存储</p><p>distro分布式一致性协议里，设计了一个定时sync同步机制和任务</p><p>关键点，仅仅按照这套算法来运行，会导致数据分片，data partition，每个nacos节点仅仅负责和管理了一部分的服务实例数据</p><p>提出第一种服务发现读数据的时候，nacos节点上没有你要的服务实例的数据，写路由+数据分片+读路由的架构设计，可用性的问题，优点是数据是强一致的，CAP，C，牺牲掉A，可用性就没有了，并不是nacos采用的方案，CP</p><p>nacos默认提供的AP，保证可用性</p><p>通过各个节点 定时同步数据的机制，可以确保说什么，每个节点除了处理自己负责的那部分数据写入，自己也会不断的把自己的数据同步给别的节点，定时的不断的接收到别的节点同步过来的数据</p><p>对于你的每一个节点来说，他会发现你这个节点上，会有所有节点的数据都汇总到你这里来，你这里会源源不断的接收到集群里完整的服务实例数据，保证最终一致性的概念，最终每个节点都会有集群里最新的数据</p><p>时间差问题-&gt;最终一致性，牺牲掉了一致性，AP，CP</p><p>2、新加入的nacos节点会拉取全量数据，轮询所有nacos节点，发送请求拉取全量数据，所以其实每个nacos节点上都会有所有注册上来的临时服务实例的数据</p><p>3、nacos每个节点都会定期发送心跳给其他的节点，心跳请求会进行数据校验，主要是交换数据的校验值，如果发现要是其他机器上的数据跟自己不一致，就会全量拉取数据进行补齐</p><p>4、nacos每个节点都可以处理读请求，因为有全量数据</p><p>distro协议是兼顾CAP中的AP的，在这个协议之下，所有节点通过定期数据同步，还有心跳校验实现节点数据最终一致，让每个节点都有全量数据，这样的话，如果有节点宕机崩溃都是没关系的</p><p>另外网络分区的话，也是没事的，因为不同的网络分区里就是读写分区中的nacos节点就可以了，就是没办法互相同步数据了，数据会不一致（通过MD5来校验的），但是一旦分区问题恢复了，心跳校验机制运作起来，数据会自动补齐的</p><h3 id="基于Raft协议的弱CP机制"><a href="#基于Raft协议的弱CP机制" class="headerlink" title="基于Raft协议的弱CP机制"></a>基于Raft协议的弱CP机制</h3><p>我如果是基于路由转发的这种方式， 数据集中在一个服务器上，这样是不可行的，会把机器打垮。如果是全量复制，数据也是强一致的，但是这种同步全量复制机制是很重的，写入性能非常低。</p><p>Distro这种是异步复制，保障的是最终一致性，再加上心跳机制，各个节点最终是一致的，但是有时间差问题，牺牲了一致性。即使崩溃了，也有一个机器有几乎全量数据。</p><p>首先Nacos集群通过Raft协议来选举，选举成为leader的节点才能接受读请求，然后接受读请求这一段时间服务是不可用，因为有一个raft日志同步过程（半数节点以上），但是Nacos的Raft不是标准的两阶段提交（2.0之后是标准的Raft两阶段提交），所以Nacos是有是一个弱CP机制的。有一个问题，半数节点同步了，其他节点呢？Nacos是通过注册心跳来解决，Nacos主节点发送心跳（zip）的时候附带了主节点上一些服务信息，然后从节点如果发现自己少了这些，那么就主动call注解点来拉取。</p><h3 id="临时实例和持久实例"><a href="#临时实例和持久实例" class="headerlink" title="临时实例和持久实例"></a>临时实例和持久实例</h3><ul><li>临时实例：默认情况，注册在内存注册表中，不会持久化到磁盘文件，健康检查是client模式，client主动上报，5S一次，Server 检查心跳情况，15秒没上报就设置为不健康，30S没上报就删除实例</li><li>持久化实例：注册到内存注册表之后，还会写入到磁盘文件，心跳检测是Server主动去检测client心跳是拉模式，20S检查一次，检测失败会把实例标记为不健康，但不会清除，因为持久化了</li></ul><p>使用场景：临时实例是存在突发流量横向扩展服务，适用于互联网，持久实例是相对固定的实例。</p><h2 id="Naocs-源码分析"><a href="#Naocs-源码分析" class="headerlink" title="Naocs 源码分析"></a>Naocs 源码分析</h2><h3 id="Nacos-Client源码分析"><a href="#Nacos-Client源码分析" class="headerlink" title="Nacos Client源码分析"></a>Nacos Client源码分析</h3><h4 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h4><p>Instance类，代表一个服务实例，一些基础信息，一个实例隶属于一个服务，一个集群</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instance</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">742906310567291979L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unique id of this instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String instanceId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance ip.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance weight.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">1.0D</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance health status.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">healthy</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If instance is enabled to accept request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If instance is ephemeral.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ephemeral</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cluster information of instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String clusterName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service information of instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user extended attributes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceInfo类，包含一个Instance列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInfo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">jsonFromServer</span> <span class="operator">=</span> EMPTY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLITER</span> <span class="operator">=</span> <span class="string">&quot;@@&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 服务名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String clusters; <span class="comment">// 一个服务可能有多个集群</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">cacheMillis</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Instance&gt; hosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Instance&gt;(); <span class="comment">// 当前服务所有的服务实例列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastRefTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">checksum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">allIPs</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingService 接口，它有一个实现类NacosNamingService，可以完成Client到Server的各种通信，注册&#x2F;取消注册，订阅取消等等</p><h4 id="Nacos启动流程"><a href="#Nacos启动流程" class="headerlink" title="Nacos启动流程"></a>Nacos启动流程</h4><p>Nacos启动是根据事件监听机制，监听到web服务器启动之后，就开始自动注册。自动注册之前的逻辑先跳过，直接来看到底是怎么注册的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> namingService();</span><br><span class="line"><span class="comment">// 微服务名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> registration.getServiceId();</span><br><span class="line"><span class="comment">// 分组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> nacosDiscoveryProperties.getGroup();</span><br><span class="line"><span class="comment">// 生成instance </span></span><br><span class="line"><span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用注册逻辑</span></span><br><span class="line">namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">instance.getIp(), instance.getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line"><span class="comment">// rethrow a RuntimeException if the registration is failed.</span></span><br><span class="line"><span class="comment">// issue : https://github.com/alibaba/spring-cloud-alibaba/issues/1132</span></span><br><span class="line">rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入的是NacosNamingService类的registerInstance方法，其实还是一个封装instance，然后注册的，进入到这个重载方法内部，有几步需要做的：</p><ol><li>验证instance是否合法</li><li>获取groupSerce名称 例如 my_default_group@@order_service</li><li>开始心跳  </li><li>发起注册</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="comment">// 是否是临时实例 构建Beat信息</span></span><br><span class="line">            <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            <span class="comment">// 开始心跳</span></span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看一下心跳信息有什么内容，其实就是当前实例的一些东西， 加上间隔时间。默认是5S发送一次心跳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeatInfo <span class="title function_">buildBeatInfo</span><span class="params">(String groupedServiceName, Instance instance)</span> &#123;</span><br><span class="line">        <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeatInfo</span>();</span><br><span class="line">        beatInfo.setServiceName(groupedServiceName);</span><br><span class="line">        beatInfo.setIp(instance.getIp());</span><br><span class="line">        beatInfo.setPort(instance.getPort());</span><br><span class="line">        beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">        beatInfo.setWeight(instance.getWeight());</span><br><span class="line">        beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">        beatInfo.setScheduled(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 心跳间隔 默认5秒</span></span><br><span class="line">        beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line">        <span class="keyword">return</span> beatInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码执行顺序可以看出，既然先执行发送心跳，但是此时还没注册上去，发送心跳必然找不到服务啊？其实这是一个延迟任务，点进发送心跳的源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add beat information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName service name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beatInfo    beat information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> &#123;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[BEAT] adding beat: &#123;&#125; to beat map.&quot;</span>, beatInfo);</span><br><span class="line"><span class="comment">// key的格式为 groupId@@微服务名称##ip##port</span></span><br><span class="line"><span class="comment">// 这个key是固定了主机了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> buildKey(serviceName, beatInfo.getIp(), beatInfo.getPort());</span><br><span class="line">        <span class="type">BeatInfo</span> <span class="variable">existBeat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//fix #1733 again</span></span><br><span class="line"><span class="comment">// dom2Beat是一个缓存map，key是主机，value=主机发送的心跳信息beat</span></span><br><span class="line"><span class="comment">// 前面的心跳停了才发送新的心跳</span></span><br><span class="line">        <span class="keyword">if</span> ((existBeat = dom2Beat.put(key, beatInfo)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            existBeat.setStopped(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始定时任务 5S之后开始任务 在结束之前又开始一个新的任务</span></span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">        MetricsMonitor.getDom2BeatSizeMonitor().set(dom2Beat.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看一下BeatTask的run方法，其实就是使用httpClient发起调用，然后结束之前把任务再添加今天循环调用而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nextTime</span> <span class="operator">=</span> beatInfo.getPeriod();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发送心跳 PUT 请求</span></span><br><span class="line">                <span class="type">JsonNode</span> <span class="variable">result</span> <span class="operator">=</span> serverProxy.sendBeat(beatInfo, BeatReactor.<span class="built_in">this</span>.lightBeatEnabled);</span><br><span class="line">                <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> result.get(<span class="string">&quot;clientBeatInterval&quot;</span>).asLong();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">lightBeatEnabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                    lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="built_in">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nextTime = interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> NamingResponseCode.OK;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                    code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果发现此实例在nacos server上面没有注册，那么就执行注册的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                    <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">                    instance.setPort(beatInfo.getPort());</span><br><span class="line">                    instance.setIp(beatInfo.getIp());</span><br><span class="line">                    instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                    instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                    instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                    instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                    instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                    instance.setEphemeral(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                                NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                        JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception unknownEx) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, unknown exception msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                        JacksonUtils.toJson(beatInfo), unknownEx.getMessage(), unknownEx);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 再次嵌套调用</span></span><br><span class="line">                executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入JsonNode result &#x3D; serverProxy.sendBeat(beatInfo, BeatReactor.this.lightBeatEnabled);把BeatInfo拆开放入map，发送过去，是一个PUT请求，请求url &#x3D; nacos&#x2F;v1&#x2F;ns&#x2F;instance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonNode <span class="title function_">sendBeat</span><span class="params">(BeatInfo beatInfo, <span class="type">boolean</span> lightBeatEnabled)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">            NAMING_LOGGER.debug(<span class="string">&quot;[BEAT] &#123;&#125; sending beat to server: &#123;&#125;&quot;</span>, namespaceId, beatInfo.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">8</span>);</span><br><span class="line">        Map&lt;String, String&gt; bodyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!lightBeatEnabled) &#123;</span><br><span class="line">            bodyMap.put(<span class="string">&quot;beat&quot;</span>, JacksonUtils.toJson(beatInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, beatInfo.getServiceName());</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, beatInfo.getCluster());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, beatInfo.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(beatInfo.getPort()));</span><br><span class="line">        <span class="comment">// 发送Beat心跳</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/beat&quot;</span>, params, bodyMap, HttpMethod.PUT);</span><br><span class="line">        <span class="keyword">return</span> JacksonUtils.toObj(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到上文的注册逻辑，点进去看一下注册实例是怎么做的，其实就是两件事情</p><ol><li>把instace这个对象拆开，放入parmas</li><li>发起post请求，地址为 nacos&#x2F;v1&#x2F;ns&#x2F;instance</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>, namespaceId, serviceName,</span><br><span class="line">                instance);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line">        <span class="comment">// 权重</span></span><br><span class="line">        params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">        params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">        <span class="comment">// 健康度</span></span><br><span class="line">        params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">        params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">        params.put(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.toJson(instance.getMetadata()));</span><br><span class="line">        <span class="comment">// nacos/v1/ns/instance</span></span><br><span class="line">        reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入 reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);来看一些是怎么做的，一句话总结就是 如果有多个nacos节点，那么就轮训尝试注册，直到成功或是尝试次数达到了nacos服务数量。 如果是单节点，默认尝试次数为3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span><br><span class="line"><span class="params">                         String method)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;no server available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">NacosException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>();</span><br><span class="line"><span class="comment">// domain不为空，先连接这个，默认尝试次数3</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用服务注册</span></span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是一个重要的信息如果是多个nacos节点，其实是随机找个nacos节点来注册的</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(servers.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">server</span> <span class="operator">=</span> servers.get(index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, server, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 该server连接失败 ，连接下一个</span></span><br><span class="line">                index = (index + <span class="number">1</span>) % servers.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NAMING_LOGGER.error(<span class="string">&quot;request: &#123;&#125; failed, servers: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>, api, servers, exception.getErrCode(),</span><br><span class="line">                exception.getErrMsg());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(exception.getErrCode(),</span><br><span class="line">                <span class="string">&quot;failed to req API:&quot;</span> + api + <span class="string">&quot; after all servers(&quot;</span> + servers + <span class="string">&quot;) tried: &quot;</span> + exception.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后面发送HTTP POST请求的代码就不再细看了，是使用NameServerProxy来做，里面调用的是HttpClient发送的请求，请求的地址是<a href="http://127.0.0.1:8848/nacos/v1/ns/instance%E3%80%82">http://127.0.0.1:8848/nacos/v1/ns/instance。</a></p><h4 id="Nacos获取所有服务"><a href="#Nacos获取所有服务" class="headerlink" title="Nacos获取所有服务"></a>Nacos获取所有服务</h4><p>直接说结论，是在NamingServiceProxy里面调用获取服务列表的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">queryList</span><span class="params">(String serviceName, String clusters, <span class="type">int</span> udpPort, <span class="type">boolean</span> healthyOnly)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">8</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">        params.put(<span class="string">&quot;udpPort&quot;</span>, String.valueOf(udpPort));</span><br><span class="line">        params.put(<span class="string">&quot;clientIP&quot;</span>, NetUtils.localIP());</span><br><span class="line">        params.put(<span class="string">&quot;healthyOnly&quot;</span>, String.valueOf(healthyOnly));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP请求 调用服务列表</span></span><br><span class="line">        <span class="keyword">return</span> reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/list&quot;</span>, params, HttpMethod.GET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Nacos定时更新本地服务"><a href="#Nacos定时更新本地服务" class="headerlink" title="Nacos定时更新本地服务"></a>Nacos定时更新本地服务</h4><p>容器在启动的时候创建了一个<code>NacosWatch</code> Bean，这个Bean就是和服务订阅有关的，看一下关键的方法    namingService.subscribe(properties.getService(), properties.getGroup(),这里就是订阅服务的地方了。我们看一些具体是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.running.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line"><span class="type">EventListener</span> <span class="variable">eventListener</span> <span class="operator">=</span> listenerMap.computeIfAbsent(buildKey(),</span><br><span class="line">event -&gt; <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> NamingEvent) &#123;</span><br><span class="line">List&lt;Instance&gt; instances = ((NamingEvent) event)</span><br><span class="line">.getInstances();</span><br><span class="line">Optional&lt;Instance&gt; instanceOptional = selectCurrentInstance(</span><br><span class="line">instances);</span><br><span class="line">instanceOptional.ifPresent(currentInstance -&gt; &#123;</span><br><span class="line">resetIfNeeded(currentInstance);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> nacosServiceManager</span><br><span class="line">.getNamingService(properties.getNacosProperties());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">namingService.subscribe(properties.getService(), properties.getGroup(),</span><br><span class="line">Arrays.asList(properties.getClusterName()), eventListener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;namingService subscribe failed, properties:&#123;&#125;&quot;</span>, properties, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.watchFuture = <span class="built_in">this</span>.taskScheduler.scheduleWithFixedDelay(</span><br><span class="line"><span class="built_in">this</span>::nacosServicesWatch, <span class="built_in">this</span>.properties.getWatchDelay());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用层级很深，最后来到的是HostReactor下的subscribe方法，里面有一个关键的 getServiceInfo(serviceName, clusters);这里就是过去服务信息了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceName, String clusters, EventListener eventListener)</span> &#123;</span><br><span class="line">        notifier.registerListener(serviceName, clusters, eventListener);</span><br><span class="line">        getServiceInfo(serviceName, clusters);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入这个方法内部，就是现在本地注册表中获取，如果没有这个服务那就先创建一个，然后向server发送get请求获取服务，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.debug(<span class="string">&quot;failover-mode: &quot;</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line"><span class="comment">// 构建key 请求格式为 groupId@@微服务ID@@cluster名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">        <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">            <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从当前client本地注册表中获取当前服务 本地注册表是个map </span></span><br><span class="line"><span class="comment">// key -&gt; groupId@@微服务ID@@cluster名称 value -&gt; serviceinfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="comment">// 如果为空 （第一次启动肯定是空的）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == serviceObj) &#123;</span><br><span class="line"><span class="comment">// 创建个空的服务 没有任何提供者实例</span></span><br><span class="line">            serviceObj = <span class="keyword">new</span> <span class="title class_">ServiceInfo</span>(serviceName, clusters);</span><br><span class="line">            <span class="comment">// 放入注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line">            <span class="comment">// 临时缓存 主要是使用这个缓存的key 不能重复 </span></span><br><span class="line"><span class="comment">// 只要服务名称出现在这个缓存map中，就表示这个服务正在被更新</span></span><br><span class="line">            updatingMap.put(serviceName, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"><span class="comment">// 开始更新服务</span></span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line"><span class="comment">// 更新完了 删掉</span></span><br><span class="line">            updatingMap.remove(serviceName);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line"><span class="comment">// 如果注册表中有了这个服务 而且临时缓存中有了这个服务</span></span><br><span class="line">            <span class="comment">// 那这个服务就是正在被更新 那就等一会儿</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATE_HOLD_INTERVAL &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// hold a moment waiting for update finish</span></span><br><span class="line">                <span class="keyword">synchronized</span> (serviceObj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serviceObj.wait(UPDATE_HOLD_INTERVAL);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        NAMING_LOGGER</span><br><span class="line">                                .error(<span class="string">&quot;[getServiceInfo] serviceName:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定时任务启动 定时更新本地注册表中的当前服务</span></span><br><span class="line">        scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们先来看 updateServiceNow(serviceName, clusters);这个方法就是调用了一个updateService方法，那直接来看updateService就好，里面就是获取本地注册表和远程注册表的服务，然后做一个合并操作，合并就是在processServiceJson(result);处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateService</span><span class="params">(String serviceName, String clusters)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">// 在本地注册表中获取当前服务 </span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldService</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 向server发送get请求 获取服务</span></span><br><span class="line">            <span class="comment">// 返回的serviceinfo是以json串形式出现的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> serverProxy.queryList(serviceName, clusters, pushReceiver.getUdpPort(), <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(result)) &#123;</span><br><span class="line"><span class="comment">// 将来自于server的serviceinfo更新到本地 </span></span><br><span class="line">                processServiceJson(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldService != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (oldService) &#123;</span><br><span class="line">                    oldService.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析processServiceJson(result);之前要达成一个共识，来自server的数据是一个最新的数据，其实就是合并新旧数据的过程，没什么特别的地方。至此，我们清楚了是如果请求server获取最新数据然后与本地合并了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">processServiceJson</span><span class="params">(String json)</span> &#123;</span><br><span class="line"><span class="comment">// 吧来自server的json处理为ServiceInfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> JacksonUtils.toObj(json, ServiceInfo.class);</span><br><span class="line"><span class="comment">// 本地注册表中的ServiceInfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldService</span> <span class="operator">=</span> serviceInfoMap.get(serviceInfo.getKey());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pushEmptyProtection &amp;&amp; !serviceInfo.validate()) &#123;</span><br><span class="line">            <span class="comment">//empty or error push, just ignore</span></span><br><span class="line">            <span class="keyword">return</span> oldService;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 本地注册表中存在当前服务 </span></span><br><span class="line">        <span class="keyword">if</span> (oldService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为了安全起见，默认服务器的数据是最新的</span></span><br><span class="line">            <span class="keyword">if</span> (oldService.getLastRefTime() &gt; serviceInfo.getLastRefTime()) &#123;</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;out of date data received, old-t: &quot;</span> + oldService.getLastRefTime() + <span class="string">&quot;, new-t: &quot;</span></span><br><span class="line">                        + serviceInfo.getLastRefTime());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把来自service的serviceinfo替换掉本地注册表的</span></span><br><span class="line">            serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 遍历本地注册表服务中的所有实例</span></span><br><span class="line">            Map&lt;String, Instance&gt; oldHostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Instance&gt;(oldService.getHosts().size());</span><br><span class="line">            <span class="keyword">for</span> (Instance host : oldService.getHosts()) &#123;</span><br><span class="line"><span class="comment">// ip:port 作为key，instance作为value放进去</span></span><br><span class="line">                oldHostMap.put(host.toInetAddr(), host);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历来自于server的服务的所有实例</span></span><br><span class="line">            Map&lt;String, Instance&gt; newHostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Instance&gt;(serviceInfo.getHosts().size());</span><br><span class="line">            <span class="keyword">for</span> (Instance host : serviceInfo.getHosts()) &#123;</span><br><span class="line"><span class="comment">// ip:port 作为key，instance作为value放进去</span></span><br><span class="line">                newHostMap.put(host.toInetAddr(), host);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该set存的是两个map old 与 new 都有的client </span></span><br><span class="line"><span class="comment">// 但他们的instance不同，会把来自server的instance写入</span></span><br><span class="line">            Set&lt;Instance&gt; modHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line"><span class="comment">// 只有newHostMap存在的intstance，也就是新增的</span></span><br><span class="line">            Set&lt;Instance&gt; newHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line"><span class="comment">// 只有oldHostMap有，也就是server端没有的instance</span></span><br><span class="line">            Set&lt;Instance&gt; remvHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line">            <span class="comment">// 遍历来自server的</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, Instance&gt;&gt; newServiceHosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Instance&gt;&gt;(</span><br><span class="line">                    newHostMap.entrySet());</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : newServiceHosts) &#123;</span><br><span class="line">                <span class="type">Instance</span> <span class="variable">host</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="comment">// 本地注册表中也有这个 ip:port 但是两个instance不同，就放入modMap</span></span><br><span class="line">                <span class="keyword">if</span> (oldHostMap.containsKey(key) &amp;&amp; !StringUtils</span><br><span class="line">                        .equals(host.toString(), oldHostMap.get(key).toString())) &#123;</span><br><span class="line">                    modHosts.add(host);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注册表中不存在这个ip:prot 那就写入到newMap 说明这个主机是新增的</span></span><br><span class="line">                <span class="keyword">if</span> (!oldHostMap.containsKey(key)) &#123;</span><br><span class="line">                    newHosts.add(host);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历本地注册表中服务的instane</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : oldHostMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">Instance</span> <span class="variable">host</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (newHostMap.containsKey(key)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注册表中存在  但是来自server的serviceInfo不存在</span></span><br><span class="line">                <span class="keyword">if</span> (!newHostMap.containsKey(key)) &#123;</span><br><span class="line"><span class="comment">// 加入到remvMap</span></span><br><span class="line">                    remvHosts.add(host);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增了 log</span></span><br><span class="line">            <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;new ips(&quot;</span> + newHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(newHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除了 log</span></span><br><span class="line">            <span class="keyword">if</span> (remvHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;removed ips(&quot;</span> + remvHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(remvHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发生变更了 </span></span><br><span class="line">            <span class="keyword">if</span> (modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 变更心跳 instance改了 心跳也要改才行</span></span><br><span class="line">                updateBeatInfo(modHosts);</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;modified ips(&quot;</span> + modHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(modHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            serviceInfo.setJsonFromServer(json);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span> || remvHosts.size() &gt; <span class="number">0</span> || modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 只要发生了变更，就把发生变更的serviceInfo记录到缓存队列中</span></span><br><span class="line">                NotifyCenter.publishEvent(<span class="keyword">new</span> <span class="title class_">InstancesChangeEvent</span>(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                        serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">                DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果本地注册表中没有本服务直接写入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;init new ips(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line"><span class="comment">// 将来自server的serviceInfo记录到注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">            NotifyCenter.publishEvent(<span class="keyword">new</span> <span class="title class_">InstancesChangeEvent</span>(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                    serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">           </span><br><span class="line">  serviceInfo.setJsonFromServer(json);</span><br><span class="line">            DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        MetricsMonitor.getServiceInfoMapSizeMonitor().set(serviceInfoMap.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;current ips:(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们把视线回到上面的  scheduleUpdateIfAbsent(serviceName, clusters);这是一个定时更新本地数据的任务，我们进入方法内部，主要的工作就是创建一个异步对象放入map中，注意这里是DCL，然后启动任务。要想知道这个异步任务到底是做什么的，必须看一下UpdateTask这个类的run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleUpdateIfAbsent</span><span class="params">(String serviceName, String clusters)</span> &#123;</span><br><span class="line"><span class="comment">// 这是个缓存map key为groupid@@微服务名@@cluster</span></span><br><span class="line"><span class="comment">// value 是个定时异步操作对象 </span></span><br><span class="line"><span class="comment">// private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; futureMap = new HashMap&lt;String, ScheduledFuture&lt;?&gt;&gt;();</span></span><br><span class="line"><span class="comment">// 如果有这个异步对象 就返回</span></span><br><span class="line"><span class="comment">// 这种结构称为DCL 防止并发情况下重复写入</span></span><br><span class="line">        <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (futureMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个定时异步对象</span></span><br><span class="line">            ScheduledFuture&lt;?&gt; future = addTask(<span class="keyword">new</span> <span class="title class_">UpdateTask</span>(serviceName, clusters));</span><br><span class="line"><span class="comment">// 把这个定时异步任务放入缓存map</span></span><br><span class="line">            futureMap.put(ServiceInfo.getKey(serviceName, clusters), future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>run方法的分析如下，就是更新注册表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delayTime</span> <span class="operator">=</span> DEFAULT_DELAY;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 在本地注册表获取当前服务</span></span><br><span class="line">                <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (serviceObj == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 本地不存在这个服务，从server拉取并更新到本地</span></span><br><span class="line">                    updateService(serviceName, clusters);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理本地注册表粗存在当前服务的情况</span></span><br><span class="line"><span class="comment">// lastRefTime 当前instanc最后被访问的时间</span></span><br><span class="line">                <span class="comment">// serviceObj.getLastRefTime() 当前服务最后被访问的时间 来源于这个服务里面的所有</span></span><br><span class="line">                <span class="comment">// 实例中最晚被访问的时间</span></span><br><span class="line">                <span class="keyword">if</span> (serviceObj.getLastRefTime() &lt;= lastRefTime) &#123;</span><br><span class="line">                    <span class="comment">//  当前注册表需要更新了</span></span><br><span class="line">                    updateService(serviceName, clusters);</span><br><span class="line">                    serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// if serviceName already updated by push, we should not override it</span></span><br><span class="line">                    <span class="comment">// since the push data may be different from pull through force push</span></span><br><span class="line">                    refreshOnly(serviceName, clusters);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将来自注册表的这个最后访问时间更新到当前client缓存中</span></span><br><span class="line">                lastRefTime = serviceObj.getLastRefTime();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!notifier.isSubscribed(serviceName, clusters) &amp;&amp; !futureMap</span><br><span class="line">                        .containsKey(ServiceInfo.getKey(serviceName, clusters))) &#123;</span><br><span class="line">                    <span class="comment">// abort the update task</span></span><br><span class="line">                    NAMING_LOGGER.info(<span class="string">&quot;update task is stopped, service:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isEmpty(serviceObj.getHosts())) &#123;</span><br><span class="line">                    incFailCount();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                delayTime = serviceObj.getCacheMillis();</span><br><span class="line">                resetFailCount();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                incFailCount();</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;[NA] failed to update serviceName: &quot;</span> + serviceName, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 开始下一次定时更新任务就好了 循环执行</span></span><br><span class="line">                executor.schedule(<span class="built_in">this</span>, Math.min(delayTime &lt;&lt; failCount, DEFAULT_DELAY * <span class="number">60</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Nacos定时更新本地服务的就是以上流程，我们可以用一张流程图来概括这整个步骤：</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203210117403.png" alt="Nacos Client定时更新本地服务(1)"></p><h4 id="Nacos-Client获取要调用的服务的提供者列表"><a href="#Nacos-Client获取要调用的服务的提供者列表" class="headerlink" title="Nacos Client获取要调用的服务的提供者列表"></a>Nacos Client获取要调用的服务的提供者列表</h4><p>首先说结论，客户端是需要调用的时候才懒加载进来服务提供者信息。客户端是基于Ribbon负载均衡来做的，我们进入Ribbon的配置类，关键点就是这个ZoneAwareLoadBalancer类，这是在调用的时候才会创建的一个配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ILoadBalancer <span class="title function_">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span><br><span class="line"><span class="params">ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span><br><span class="line"><span class="params">IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 只有服务真正发生调用的时候才会创建这个类</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZoneAwareLoadBalancer</span>&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在进入这个ZoneAwareLoadBalancer， 前面都是一些初始化赋值操作，后面的restOfInit(clientConfig)才是配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DynamicServerListLoadBalancer</span><span class="params">(IClientConfig clientConfig, IRule rule, IPing ping,</span></span><br><span class="line"><span class="params">                                         ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span></span><br><span class="line"><span class="params">                                         ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(clientConfig, rule, ping);</span><br><span class="line">        <span class="built_in">this</span>.serverListImpl = serverList;</span><br><span class="line">        <span class="built_in">this</span>.filter = filter;</span><br><span class="line">        <span class="built_in">this</span>.serverListUpdater = serverListUpdater;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AbstractServerListFilter) &#123;</span><br><span class="line">            ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">        &#125;</span><br><span class="line">        restOfInit(clientConfig);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入 restOfInit(clientConfig)，过滤掉不重要东西，然后我们可以观察到 updateListOfServers(); 根据方法名字我们就可以推断出来，这就是一个获取服务提供者列表的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">primeConnection</span> <span class="operator">=</span> <span class="built_in">this</span>.isEnablePrimingConnections();</span><br><span class="line">    <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">    <span class="built_in">this</span>.setEnablePrimingConnections(<span class="literal">false</span>);</span><br><span class="line">    enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">    updateListOfServers();</span><br><span class="line">    <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="built_in">this</span>.getPrimeConnections() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getPrimeConnections()</span><br><span class="line">                .primeConnections(getReachableServers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;</span>, clientConfig.getClientName(), <span class="built_in">this</span>.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进去，发现获取服务列表的是serverListImpl.getUpdatedListOfServers();这里。这其实是loadBlancer接口，里面定义了 获取服务的方法，我们如果要获取服务实例，都是要继承这个接口的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateListOfServers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="literal">null</span>) &#123;</span><br><span class="line">        servers = serverListImpl.getUpdatedListOfServers();</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>,</span><br><span class="line">                getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="literal">null</span>) &#123;</span><br><span class="line">            servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>,</span><br><span class="line">                    getIdentifier(), servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下哪些类实现了这个接口，很明显Nacos也实现了这个方法，那么我们就直接进去看看nacos具体如何做的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203211156633.png" alt="image-20220321115627566"></p><p>进入Nacos实现的这个方法内部，可以看到关键方法就是根据服务ID获取服务实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;NacosServer&gt; <span class="title function_">getServers</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> discoveryProperties.getGroup();</span><br><span class="line">            <span class="comment">// 根据服务ID获取服务实例</span></span><br><span class="line">List&lt;Instance&gt; instances = discoveryProperties.namingServiceInstance()</span><br><span class="line">.selectInstances(serviceId, group, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> instancesToServerList(instances);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;Can not get service instances from nacos, serviceId=&quot;</span> + serviceId,</span><br><span class="line">e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入方法内部，做的事情就是获取订阅的服务，然后根据返回的instance过滤出来可用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, String groupName, List&lt;String&gt; clusters, <span class="type">boolean</span> healthy,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> subscribe)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">       </span><br><span class="line">       ServiceInfo serviceInfo;</span><br><span class="line">       <span class="keyword">if</span> (subscribe) &#123;</span><br><span class="line">           <span class="comment">// 获取到要调用服务的serviceinfo</span></span><br><span class="line">           serviceInfo = hostReactor.getServiceInfo(NamingUtils.getGroupedName(serviceName, groupName),</span><br><span class="line">                   StringUtils.join(clusters, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           serviceInfo = hostReactor</span><br><span class="line">                   .getServiceInfoDirectlyFromServer(NamingUtils.getGroupedName(serviceName, groupName),</span><br><span class="line">                           StringUtils.join(clusters, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从所有服务列表中过滤出来可用的</span></span><br><span class="line">       <span class="keyword">return</span> selectInstances(serviceInfo, healthy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后进入具体的获取方法，我们之前已经解读过了，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.debug(<span class="string">&quot;failover-mode: &quot;</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line"><span class="comment">// 构建key 请求格式为 groupId@@微服务ID@@cluster名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">        <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">            <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从当前client本地注册表中获取当前服务 本地注册表是个map </span></span><br><span class="line"><span class="comment">// key -&gt; groupId@@微服务ID@@cluster名称 value -&gt; serviceinfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="comment">// 如果为空 （第一次启动肯定是空的）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == serviceObj) &#123;</span><br><span class="line"><span class="comment">// 创建个空的服务 没有任何提供者实例</span></span><br><span class="line">            serviceObj = <span class="keyword">new</span> <span class="title class_">ServiceInfo</span>(serviceName, clusters);</span><br><span class="line">            <span class="comment">// 放入注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line">            <span class="comment">// 临时缓存 主要是使用这个缓存的key 不能重复 </span></span><br><span class="line"><span class="comment">// 只要服务名称出现在这个缓存map中，就表示这个服务正在被更新</span></span><br><span class="line">            updatingMap.put(serviceName, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"><span class="comment">// 开始更新服务</span></span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line"><span class="comment">// 更新完了 删掉</span></span><br><span class="line">            updatingMap.remove(serviceName);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line"><span class="comment">// 如果注册表中有了这个服务 而且临时缓存中有了这个服务</span></span><br><span class="line">            <span class="comment">// 那这个服务就是正在被更新 那就等一会儿</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATE_HOLD_INTERVAL &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// hold a moment waiting for update finish</span></span><br><span class="line">                <span class="keyword">synchronized</span> (serviceObj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serviceObj.wait(UPDATE_HOLD_INTERVAL);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        NAMING_LOGGER</span><br><span class="line">                                .error(<span class="string">&quot;[getServiceInfo] serviceName:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定时任务启动 定时更新本地注册表中的当前服务</span></span><br><span class="line">        scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们看一下过来出来可用服务是如何做的，一句话就是过滤不健康的不可用的权重小于0的服务，返回正常的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(ServiceInfo serviceInfo, <span class="type">boolean</span> healthy)</span> &#123;</span><br><span class="line">    List&lt;Instance&gt; list;</span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="literal">null</span> || CollectionUtils.isEmpty(list = serviceInfo.getHosts())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Instance&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代这个服务的所有instance</span></span><br><span class="line">    Iterator&lt;Instance&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="comment">// 服务非健康的 非可用 权重&lt;=0，从列表中去除</span></span><br><span class="line">        <span class="keyword">if</span> (healthy != instance.isHealthy() || !instance.isEnabled() || instance.getWeight() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回可用instance列表</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nacos-Server源码分析"><a href="#Nacos-Server源码分析" class="headerlink" title="Nacos Server源码分析"></a>Nacos Server源码分析</h3><h4 id="重要API介绍"><a href="#重要API介绍" class="headerlink" title="重要API介绍"></a>重要API介绍</h4><ol><li><p>InstanceController 处理客户端请求例如订阅 心跳</p></li><li><p>Service 代表了一个服务 （Service of Nacos server side） 引入了一个Service Cluster Instance模型，也就是一个实例集合，类似客户端的ServiceInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3470985546826874460L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * protect threshold.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 保护阈值 默认是0.8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">protectThreshold</span> <span class="operator">=</span> <span class="number">0.0F</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * application name of this service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group to classify services into different sets.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>RecordListener 数据监听接口 实现了这个接口Service就是一个监听器 范型指定正在监听的数据类型 Record instance也是继承了这个，所以 RecordListener 监听的各个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecordListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Record</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the listener was registered with this key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key candidate key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the listener was registered with this key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 判断监听器是否监听了这个key</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">interests</span><span class="params">(String key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the listener is to be removed by matching the &#x27;key&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if match success</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 判断监听器是否已经移除了这个key</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matchUnlistenKey</span><span class="params">(String key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Action to do if data of target key has changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   target key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value data of the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// key变化触发这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(String key, T value)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Action to do if data of target key has been removed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key target key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 指定key的数据被删除 触发这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDelete</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Record Nacos集群中传递的记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Record</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get the checksum of this record, usually for record comparison.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> checksum of record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getChecksum</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ServiceManager 是RecordListener<Intance>的实现类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceManager</span> <span class="keyword">implements</span> <span class="title class_">RecordListener</span>&lt;Service&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map(namespace, Map(group::serviceName, Service)).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 就是注册表了 外层是namespace 内层map key-&gt;serviceId value-&gt;service对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 来自于其他nacos变更数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingDeque&lt;ServiceKey&gt; toBeUpdatedServicesQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 同步器 service状态同步器 nacos集群同步用的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Synchronizer</span> <span class="variable">synchronizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceStatusSynchronizer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 一致性服务 基于raft数据同步的</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;consistencyDelegate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ConsistencyService consistencyService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SwitchDomain switchDomain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DistroMapper distroMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerMemberManager memberManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PushService pushService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RaftPeerSet raftPeerSet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxFinalizeCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">putServiceLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.auto-clean:false&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> emptyServiceAutoClean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.clean.initial-delay-ms:60000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cleanEmptyServiceDelay;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.clean.period-time-ms:20000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cleanEmptyServicePeriod;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Cluster 集群的实现，里面有两个集合为临时实例集合和持久实例集合，然后它属于一个Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cluster</span> <span class="keyword">extends</span> <span class="title class_">com</span>.alibaba.nacos.api.naming.pojo.Cluster <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLUSTER_NAME_SYNTAX</span> <span class="operator">=</span> <span class="string">&quot;[0-9a-zA-Z-]+&quot;</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8940123791150907510L</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * a addition for same site routing, can group multiple sites into a region, like Hangzhou, Shanghai, etc.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sitegroup</span> <span class="operator">=</span> StringUtils.EMPTY;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">defCkport</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">defIpPort</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> HealthCheckTask checkTask;</span><br><span class="line"><span class="comment">// 持久实例集合</span></span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Set&lt;Instance&gt; persistentInstances = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 临时实例集合</span></span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Set&lt;Instance&gt; ephemeralInstances = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Service service;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">inited</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>Instance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instance</span> <span class="keyword">extends</span> <span class="title class_">com</span>.alibaba.nacos.api.naming.pojo.Instance <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MAX_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">10000.0D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MIN_POSITIVE_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">0.01D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MIN_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">0.00D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6527721638428975306L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastBeat</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JsonIgnore</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">mockValid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 不健康状态的标记 为true的时候就表示实例为不健康 当前实例被标记</span></span><br><span class="line">    <span class="comment">// 对于临时实例，永久为false 即该属性对临时实例没有意义</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String tenant;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String app;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ONLY_DIGIT_AND_DOT</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d|\\.)+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLITER</span> <span class="operator">=</span> <span class="string">&quot;_&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Server-处理client注册请求"><a href="#Server-处理client注册请求" class="headerlink" title="Server 处理client注册请求"></a>Server 处理client注册请求</h4><p>InstanceController就是处理和实例相关的信息，我们定位到这个类直接根据方法名找到对应方法就可以阅读源码了。直接定为到register方法，这里就是处理client注册请求的地方。具体做的事情：</p><ol><li>解析参数</li><li>通过请求参数组装instance</li><li>把instance写入注册表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@CanDistro</span></span><br><span class="line"> <span class="meta">@PostMapping</span></span><br><span class="line"> <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">final</span> <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils</span><br><span class="line">             .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">     <span class="comment">// 请求中不包含servicname 报错</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line"><span class="comment">// 合法检验</span></span><br><span class="line">     NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">     <span class="comment">// 通过请求参数组装instance</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> parseInstance(request);</span><br><span class="line">     <span class="comment">// 把instance写入注册表</span></span><br><span class="line">     serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们先来看如何通过请求参数组装一个instance，其实还是在加工上层方法传递过来的请求属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Instance <span class="title function_">parseInstance</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">        <span class="type">String</span> <span class="variable">app</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;app&quot;</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过请求中的各种属性值构建一个instance</span></span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getIpAddress(request);</span><br><span class="line">        instance.setApp(app);</span><br><span class="line">        instance.setServiceName(serviceName);</span><br><span class="line">        <span class="comment">// Generate simple instance id first. This value would be updated according to</span></span><br><span class="line">        <span class="comment">// INSTANCE_ID_GENERATOR.</span></span><br><span class="line">        instance.setInstanceId(instance.generateInstanceId());</span><br><span class="line">        instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line">        <span class="type">String</span> <span class="variable">metadata</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;metadata&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(metadata)) &#123;</span><br><span class="line">            instance.setMetadata(UtilsAndCommons.parseMetadata(metadata));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// instance验证合法检验 具体就是IP是否合法 权重是否为有效范围内</span></span><br><span class="line">        instance.validate();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看到底是怎么把instance注册到注册表中，这里是ServiceManager来管理的，上面提到这个类就是专门来管理服务注册之类的事情，进入registerInstance方法中，看它是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 如果没有service 就创建一个service 然后配置一些信息放入注册表 </span></span><br><span class="line">        createEmptyService(namespaceId, serviceName, instance.isEphemeral());</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM,</span><br><span class="line">                    <span class="string">&quot;service not found, namespace: &quot;</span> + namespaceId + <span class="string">&quot;, service: &quot;</span> + serviceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把instance写入到service</span></span><br><span class="line">        addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先看 createEmptyService(namespaceId, serviceName, instance.isEphemeral())，他最终调用的是createServiceIfAbsent方法，进入这个方法内部看看，其实就是如果在注册表中获取不到service，就创建一个，然后进行赋值，前面的其实都很清楚，关键是要看看 putServiceAndInit(service);是做了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createServiceIfAbsent</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> local, Cluster cluster)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 拿到一个service 如果没有就new 一个</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Loggers.SRV_LOG.info(<span class="string">&quot;creating empty service &#123;&#125;:&#123;&#125;&quot;</span>, namespaceId, serviceName);</span><br><span class="line">            service = <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">            <span class="comment">// 属性赋值</span></span><br><span class="line">            service.setName(serviceName);</span><br><span class="line">            service.setNamespaceId(namespaceId);</span><br><span class="line">            service.setGroupName(NamingUtils.getGroupName(serviceName));</span><br><span class="line">            <span class="comment">// now validate the service. if failed, exception will be thrown</span></span><br><span class="line">            service.setLastModifiedMillis(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">// 重新计算校验和</span></span><br><span class="line">            service.recalculateChecksum();</span><br><span class="line">            <span class="keyword">if</span> (cluster != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 和cluster建立联系</span></span><br><span class="line">                cluster.setService(service);</span><br><span class="line">                service.getClusterMap().put(cluster.getName(), cluster);</span><br><span class="line">            &#125;</span><br><span class="line">            service.validate();</span><br><span class="line">            <span class="comment">// 做了一些初始化</span></span><br><span class="line">            putServiceAndInit(service);</span><br><span class="line">            <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">                <span class="comment">// 对持久化服务加一个同步任务</span></span><br><span class="line">                addOrReplaceService(service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来到 putServiceAndInit(service);方法内部，做的事情就是写入注册表，开始心跳检测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putServiceAndInit</span><span class="params">(Service service)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">       <span class="comment">// 把service写入注册表 DCL写法 </span></span><br><span class="line">       putService(service);</span><br><span class="line">       service = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">       <span class="comment">// 内部健康检测任务 定期清除过期instance 当前service所有的cluster所有的健康检查任务开启</span></span><br><span class="line">       service.init();</span><br><span class="line">    <span class="comment">// 给nacos的持久实例 临时实例添加监听</span></span><br><span class="line">       consistencyService</span><br><span class="line">               .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="literal">true</span>), service);</span><br><span class="line">       consistencyService</span><br><span class="line">               .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="literal">false</span>), service);</span><br><span class="line">       Loggers.SRV_LOG.info(<span class="string">&quot;[NEW-SERVICE] &#123;&#125;&quot;</span>, service.toJson());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>至此，createEmptyService(namespaceId, serviceName, instance.isEphemeral());方法说完了，然后开始第二步把instance写入到service，也就是addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);方法。进入这个方法内部，做的事情就是修改service的instance列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// ephemeral 默认是true 是否为临时实例 -&gt; 实例是否持久化 -&gt; AP or CP</span></span><br><span class="line">        <span class="comment">//com.alibaba.nacos.naming.ephemeral.namespaceId##serviceName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">        <span class="comment">// 从注册表获取service</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"><span class="comment">// 将要注册的instance写入到service中 也就是写入到注册表</span></span><br><span class="line">        <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">            <span class="comment">// 修改当前service的instance列表，这个修改是两者，一是添加二是删除</span></span><br><span class="line">            List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">            <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line">            instances.setInstanceList(instanceList);</span><br><span class="line">            consistencyService.put(key, instances);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入addIpAddresses(service, ephemeral, ips)方法，看看更新service的instance列表是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">updateIpAddresses</span><span class="params">(Service service, String action, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">// 从其他nacos获取当前服务数据 临时实例</span></span><br><span class="line">        <span class="type">Datum</span> <span class="variable">datum</span> <span class="operator">=</span> consistencyService</span><br><span class="line">                .get(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), ephemeral));</span><br><span class="line"><span class="comment">// 获取本地注册表中当前服务的所有临时实例</span></span><br><span class="line">        List&lt;Instance&gt; currentIPs = service.allIPs(ephemeral);</span><br><span class="line">        Map&lt;String, Instance&gt; currentInstances = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(currentIPs.size());</span><br><span class="line">        Set&lt;String&gt; currentInstanceIds = Sets.newHashSet();</span><br><span class="line"><span class="comment">// 遍历注册表中所有实例 </span></span><br><span class="line">        <span class="keyword">for</span> (Instance instance : currentIPs) &#123;</span><br><span class="line">            <span class="comment">// ip:port -&gt; instance 写入到map中</span></span><br><span class="line">            currentInstances.put(instance.toIpAddr(), instance);</span><br><span class="line">            <span class="comment">// 把实例id写入到set中</span></span><br><span class="line">            currentInstanceIds.add(instance.getInstanceId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Instance&gt; instanceMap;</span><br><span class="line">    <span class="comment">// 外来的数据不为空</span></span><br><span class="line">        <span class="keyword">if</span> (datum != <span class="literal">null</span> &amp;&amp; <span class="literal">null</span> != datum.value) &#123;</span><br><span class="line">            <span class="comment">// 参数为外来的instances 和 本地currentInstances map</span></span><br><span class="line">            <span class="comment">// 做的事情大概就是把本地map的instance数据替换掉外来数据中相同主机（ip+port）的instance数据</span></span><br><span class="line">            instanceMap = setValid(((Instances) datum.value).getInstanceList(), currentInstances);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            instanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(ips.length);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 遍历注册的实例</span></span><br><span class="line">        <span class="keyword">for</span> (Instance instance : ips) &#123;</span><br><span class="line">            <span class="comment">// 如果当前service不包含这个instance的cluster那就创建一个</span></span><br><span class="line">            <span class="keyword">if</span> (!service.getClusterMap().containsKey(instance.getClusterName())) &#123;</span><br><span class="line">                <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cluster</span>(instance.getClusterName(), service);</span><br><span class="line">                <span class="comment">// cluster初始化的健康检测任务</span></span><br><span class="line">                cluster.init();</span><br><span class="line">                service.getClusterMap().put(instance.getClusterName(), cluster);</span><br><span class="line">                Loggers.SRV_LOG</span><br><span class="line">                        .warn(<span class="string">&quot;cluster: &#123;&#125; not found, ip: &#123;&#125;, will create new cluster with default configuration.&quot;</span>,</span><br><span class="line">                                instance.getClusterName(), instance.toJson());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 是删除操作吗？</span></span><br><span class="line">            <span class="keyword">if</span> (UtilsAndCommons.UPDATE_INSTANCE_ACTION_REMOVE.equals(action)) &#123;</span><br><span class="line">                instanceMap.remove(instance.getDatumKey());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 添加操作 </span></span><br><span class="line">                <span class="comment">// 把当前instance添加到外来的和本地数据综合之后的map中 也就是最新数据</span></span><br><span class="line">                <span class="type">Instance</span> <span class="variable">oldInstance</span> <span class="operator">=</span> instanceMap.get(instance.getDatumKey());</span><br><span class="line">                <span class="keyword">if</span> (oldInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance.setInstanceId(oldInstance.getInstanceId());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    instance.setInstanceId(instance.generateInstanceId(currentInstanceIds));</span><br><span class="line">                &#125;</span><br><span class="line">                instanceMap.put(instance.getDatumKey(), instance);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instanceMap.size() &lt;= <span class="number">0</span> &amp;&amp; UtilsAndCommons.UPDATE_INSTANCE_ACTION_ADD.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;ip list can not be empty, service: &quot;</span> + service.getName() + <span class="string">&quot;, ip list: &quot;</span> + JacksonUtils</span><br><span class="line">                            .toJson(instanceMap.values()));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 返回 最新数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(instanceMap.values());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到addInstance()方法，然后看最后两步，经过上面操作，我们获得了含有本地service信息，其他nacos服务传递过来的service信息合并后的最新的instance，再加上我们注册的instance的一个List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// ephemeral 默认是true 是否为临时实例 -&gt; 实例是否持久化 -&gt; AP or CP</span></span><br><span class="line">        <span class="comment">//com.alibaba.nacos.naming.ephemeral.namespaceId##serviceName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">        <span class="comment">// 从注册表获取service</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"><span class="comment">// 将要注册的instance写入到service中 也就是写入到注册表</span></span><br><span class="line">        <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">            <span class="comment">// 修改当前service的instance列表，这个修改是两者，一是添加二是删除</span></span><br><span class="line">            List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">            <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line">            <span class="comment">// 获取到最新的数据</span></span><br><span class="line">            instances.setInstanceList(instanceList);</span><br><span class="line">            <span class="comment">// 同步服务，同步这个数据到其他nacos服务器</span></span><br><span class="line">            consistencyService.put(key, instances);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="开启Service健康检测定时任务"><a href="#开启Service健康检测定时任务" class="headerlink" title="开启Service健康检测定时任务"></a>开启Service健康检测定时任务</h4><p>来到 putServiceAndInit(service);方法内部，上面已经分析如何写入到注册表，现在开始看如何心跳检测。进入putServiceAndInit(service)内部的service.init()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 开始定时清除过期instance</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line">    <span class="comment">// 遍历service的cluster</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">        entry.getValue().setService(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 开启每个cluster的健康检测</span></span><br><span class="line">        entry.getValue().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>看一下心跳检测是怎么做的，一句话就是5S检测一次，15S没发送心跳就把实例状态改为不健康，30S没收到就摘除这个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">scheduleCheck</span><span class="params">(ClientBeatCheckTask task)</span> &#123;</span><br><span class="line">       futureMap.computeIfAbsent(task.taskKey(),</span><br><span class="line">               <span class="comment">// 也就是5S检测一次</span></span><br><span class="line">               k -&gt; GlobalExecutor.scheduleNamingHealth(task, <span class="number">5000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 心跳检测的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 集群心跳任务检测，根据服务名取模到一个区间 就是一个服务 多个实例只有一个机器执行心跳检测</span></span><br><span class="line">           <span class="keyword">if</span> (!getDistroMapper().responsible(service.getName())) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 没开启健康检测就退出</span></span><br><span class="line">           <span class="keyword">if</span> (!getSwitchDomain().isHealthCheckEnabled()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 这个服务所有临时实例</span></span><br><span class="line">           List&lt;Instance&gt; instances = service.allIPs(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// first set health status of instances:</span></span><br><span class="line">           <span class="comment">// 超过15S就过期</span></span><br><span class="line">           <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">               <span class="comment">// 当前时间 - 实例上次心跳 &gt; 15秒</span></span><br><span class="line">               <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) &#123;</span><br><span class="line">                  <span class="comment">// mark标记是持久实例 如果instance是临时实例</span></span><br><span class="line">                   <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (instance.isHealthy()) &#123;</span><br><span class="line">                           <span class="comment">// 实例健康状态 -&gt; false</span></span><br><span class="line">                           instance.setHealthy(<span class="literal">false</span>);</span><br><span class="line">                           Loggers.EVT_LOG</span><br><span class="line">                                   .info(<span class="string">&quot;&#123;POS&#125; &#123;IP-DISABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client timeout after &#123;&#125;, last beat: &#123;&#125;&quot;</span>,</span><br><span class="line">                                           instance.getIp(), instance.getPort(), instance.getClusterName(),</span><br><span class="line">                                           service.getName(), UtilsAndCommons.LOCALHOST_SITE,</span><br><span class="line">                                           instance.getInstanceHeartBeatTimeOut(), instance.getLastBeat());</span><br><span class="line">                           <span class="comment">// 发布状态变更事件</span></span><br><span class="line">                           getPushService().serviceChanged(service);</span><br><span class="line">                           ApplicationUtils.publishEvent(<span class="keyword">new</span> <span class="title class_">InstanceHeartbeatTimeoutEvent</span>(<span class="built_in">this</span>, instance));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!getGlobalConfig().isExpireInstance()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// then remove obsolete instances:</span></span><br><span class="line">           <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line"><span class="comment">// 临时实例</span></span><br><span class="line">               <span class="keyword">if</span> (instance.isMarked()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果超过30S了 直接吧这个机器删掉</span></span><br><span class="line">               <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getIpDeleteTimeout()) &#123;</span><br><span class="line">                   <span class="comment">// delete instance</span></span><br><span class="line">                   Loggers.SRV_LOG.info(<span class="string">&quot;[AUTO-DELETE-IP] service: &#123;&#125;, ip: &#123;&#125;&quot;</span>, service.getName(),</span><br><span class="line">                           JacksonUtils.toJson(instance));</span><br><span class="line">                   <span class="comment">// 删除实例 这是不是删除的server的注册表</span></span><br><span class="line">                   deleteIp(instance);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;Exception while processing client beat time out.&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里的deleteIp(instance)是个异步，通过向nacos server发送一个请求，然后再做的删除，请求的就是InstanceController。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteIp</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            NamingProxy.<span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> NamingProxy.Request.newRequest();</span><br><span class="line">            request.appendParam(<span class="string">&quot;ip&quot;</span>, instance.getIp()).appendParam(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()))</span><br><span class="line">                    .appendParam(<span class="string">&quot;ephemeral&quot;</span>, <span class="string">&quot;true&quot;</span>).appendParam(<span class="string">&quot;clusterName&quot;</span>, instance.getClusterName())</span><br><span class="line">                    .appendParam(<span class="string">&quot;serviceName&quot;</span>, service.getName()).appendParam(<span class="string">&quot;namespaceId&quot;</span>, service.getNamespaceId());</span><br><span class="line">            <span class="comment">// 自己请求自己，发送Delete请求，删除实例</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://&quot;</span> + IPUtil.localHostIP() + IPUtil.IP_PORT_SPLITER + EnvUtil.getPort() + EnvUtil.getContextPath()</span><br><span class="line">                    + UtilsAndCommons.NACOS_NAMING_CONTEXT + <span class="string">&quot;/instance?&quot;</span> + request.toUrl();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// delete instance asynchronously:</span></span><br><span class="line">            HttpClient.asyncHttpDelete(url, <span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(RestResult&lt;String&gt; result)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!result.ok()) &#123;</span><br><span class="line">                        Loggers.SRV_LOG</span><br><span class="line">                                .error(<span class="string">&quot;[IP-DEAD] failed to delete ip automatically, ip: &#123;&#125;, caused &#123;&#125;, resp code: &#123;&#125;&quot;</span>,</span><br><span class="line">                                        instance.toJson(), result.getMessage(), result.getCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                    Loggers.SRV_LOG</span><br><span class="line">                            .error(<span class="string">&quot;[IP-DEAD] failed to delete ip automatically, ip: &#123;&#125;, error: &#123;&#125;&quot;</span>, instance.toJson(),</span><br><span class="line">                                    throwable);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancel</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.SRV_LOG</span><br><span class="line">                    .error(<span class="string">&quot;[IP-DEAD] failed to delete ip automatically, ip: &#123;&#125;, error: &#123;&#125;&quot;</span>, instance.toJson(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="开启Cluster的健康检测定时任务"><a href="#开启Cluster的健康检测定时任务" class="headerlink" title="开启Cluster的健康检测定时任务"></a>开启Cluster的健康检测定时任务</h4><p>service的健康检测我们已经了解了，现在开始看cluster的健康检测，直接进入cluster.init()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init cluster.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经初始化过了 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (inited) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个健康检查任务</span></span><br><span class="line">    checkTask = <span class="keyword">new</span> <span class="title class_">HealthCheckTask</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 开启定时任务</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(checkTask);</span><br><span class="line">    inited = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看一下HealthCheckTask的run()方法，还是一样的套路，在结束之前再重新开启一个任务。具体的任务是在healthCheckProcessor.process(this);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (distroMapper.responsible(cluster.getService().getName()) &amp;&amp; switchDomain</span><br><span class="line">                .isHealthCheckEnabled(cluster.getService().getName())) &#123;</span><br><span class="line">            <span class="comment">// 健康检查处理器处理</span></span><br><span class="line">            healthCheckProcessor.process(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                Loggers.EVT_LOG</span><br><span class="line">                        .debug(<span class="string">&quot;[HEALTH-CHECK] schedule health check task: &#123;&#125;&quot;</span>, cluster.getService().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Loggers.SRV_LOG</span><br><span class="line">                .error(<span class="string">&quot;[HEALTH-CHECK] error while process health check for &#123;&#125;:&#123;&#125;&quot;</span>, cluster.getService().getName(),</span><br><span class="line">                        cluster.getName(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cancelled) &#123;</span><br><span class="line">            <span class="comment">// 重复执行</span></span><br><span class="line">            HealthCheckReactor.scheduleCheck(<span class="built_in">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// worst == 0 means never checked</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getCheckRtWorst() &gt; <span class="number">0</span> &amp;&amp; switchDomain.isHealthCheckEnabled(cluster.getService().getName())</span><br><span class="line">                    &amp;&amp; distroMapper.responsible(cluster.getService().getName())) &#123;</span><br><span class="line">                <span class="comment">// TLog doesn&#x27;t support float so we must convert it into long</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span></span><br><span class="line">                        ((<span class="built_in">this</span>.getCheckRtLast() - <span class="built_in">this</span>.getCheckRtLastLast()) * <span class="number">10000</span>) / <span class="built_in">this</span>.getCheckRtLastLast();</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">this</span>.setCheckRtLastLast(<span class="built_in">this</span>.getCheckRtLast());</span><br><span class="line">                </span><br><span class="line">                <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> <span class="built_in">this</span>.getCluster();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (Loggers.CHECK_RT.isDebugEnabled()) &#123;</span><br><span class="line">                    Loggers.CHECK_RT.debug(<span class="string">&quot;&#123;&#125;:&#123;&#125;@&#123;&#125;-&gt;normalized: &#123;&#125;, worst: &#123;&#125;, best: &#123;&#125;, last: &#123;&#125;, diff: &#123;&#125;&quot;</span>,</span><br><span class="line">                            cluster.getService().getName(), cluster.getName(), cluster.getHealthChecker().getType(),</span><br><span class="line">                            <span class="built_in">this</span>.getCheckRtNormalized(), <span class="built_in">this</span>.getCheckRtWorst(), <span class="built_in">this</span>.getCheckRtBest(),</span><br><span class="line">                            <span class="built_in">this</span>.getCheckRtLast(), diff);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>healthCheckProcessor.process(this)，这是一个接口的实现类里面的处理方法，这个接口有很多实现类。我们这里用到的是最后一个，所以来看这个方法是什么样的。就是拿出来所有的持久而且是健康的实例，然后遍历，根据他们的IP port构建心跳，然后放入队列中，后面会有线程处理队列。这里其实就是对持久实例的健康检测，Server给Client发心跳。那么必须有一个对队列操作的对象。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203221208632.png" alt="image-20220322120835506"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(HealthCheckTask task)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取所有持久实例</span></span><br><span class="line">       List&lt;Instance&gt; ips = task.getCluster().allIPs(<span class="literal">false</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isEmpty(ips)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (Instance ip : ips) &#123;</span><br><span class="line">           <span class="comment">// 过期的就不管</span></span><br><span class="line">           <span class="keyword">if</span> (ip.isMarked()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (SRV_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   SRV_LOG.debug(<span class="string">&quot;tcp check, ip is marked as to skip health check, ip:&quot;</span> + ip.getIp());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (!ip.markChecking()) &#123;</span><br><span class="line">               SRV_LOG.warn(<span class="string">&quot;tcp check started before last one finished, service: &quot;</span> + task.getCluster().getService()</span><br><span class="line">                       .getName() + <span class="string">&quot;:&quot;</span> + task.getCluster().getName() + <span class="string">&quot;:&quot;</span> + ip.getIp() + <span class="string">&quot;:&quot;</span> + ip.getPort());</span><br><span class="line">               </span><br><span class="line">               healthCheckCommon</span><br><span class="line">                       .reEvaluateCheckRT(task.getCheckRtNormalized() * <span class="number">2</span>, task, switchDomain.getTcpHealthParams());</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 生成一个心跳</span></span><br><span class="line">           <span class="type">Beat</span> <span class="variable">beat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Beat</span>(ip, task);</span><br><span class="line">           <span class="comment">// 放入队列中</span></span><br><span class="line">           taskQueue.add(beat);</span><br><span class="line">           MetricsMonitor.getTcpHealthCheckMonitor().incrementAndGet();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后看一下拿到队列了的这个beat是怎么处理的，拿到这个beat然后封装到list里，然后放到线程池里面执行，也就是给客户端发送请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Collection&lt;Callable&lt;Void&gt;&gt; tasks = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Beat</span> <span class="variable">beat</span> <span class="operator">=</span> taskQueue.poll(CONNECT_TIMEOUT_MS / <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">if</span> (beat == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tasks.add(<span class="keyword">new</span> <span class="title class_">TaskProcessor</span>(beat));</span><br><span class="line">    &#125; <span class="keyword">while</span> (taskQueue.size() &gt; <span class="number">0</span> &amp;&amp; tasks.size() &lt; NIO_THREAD_COUNT * <span class="number">64</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Future&lt;?&gt; f : GlobalExecutor.invokeAllTcpSuperSenseTask(tasks)) &#123;</span><br><span class="line">        f.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Nacos-Server处理注销请求"><a href="#Nacos-Server处理注销请求" class="headerlink" title="Nacos Server处理注销请求"></a>Nacos Server处理注销请求</h4><p>上面提到Service健康检查的时候如果发现实例已经30S没发送心跳，那么我们就会删除这个实例，具体的删除就是向InstanceController发送@Delete请求，那么我们现在就来分析Nacos Server在删除实例的时候具体是怎么做的，首先来到这个Controller的方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line">    <span class="meta">@DeleteMapping</span></span><br><span class="line">    <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deregister</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 前面是根据请求参数构建对象</span></span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getIpAddress(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">        NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;remove instance from non-exist service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除实例</span></span><br><span class="line">        serviceManager.removeInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键信息是在 serviceManager.removeInstance(namespaceId, serviceName, instance.isEphemeral(), instance)，具体来看这个方法是在干嘛，也很简单就是拿到service，对其加锁然后修改。具体还是要看内部的removeInstance方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 从注册表获取当前service</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">            <span class="comment">// 删除Instance实例</span></span><br><span class="line">            removeInstance(namespaceId, serviceName, ephemeral, service, ips);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来到removeInstance方法内部，和之前分析的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Service service,</span></span><br><span class="line"><span class="params">                               Instance... ips)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line"><span class="comment">// 从注册表中删除实例 这里是调用的还是 com.alibaba.nacos.naming.core.ServiceManager#updateIpAddresses</span></span><br><span class="line">       List&lt;Instance&gt; instanceList = substractIpAddresses(service, ephemeral, ips);</span><br><span class="line"></span><br><span class="line">       <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line">       instances.setInstanceList(instanceList);</span><br><span class="line"><span class="comment">// 发生了变更 把本次变更同步给其他nacos节点</span></span><br><span class="line">       consistencyService.put(key, instances);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Server处理心跳请求"><a href="#Server处理心跳请求" class="headerlink" title="Server处理心跳请求"></a>Server处理心跳请求</h4><p>同样的Server处理心跳请求也是在InstanceController，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line">   <span class="meta">@PutMapping(&quot;/beat&quot;)</span></span><br><span class="line">   <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line">   <span class="keyword">public</span> ObjectNode <span class="title function_">beat</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 创建一个Node，返回值就是这个 后面就是围绕这个node的操作</span></span><br><span class="line">       <span class="type">ObjectNode</span> <span class="variable">result</span> <span class="operator">=</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL, switchDomain.getClientBeatInterval());</span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">beat</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;beat&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       <span class="type">RsInfo</span> <span class="variable">clientBeat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(beat)) &#123;</span><br><span class="line">           clientBeat = JacksonUtils.toObj(beat, RsInfo.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> WebUtils</span><br><span class="line">               .optional(request, CommonParams.CLUSTER_NAME, UtilsAndCommons.DEFAULT_CLUSTER_NAME);</span><br><span class="line">       <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;ip&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       <span class="comment">// 获取到客户端传递来的client端口 将来用来UDP通信</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(WebUtils.optional(request, <span class="string">&quot;port&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">       <span class="keyword">if</span> (clientBeat != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotBlank(clientBeat.getCluster())) &#123;</span><br><span class="line">               clusterName = clientBeat.getCluster();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// fix #2533</span></span><br><span class="line">               clientBeat.setCluster(clusterName);</span><br><span class="line">           &#125;</span><br><span class="line">           ip = clientBeat.getIp();</span><br><span class="line">           port = clientBeat.getPort();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">       <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">       NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">       Loggers.SRV_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] full arguments: beat: &#123;&#125;, serviceName: &#123;&#125;&quot;</span>, clientBeat, serviceName);</span><br><span class="line">       <span class="comment">// 获取当前注册表中的发送请求对应的client对应的Instance</span></span><br><span class="line">       <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> serviceManager.getInstance(namespaceId, serviceName, clusterName, ip, port);</span><br><span class="line">       <span class="comment">// 处理注册表中不存在该client的instance的情况</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (clientBeat == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 如果请求中获取到的Beat，即client端的BeatInfo为空 请求中未携带心跳数据</span></span><br><span class="line">               result.put(CommonParams.CODE, NamingResponseCode.RESOURCE_NOT_FOUND);</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;[CLIENT-BEAT] The instance has been removed for health mechanism, &quot;</span></span><br><span class="line">                   + <span class="string">&quot;perform data compensation operations, beat: &#123;&#125;, serviceName: &#123;&#125;&quot;</span>, clientBeat, serviceName);</span><br><span class="line">           <span class="comment">// 注册表中没有这个instance 但是发送的请求中是有心跳信息的</span></span><br><span class="line">           <span class="comment">// 利用心跳信息创建一个</span></span><br><span class="line">           <span class="comment">// 注册请求还没到 心跳先到了 就是这种情况</span></span><br><span class="line">           instance = <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">           instance.setPort(clientBeat.getPort());</span><br><span class="line">           instance.setIp(clientBeat.getIp());</span><br><span class="line">           instance.setWeight(clientBeat.getWeight());</span><br><span class="line">           instance.setMetadata(clientBeat.getMetadata());</span><br><span class="line">           instance.setClusterName(clusterName);</span><br><span class="line">           instance.setServiceName(serviceName);</span><br><span class="line">           instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">           instance.setEphemeral(clientBeat.isEphemeral());</span><br><span class="line">           <span class="comment">// 注册到注册表中</span></span><br><span class="line">           serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.SERVER_ERROR,</span><br><span class="line">                   <span class="string">&quot;service not found: &quot;</span> + serviceName + <span class="string">&quot;@&quot;</span> + namespaceId);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (clientBeat == <span class="literal">null</span>) &#123;</span><br><span class="line">           clientBeat = <span class="keyword">new</span> <span class="title class_">RsInfo</span>();</span><br><span class="line">           clientBeat.setIp(ip);</span><br><span class="line">           clientBeat.setPort(port);</span><br><span class="line">           clientBeat.setCluster(clusterName);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 真正处理心跳</span></span><br><span class="line">       service.processClientBeat(clientBeat);</span><br><span class="line">       </span><br><span class="line">       result.put(CommonParams.CODE, NamingResponseCode.OK);</span><br><span class="line">       <span class="keyword">if</span> (instance.containsMetadata(PreservedMetadataKeys.HEART_BEAT_INTERVAL)) &#123;</span><br><span class="line">           result.put(SwitchEntry.CLIENT_BEAT_INTERVAL, instance.getInstanceHeartBeatInterval());</span><br><span class="line">       &#125;</span><br><span class="line">       result.put(SwitchEntry.LIGHT_BEAT_ENABLED, switchDomain.isLightBeatEnabled());</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入真正处理心跳的方法内部，我们可以看到就是根据service和心跳消息构建一个处理任务，处理任务就是找到对应的的instance更新其最后心跳事件 如果这个实例之前已经是不健康的了，现在心跳来了，那么就更新为健康的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processClientBeat</span><span class="params">(<span class="keyword">final</span> RsInfo rsInfo)</span> &#123;</span><br><span class="line">      <span class="comment">// 这个处理器实现了run方法</span></span><br><span class="line">      <span class="type">ClientBeatProcessor</span> <span class="variable">clientBeatProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientBeatProcessor</span>();</span><br><span class="line">      clientBeatProcessor.setService(<span class="built_in">this</span>);</span><br><span class="line">      clientBeatProcessor.setRsInfo(rsInfo);</span><br><span class="line">      <span class="comment">// 开启一个立即执行的任务 执行任务的run</span></span><br><span class="line">      HealthCheckReactor.scheduleNow(clientBeatProcessor);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 获取到注册表的service</span></span><br><span class="line">      <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="built_in">this</span>.service;</span><br><span class="line">      <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">          Loggers.EVT_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] processing beat: &#123;&#125;&quot;</span>, rsInfo.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从心跳信息中获取一些信息</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> rsInfo.getIp();</span><br><span class="line">      <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> rsInfo.getCluster();</span><br><span class="line">      <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> rsInfo.getPort();</span><br><span class="line">      <span class="comment">// 获取这个service对应的cluster</span></span><br><span class="line">      <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> service.getClusterMap().get(clusterName);</span><br><span class="line">      <span class="comment">// 获取临时实例 因为是客户端发送心跳到server</span></span><br><span class="line">      List&lt;Instance&gt; instances = cluster.allIPs(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 遍历临时实例</span></span><br><span class="line">      <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">          <span class="comment">// 如果这个实例的IP port和当前心跳的instance的相同</span></span><br><span class="line">          <span class="keyword">if</span> (instance.getIp().equals(ip) &amp;&amp; instance.getPort() == port) &#123;</span><br><span class="line">              <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                  Loggers.EVT_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] refresh beat: &#123;&#125;&quot;</span>, rsInfo.toString());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 更新这个实例最新的心跳事件</span></span><br><span class="line">              instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line">              <span class="keyword">if</span> (!instance.isMarked() &amp;&amp; !instance.isHealthy()) &#123;</span><br><span class="line">                  <span class="comment">// 如果不是临时节点 而且之前标记为不健康</span></span><br><span class="line">                  <span class="comment">// 既然心跳都来了，那么就更新为健康的</span></span><br><span class="line">                  instance.setHealthy(<span class="literal">true</span>);</span><br><span class="line">                  Loggers.EVT_LOG</span><br><span class="line">                          .info(<span class="string">&quot;service: &#123;&#125; &#123;POS&#125; &#123;IP-ENABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client beat ok&quot;</span>,</span><br><span class="line">                                  cluster.getService().getName(), ip, port, cluster.getName(),</span><br><span class="line">                                  UtilsAndCommons.LOCALHOST_SITE);</span><br><span class="line">                  <span class="comment">// 发布变更事件 后面分析UDP通知客户端</span></span><br><span class="line">                  getPushService().serviceChanged(service);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Server处理客户端订阅"><a href="#Server处理客户端订阅" class="headerlink" title="Server处理客户端订阅"></a>Server处理客户端订阅</h4><p>客户端订阅服务，服务端的实例变更后，会UDP通知客户端，我们先来到服务订阅接口，获取参数，获取udp端口，然后处理请求，在doSrvIpxt处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">  <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.READ)</span></span><br><span class="line">  <span class="keyword">public</span> ObjectNode <span class="title function_">list</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">      <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">      NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">      <span class="comment">// 用于指定客户端类型 </span></span><br><span class="line">      <span class="type">String</span> <span class="variable">agent</span> <span class="operator">=</span> WebUtils.getUserAgent(request);</span><br><span class="line">      <span class="type">String</span> <span class="variable">clusters</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;clusters&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;clientIP&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      <span class="comment">// UDP端口，用于变更通知 </span></span><br><span class="line">      <span class="type">int</span> <span class="variable">udpPort</span> <span class="operator">=</span> Integer.parseInt(WebUtils.optional(request, <span class="string">&quot;udpPort&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">      <span class="type">String</span> <span class="variable">env</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;env&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isCheck</span> <span class="operator">=</span> Boolean.parseBoolean(WebUtils.optional(request, <span class="string">&quot;isCheck&quot;</span>, <span class="string">&quot;false&quot;</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="type">String</span> <span class="variable">app</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;app&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      </span><br><span class="line">      <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;tid&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      </span><br><span class="line">      <span class="type">boolean</span> <span class="variable">healthyOnly</span> <span class="operator">=</span> Boolean.parseBoolean(WebUtils.optional(request, <span class="string">&quot;healthyOnly&quot;</span>, <span class="string">&quot;false&quot;</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> doSrvIpxt(namespaceId, serviceName, agent, clusters, clientIP, udpPort, env, isCheck, app, tenant,</span><br><span class="line">              healthyOnly);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进入具体的处理方法，先是创建根据agent创建一个UDP Client然后放入map中，后面会根据这个map中client发送UDP请求，然后从注册表中获取所有可用的instance并封装称为json。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get service full information with instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> namespaceId namespace id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName service name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agent       agent infor string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusters    cluster names</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientIP    client ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> udpPort     push udp port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> env         env</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isCheck     is check request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> app         app name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tid         tenant</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> healthyOnly whether only for healthy check</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service full information with instances</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception any error during handle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ObjectNode <span class="title function_">doSrvIpxt</span><span class="params">(String namespaceId, String serviceName, String agent, String clusters, String clientIP,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> udpPort, String env, <span class="type">boolean</span> isCheck, String app, String tid, <span class="type">boolean</span> healthyOnly)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 根据不同的agent生成不同的ClientInfo 比如java agent生成一个java的ClientInfo</span></span><br><span class="line">        <span class="type">ClientInfo</span> <span class="variable">clientInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientInfo</span>(agent);</span><br><span class="line">        <span class="comment">// 这个就是返回的结果 后续代码就是对这个node各种操作</span></span><br><span class="line">        <span class="type">ObjectNode</span> <span class="variable">result</span> <span class="operator">=</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        <span class="comment">// 获取注册表的当前服务</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">        <span class="type">long</span> <span class="variable">cacheMillis</span> <span class="operator">=</span> switchDomain.getDefaultCacheMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// now try to enable the push</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (udpPort &gt; <span class="number">0</span> &amp;&amp; pushService.canEnablePush(agent)) &#123;</span><br><span class="line">                <span class="comment">// 创建当前发出订阅请求的Nacos client的UDP Client并放入缓存map中</span></span><br><span class="line">                <span class="comment">// 在UDP通信当中 Nacos Client充当是UDP Server</span></span><br><span class="line">                pushService</span><br><span class="line">                        .addClient(namespaceId, serviceName, clusters, agent, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(clientIP, udpPort),</span><br><span class="line">                                pushDataSource, tid, app);</span><br><span class="line">                cacheMillis = switchDomain.getPushCacheMillis(serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.SRV_LOG</span><br><span class="line">                    .error(<span class="string">&quot;[NACOS-API] failed to added push client &#123;&#125;, &#123;&#125;:&#123;&#125;&quot;</span>, clientInfo, clientIP, udpPort, e);</span><br><span class="line">            cacheMillis = switchDomain.getDefaultCacheMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果注册表中没有这个服务，则直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Loggers.SRV_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                Loggers.SRV_LOG.debug(<span class="string">&quot;no instance to serve for service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">            result.put(<span class="string">&quot;name&quot;</span>, serviceName);</span><br><span class="line">            result.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">            result.put(<span class="string">&quot;cacheMillis&quot;</span>, cacheMillis);</span><br><span class="line">            result.replace(<span class="string">&quot;hosts&quot;</span>, JacksonUtils.createEmptyArrayNode());</span><br><span class="line">            <span class="keyword">return</span> result; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否可用 如果不可用直接跑出异常</span></span><br><span class="line">        checkIfDisabled(service);</span><br><span class="line">        </span><br><span class="line">        List&lt;Instance&gt; srvedIPs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有可用实例</span></span><br><span class="line">        srvedIPs = service.srvIPs(Arrays.asList(StringUtils.split(clusters, <span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// filter ips using selector:</span></span><br><span class="line">        <span class="comment">// 选择器根据选择算法</span></span><br><span class="line">        <span class="comment">// 如果选择器不空 则根据选择算法选择可用的instance</span></span><br><span class="line">        <span class="keyword">if</span> (service.getSelector() != <span class="literal">null</span> &amp;&amp; StringUtils.isNotBlank(clientIP)) &#123;</span><br><span class="line">            srvedIPs = service.getSelector().select(clientIP, srvedIPs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有可用的instance 返回的Hosts还是为空的 直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(srvedIPs)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (Loggers.SRV_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                Loggers.SRV_LOG.debug(<span class="string">&quot;no instance to serve for service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (clientInfo.type == ClientInfo.ClientType.JAVA</span><br><span class="line">                    &amp;&amp; clientInfo.version.compareTo(VersionUtil.parseVersion(<span class="string">&quot;1.0.0&quot;</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                result.put(<span class="string">&quot;dom&quot;</span>, serviceName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.put(<span class="string">&quot;dom&quot;</span>, NamingUtils.getServiceName(serviceName));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.put(<span class="string">&quot;name&quot;</span>, serviceName);</span><br><span class="line">            result.put(<span class="string">&quot;cacheMillis&quot;</span>, cacheMillis);</span><br><span class="line">            result.put(<span class="string">&quot;lastRefTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">            result.put(<span class="string">&quot;checksum&quot;</span>, service.getChecksum());</span><br><span class="line">            result.put(<span class="string">&quot;useSpecifiedURL&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            result.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">            result.put(<span class="string">&quot;env&quot;</span>, env);</span><br><span class="line">            result.set(<span class="string">&quot;hosts&quot;</span>, JacksonUtils.createEmptyArrayNode());</span><br><span class="line">            result.set(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.transferToJsonNode(service.getMetadata()));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里 说明是有可用的instance</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Instance&gt;&gt; ipMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 放入健康的instance</span></span><br><span class="line">        ipMap.put(Boolean.TRUE, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 放入不健康的instance</span></span><br><span class="line">        ipMap.put(Boolean.FALSE, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 把健康和不健康的实例分开放置在map中</span></span><br><span class="line">        <span class="keyword">for</span> (Instance ip : srvedIPs) &#123;</span><br><span class="line">            ipMap.get(ip.isHealthy()).add(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否需要检测instance的保护阈值 </span></span><br><span class="line">        <span class="keyword">if</span> (isCheck) &#123;</span><br><span class="line">            result.put(<span class="string">&quot;reachProtectThreshold&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取服务的保护阈值</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> service.getProtectThreshold();</span><br><span class="line">        <span class="comment">// 如果健康实例的数量/所有的instance数量 &lt;= 保护阈值 说明要启动保护机制 </span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">float</span>) ipMap.get(Boolean.TRUE).size() / srvedIPs.size() &lt;= threshold) &#123;</span><br><span class="line">            </span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;protect threshold reached, return all ips, service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            <span class="keyword">if</span> (isCheck) &#123;</span><br><span class="line">                result.put(<span class="string">&quot;reachProtectThreshold&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动了保护阈值 那么消费者要调用所有的实例，这也可能导致调用到不可用的实例</span></span><br><span class="line">            <span class="comment">// 这样牺牲了调用者，但是不会吧所有请求都发给可用的实例，防止宕机</span></span><br><span class="line">            ipMap.get(Boolean.TRUE).addAll(ipMap.get(Boolean.FALSE));</span><br><span class="line">            ipMap.get(Boolean.FALSE).clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isCheck) &#123;</span><br><span class="line">            result.put(<span class="string">&quot;protectThreshold&quot;</span>, service.getProtectThreshold());</span><br><span class="line">            result.put(<span class="string">&quot;reachLocalSiteCallThreshold&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ArrayNode</span> <span class="variable">hosts</span> <span class="operator">=</span> JacksonUtils.createEmptyArrayNode();</span><br><span class="line">        <span class="comment">// 这个ipMap放的是所有健康和不健康的实例</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Boolean, List&lt;Instance&gt;&gt; entry : ipMap.entrySet()) &#123;</span><br><span class="line">            List&lt;Instance&gt; ips = entry.getValue();</span><br><span class="line">            <span class="comment">// 如果客户端只有健康的instance且当前遍历的map key为false 则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (healthyOnly &amp;&amp; !entry.getKey()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历的ips 可能是所有不健康的实例列表</span></span><br><span class="line">            <span class="comment">// 可能是所有健康的</span></span><br><span class="line">            <span class="comment">// 也可能是所有的instance列表</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : ips) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// remove disabled instance:</span></span><br><span class="line">                <span class="comment">// 跳过禁用的instance</span></span><br><span class="line">                <span class="keyword">if</span> (!instance.isEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前遍历的instance 转换为json</span></span><br><span class="line">                <span class="type">ObjectNode</span> <span class="variable">ipObj</span> <span class="operator">=</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">                </span><br><span class="line">                ipObj.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">                ipObj.put(<span class="string">&quot;port&quot;</span>, instance.getPort());</span><br><span class="line">                <span class="comment">// deprecated since nacos 1.0.0:</span></span><br><span class="line">                ipObj.put(<span class="string">&quot;valid&quot;</span>, entry.getKey());</span><br><span class="line">                ipObj.put(<span class="string">&quot;healthy&quot;</span>, entry.getKey());</span><br><span class="line">                ipObj.put(<span class="string">&quot;marked&quot;</span>, instance.isMarked());</span><br><span class="line">                ipObj.put(<span class="string">&quot;instanceId&quot;</span>, instance.getInstanceId());</span><br><span class="line">                ipObj.set(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.transferToJsonNode(instance.getMetadata()));</span><br><span class="line">                ipObj.put(<span class="string">&quot;enabled&quot;</span>, instance.isEnabled());</span><br><span class="line">                ipObj.put(<span class="string">&quot;weight&quot;</span>, instance.getWeight());</span><br><span class="line">                ipObj.put(<span class="string">&quot;clusterName&quot;</span>, instance.getClusterName());</span><br><span class="line">                <span class="keyword">if</span> (clientInfo.type == ClientInfo.ClientType.JAVA</span><br><span class="line">                        &amp;&amp; clientInfo.version.compareTo(VersionUtil.parseVersion(<span class="string">&quot;1.0.0&quot;</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ipObj.put(<span class="string">&quot;serviceName&quot;</span>, instance.getServiceName());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ipObj.put(<span class="string">&quot;serviceName&quot;</span>, NamingUtils.getServiceName(instance.getServiceName()));</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ipObj.put(<span class="string">&quot;ephemeral&quot;</span>, instance.isEphemeral());</span><br><span class="line">                <span class="comment">// 添加到hosts中</span></span><br><span class="line">                hosts.add(ipObj);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result.replace(<span class="string">&quot;hosts&quot;</span>, hosts);</span><br><span class="line">        <span class="keyword">if</span> (clientInfo.type == ClientInfo.ClientType.JAVA</span><br><span class="line">                &amp;&amp; clientInfo.version.compareTo(VersionUtil.parseVersion(<span class="string">&quot;1.0.0&quot;</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result.put(<span class="string">&quot;dom&quot;</span>, serviceName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.put(<span class="string">&quot;dom&quot;</span>, NamingUtils.getServiceName(serviceName));</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(<span class="string">&quot;name&quot;</span>, serviceName);</span><br><span class="line">        result.put(<span class="string">&quot;cacheMillis&quot;</span>, cacheMillis);</span><br><span class="line">        result.put(<span class="string">&quot;lastRefTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        result.put(<span class="string">&quot;checksum&quot;</span>, service.getChecksum());</span><br><span class="line">        result.put(<span class="string">&quot;useSpecifiedURL&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        result.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">        result.put(<span class="string">&quot;env&quot;</span>, env);</span><br><span class="line">        result.replace(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.transferToJsonNode(service.getMetadata()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h4 id="Server和Client之间的UDP通信"><a href="#Server和Client之间的UDP通信" class="headerlink" title="Server和Client之间的UDP通信"></a>Server和Client之间的UDP通信</h4><h5 id="服务端发送UDP推送"><a href="#服务端发送UDP推送" class="headerlink" title="服务端发送UDP推送"></a>服务端发送UDP推送</h5><p>我们在心跳请求哪里发现，如果实例的健康状况发生了变化，那么我们要把这个状态的变更通知到订阅者，这是居于Spring事件机制做的，发布这个事件之后会有一个处理器来处理，具体就是封装成UDP报文发送给client，client再发送一个ack。我们先来到修改实例健康状态的代码。进入serviceChanged方法，看看具体是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新这个实例最新的心跳事件</span></span><br><span class="line">instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line"><span class="keyword">if</span> (!instance.isMarked() &amp;&amp; !instance.isHealthy()) &#123;</span><br><span class="line">    <span class="comment">// 如果不是临时节点 而且之前标记为不健康</span></span><br><span class="line">    <span class="comment">// 既然心跳都来了，那么就更新为健康的</span></span><br><span class="line">    instance.setHealthy(<span class="literal">true</span>);</span><br><span class="line">    Loggers.EVT_LOG</span><br><span class="line">        .info(<span class="string">&quot;service: &#123;&#125; &#123;POS&#125; &#123;IP-ENABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client beat ok&quot;</span>,</span><br><span class="line">              cluster.getService().getName(), ip, port, cluster.getName(),</span><br><span class="line">              UtilsAndCommons.LOCALHOST_SITE);</span><br><span class="line">    <span class="comment">// 发布变更事件 后面分析UDP通知客户端</span></span><br><span class="line">    getPushService().serviceChanged(service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceChanged</span><span class="params">(Service service)</span> &#123;</span><br><span class="line">        <span class="comment">// merge some change events to reduce the push frequency:</span></span><br><span class="line">        <span class="keyword">if</span> (futureMap</span><br><span class="line">                .containsKey(UtilsAndCommons.assembleFullServiceName(service.getNamespaceId(), service.getName()))) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        <span class="built_in">this</span>.applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceChangeEvent</span>(<span class="built_in">this</span>, service));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一旦这个事件发生了，触发了com.alibaba.nacos.naming.push.PushService#onApplicationEvent方法，那就要分析这个方法做的是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ServiceChangeEvent event)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> event.getService();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> service.getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> service.getNamespaceId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个定时操作 异步执行相关内容 变化一次只执行一次</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> GlobalExecutor.scheduleUdpSender(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Loggers.PUSH.info(serviceName + <span class="string">&quot; is changed, add it to push queue.&quot;</span>);</span><br><span class="line">            <span class="comment">// 从缓存map中获取 udp client client订阅服务的时候已经放进去了</span></span><br><span class="line">            ConcurrentMap&lt;String, PushClient&gt; clients = clientMap</span><br><span class="line">                .get(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">            <span class="comment">// 没有UDP客户端，直接结束了</span></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isEmpty(clients)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 更新最后引用事件</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastRefTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="comment">// 遍历所有 UDPclient 进行UDP推送</span></span><br><span class="line">            <span class="keyword">for</span> (PushClient client : clients.values()) &#123;</span><br><span class="line">                <span class="comment">// 如果这个UDPclient是一个僵尸client 就移除他</span></span><br><span class="line">                <span class="keyword">if</span> (client.zombie()) &#123;</span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">&quot;client is zombie: &quot;</span> + client.toString());</span><br><span class="line">                    clients.remove(client.toString());</span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">&quot;client is zombie: &quot;</span> + client.toString());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Receiver.AckEntry ackEntry;</span><br><span class="line">                Loggers.PUSH.debug(<span class="string">&quot;push serviceName: &#123;&#125; to client: &#123;&#125;&quot;</span>, serviceName, client.toString());</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getPushCacheKey(serviceName, client.getIp(), client.getAgent());</span><br><span class="line">                <span class="type">byte</span>[] compressData = <span class="literal">null</span>;</span><br><span class="line">                Map&lt;String, Object&gt; data = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (switchDomain.getDefaultPushCacheMillis() &gt;= <span class="number">20000</span> &amp;&amp; cache.containsKey(key)) &#123;</span><br><span class="line">                    org.javatuples.<span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> (org.javatuples.Pair) cache.get(key);</span><br><span class="line">                    compressData = (<span class="type">byte</span>[]) (pair.getValue0());</span><br><span class="line">                    data = (Map&lt;String, Object&gt;) pair.getValue1();</span><br><span class="line"></span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">&quot;[PUSH-CACHE] cache hit: &#123;&#125;:&#123;&#125;&quot;</span>, serviceName, client.getAddrStr());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (compressData != <span class="literal">null</span>) &#123;</span><br><span class="line">                    ackEntry = prepareAckEntry(client, compressData, data, lastRefTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ackEntry = prepareAckEntry(client, prepareHostsData(client), lastRefTime);</span><br><span class="line">                    <span class="keyword">if</span> (ackEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">                        cache.put(key, <span class="keyword">new</span> <span class="title class_">org</span>.javatuples.Pair&lt;&gt;(ackEntry.origin.getData(), ackEntry.data));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Loggers.PUSH.info(<span class="string">&quot;serviceName: &#123;&#125; changed, schedule push for: &#123;&#125;, agent: &#123;&#125;, key: &#123;&#125;&quot;</span>,</span><br><span class="line">                                  client.getServiceName(), client.getAddrStr(), client.getAgent(),</span><br><span class="line">                                  (ackEntry == <span class="literal">null</span> ? <span class="literal">null</span> : ackEntry.key));</span><br><span class="line">                <span class="comment">// UDP Push给客户端</span></span><br><span class="line">                udpPush(ackEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.PUSH.error(<span class="string">&quot;[NACOS-PUSH] failed to push serviceName: &#123;&#125; to client, error: &#123;&#125;&quot;</span>, serviceName, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            futureMap.remove(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    futureMap.put(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName), future);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下具体的UDP推送方法也就是 udpPush(ackEntry)  其实就是调用JDK的方法发送UDP报文，然后失败重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Receiver.AckEntry <span class="title function_">udpPush</span><span class="params">(Receiver.AckEntry ackEntry)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (ackEntry == <span class="literal">null</span>) &#123;</span><br><span class="line">           Loggers.PUSH.error(<span class="string">&quot;[NACOS-PUSH] ackEntry is null.&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 超过重试次数 返回</span></span><br><span class="line">       <span class="keyword">if</span> (ackEntry.getRetryTimes() &gt; MAX_RETRY_TIMES) &#123;</span><br><span class="line">           Loggers.PUSH.warn(<span class="string">&quot;max re-push times reached, retry times &#123;&#125;, key: &#123;&#125;&quot;</span>, ackEntry.retryTimes, ackEntry.key);</span><br><span class="line">           ackMap.remove(ackEntry.key);</span><br><span class="line">           udpSendTimeMap.remove(ackEntry.key);</span><br><span class="line">           failedPush += <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">return</span> ackEntry;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!ackMap.containsKey(ackEntry.key)) &#123;</span><br><span class="line">               totalPush++;</span><br><span class="line">           &#125;</span><br><span class="line">           ackMap.put(ackEntry.key, ackEntry);</span><br><span class="line">           udpSendTimeMap.put(ackEntry.key, System.currentTimeMillis());</span><br><span class="line">           </span><br><span class="line">           Loggers.PUSH.info(<span class="string">&quot;send udp packet: &quot;</span> + ackEntry.key);</span><br><span class="line">           <span class="comment">// 发送UDP报文 JDK层面的东西</span></span><br><span class="line">           udpSocket.send(ackEntry.origin);</span><br><span class="line">           </span><br><span class="line">           ackEntry.increaseRetryTime();</span><br><span class="line">           <span class="comment">// 推送失败后，重试发送UDP报文</span></span><br><span class="line">           GlobalExecutor.scheduleRetransmitter(<span class="keyword">new</span> <span class="title class_">Retransmitter</span>(ackEntry),</span><br><span class="line">                   TimeUnit.NANOSECONDS.toMillis(ACK_TIMEOUT_NANOS), TimeUnit.MILLISECONDS);</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> ackEntry;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.PUSH.error(<span class="string">&quot;[NACOS-PUSH] failed to push data: &#123;&#125; to client: &#123;&#125;, error: &#123;&#125;&quot;</span>, ackEntry.data,</span><br><span class="line">                   ackEntry.origin.getAddress().getHostAddress(), e);</span><br><span class="line">           ackMap.remove(ackEntry.key);</span><br><span class="line">           udpSendTimeMap.remove(ackEntry.key);</span><br><span class="line">           failedPush += <span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="客户端收到UDP报文的处理"><a href="#客户端收到UDP报文的处理" class="headerlink" title="客户端收到UDP报文的处理"></a>客户端收到UDP报文的处理</h5><p>只要服务变更，Server发送消息是遍历订阅这个服务的所有client，那么客户端一定有相应的处理，接下来就分析客户端是怎么处理UDP报文的。实际是client是有一个线程轮训处理的。其实在客户端启动的时候会调用这个方法org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration#onApplicationEvent，他做的事情就是在tomcat容器启动的时候就执行对应的方法，类似事件监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// webserver初始化结束事件</span></span><br><span class="line">bind(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(WebServerInitializedEvent event)</span> &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> event.getApplicationContext();</span><br><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebServerApplicationContext) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;management&quot;</span>.equals(((ConfigurableWebServerApplicationContext) context)</span><br><span class="line">.getServerNamespace())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.port.compareAndSet(<span class="number">0</span>, event.getWebServer().getPort());</span><br><span class="line"><span class="built_in">this</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中最重要的就是最后那个注册启动的方法，接着我们来看看，过滤掉一些不重要的信息，可以看到在这里是执行了一个注册方法，所以我们还要来到注册方法内部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Discovery Lifecycle disabled. Not starting&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only initialize if nonSecurePort is greater than 0 and it isn&#x27;t already running</span></span><br><span class="line"><span class="comment">// because of containerPortInitializer below</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.running.get()) &#123;</span><br><span class="line"><span class="built_in">this</span>.context.publishEvent(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InstancePreRegisteredEvent</span>(<span class="built_in">this</span>, getRegistration()));</span><br><span class="line">register();</span><br><span class="line"><span class="keyword">if</span> (shouldRegisterManagement()) &#123;</span><br><span class="line">registerManagement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.context.publishEvent(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InstanceRegisteredEvent</span>&lt;&gt;(<span class="built_in">this</span>, getConfiguration()));</span><br><span class="line"><span class="built_in">this</span>.running.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到register()方法内部，最终调用的是com.alibaba.cloud.nacos.registry.NacosServiceRegistry#register，然后定位到最终调用注册的方法，大概就是从配置文件中获取服务信息，发送post请求，同时启动一个心跳定时任务，其实这些东西前面已经分析过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> namingService();</span><br><span class="line"><span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> registration.getServiceId();</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> nacosDiscoveryProperties.getGroup();</span><br><span class="line"></span><br><span class="line"><span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">instance.getIp(), instance.getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line"><span class="comment">// rethrow a RuntimeException if the registration is failed.</span></span><br><span class="line"><span class="comment">// issue : https://github.com/alibaba/spring-cloud-alibaba/issues/1132</span></span><br><span class="line">rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重要是namingService.registerInstance(serviceId, group, instance);</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以注意到上面有一个创建的方法即 NamingService namingService &#x3D; namingService()，其实内部是使用了NacosServiceManager通过反射调用了NamingService的构造方法来执行的，那我们直接定位到NamingService的构造方法，这里一定是执行了NamingService的初始化操作。在最后看到了有一个处理host的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="title function_">NacosNamingService</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        init(properties);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    ValidatorUtils.checkInitParam(properties);</span><br><span class="line">    <span class="built_in">this</span>.namespace = InitUtils.initNamespaceForNaming(properties);</span><br><span class="line">    InitUtils.initSerialization();</span><br><span class="line">    initServerAddr(properties);</span><br><span class="line">    InitUtils.initWebRootContext(properties);</span><br><span class="line">    initCacheDir();</span><br><span class="line">    initLogName(properties);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.serverProxy = <span class="keyword">new</span> <span class="title class_">NamingProxy</span>(<span class="built_in">this</span>.namespace, <span class="built_in">this</span>.endpoint, <span class="built_in">this</span>.serverList, properties);</span><br><span class="line">    <span class="built_in">this</span>.beatReactor = <span class="keyword">new</span> <span class="title class_">BeatReactor</span>(<span class="built_in">this</span>.serverProxy, initClientBeatThreadCount(properties));</span><br><span class="line">    <span class="comment">// 这里就是创建一个线程池来处理</span></span><br><span class="line">    <span class="built_in">this</span>.hostReactor = <span class="keyword">new</span> <span class="title class_">HostReactor</span>(<span class="built_in">this</span>.serverProxy, beatReactor, <span class="built_in">this</span>.cacheDir, isLoadCacheAtStart(properties),</span><br><span class="line">            isPushEmptyProtect(properties), initPollingThreadCount(properties));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入这个线程池的初始化代码内部，看到有一个关键信息就是创建一个PushReceiver来处理UDP推送信息。最后就来看看这个pushReceiver是怎么处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HostReactor</span><span class="params">(NamingProxy serverProxy, BeatReactor beatReactor, String cacheDir, <span class="type">boolean</span> loadCacheAtStart,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> pushEmptyProtection, <span class="type">int</span> pollingThreadCount)</span> &#123;</span><br><span class="line">       <span class="comment">// init executorService</span></span><br><span class="line">       <span class="built_in">this</span>.executor = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(pollingThreadCount, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">               <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">               thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">               thread.setName(<span class="string">&quot;com.alibaba.nacos.client.naming.updater&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> thread;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">this</span>.beatReactor = beatReactor;</span><br><span class="line">       <span class="built_in">this</span>.serverProxy = serverProxy;</span><br><span class="line">       <span class="built_in">this</span>.cacheDir = cacheDir;</span><br><span class="line">       <span class="keyword">if</span> (loadCacheAtStart) &#123;</span><br><span class="line">           <span class="built_in">this</span>.serviceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ServiceInfo&gt;(DiskCache.read(<span class="built_in">this</span>.cacheDir));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.serviceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ServiceInfo&gt;(<span class="number">16</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">this</span>.pushEmptyProtection = pushEmptyProtection;</span><br><span class="line">       <span class="built_in">this</span>.updatingMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;();</span><br><span class="line">       <span class="built_in">this</span>.failoverReactor = <span class="keyword">new</span> <span class="title class_">FailoverReactor</span>(<span class="built_in">this</span>, cacheDir);</span><br><span class="line">    <span class="comment">// 处理server 的UDP推送</span></span><br><span class="line">       <span class="built_in">this</span>.pushReceiver = <span class="keyword">new</span> <span class="title class_">PushReceiver</span>(<span class="built_in">this</span>);</span><br><span class="line">       <span class="built_in">this</span>.notifier = <span class="keyword">new</span> <span class="title class_">InstancesChangeNotifier</span>();</span><br><span class="line">       </span><br><span class="line">       NotifyCenter.registerToPublisher(InstancesChangeEvent.class, <span class="number">16384</span>);</span><br><span class="line">       NotifyCenter.registerSubscriber(notifier);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入pushReceiver，他是一个线程直接看run方法，可以看到它就是一个线程，然后做的事情就是获取UDP包，解析称为JSON然后把Nacos Server上面变更的service写入到本地，然后发送给服务器一个ack。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PushReceiver</span><span class="params">(HostReactor hostReactor)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.hostReactor = hostReactor;</span><br><span class="line">           <span class="built_in">this</span>.udpSocket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">           <span class="comment">// 创建一个线程池</span></span><br><span class="line">           <span class="built_in">this</span>.executorService = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                   <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                   thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                   thread.setName(<span class="string">&quot;com.alibaba.nacos.naming.push.receiver&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span> thread;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="comment">// 异步执行当前PushReceiver任务</span></span><br><span class="line">           <span class="built_in">this</span>.executorService.execute(<span class="built_in">this</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           NAMING_LOGGER.error(<span class="string">&quot;[NA] init udp socket failed&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (!closed) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// byte[] is initialized with 0 full filled by default</span></span><br><span class="line">               <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[UDP_MSS];</span><br><span class="line">               <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">               <span class="comment">// 接受来自server的UDP包 并封装</span></span><br><span class="line">               udpSocket.receive(packet);</span><br><span class="line">               <span class="comment">// 将数据解码称为JSON</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(IoUtils.tryDecompress(packet.getData()), UTF_8).trim();</span><br><span class="line">               NAMING_LOGGER.info(<span class="string">&quot;received push data: &quot;</span> + json + <span class="string">&quot; from &quot;</span> + packet.getAddress().toString());</span><br><span class="line">               </span><br><span class="line">               <span class="type">PushPacket</span> <span class="variable">pushPacket</span> <span class="operator">=</span> JacksonUtils.toObj(json, PushPacket.class);</span><br><span class="line">               String ack;</span><br><span class="line">               <span class="comment">// 根据不同的数据类型，返回到server不同的ack</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="string">&quot;dom&quot;</span>.equals(pushPacket.type) || <span class="string">&quot;service&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                   <span class="comment">// 将来自server的发生变更的service更新到当前Naocs Client本地注册表中</span></span><br><span class="line">                   hostReactor.processServiceJson(pushPacket.data);</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">// send ack to server</span></span><br><span class="line">                   ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;push-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;:\&quot;&quot;</span> + pushPacket.lastRefTime + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span></span><br><span class="line">                           + <span class="string">&quot;\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;dump&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                   <span class="comment">// dump data to server</span></span><br><span class="line">                   ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;dump-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;: \&quot;&quot;</span> + pushPacket.lastRefTime + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span></span><br><span class="line">                           + <span class="string">&quot;\&quot;&quot;</span> + StringUtils.escapeJavaScript(JacksonUtils.toJson(hostReactor.getServiceInfoMap()))</span><br><span class="line">                           + <span class="string">&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// do nothing send ack only</span></span><br><span class="line">                   ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;unknown-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;:\&quot;&quot;</span> + pushPacket.lastRefTime</span><br><span class="line">                           + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span> + <span class="string">&quot;\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 返回ack到server</span></span><br><span class="line">               udpSocket.send(<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(ack.getBytes(UTF_8), ack.getBytes(UTF_8).length,</span><br><span class="line">                       packet.getSocketAddress()));</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               NAMING_LOGGER.error(<span class="string">&quot;[NA] error while receiving push data&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Server间通信"><a href="#Server间通信" class="headerlink" title="Server间通信"></a>Server间通信</h4><p>Nacos在启动的时候会进行3项重要操作</p><ol><li>启动一个定时任务，每60S当前Server会向其他Nacos Server发送一次本地注册表</li><li>会从其他Nacos Server获取的注册表中的所有instance的状态，并更新到本地</li><li>启动一个定时任务，60S之后执行，每20S清理一次注册表中的空Service</li></ol><p>结论就是，ServerManager在创建的时候通过后置处理器初始化了这三个任务，我们直接来看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Init service maneger.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 第一项任务，上报本地注册表 本季注册表是以校验和方式发送</span></span><br><span class="line">       GlobalExecutor.scheduleServiceReporter(<span class="keyword">new</span> <span class="title class_">ServiceReporter</span>(), <span class="number">60000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">// 从其他nacos实例获取最新状态</span></span><br><span class="line">       GlobalExecutor.submitServiceUpdateManager(<span class="keyword">new</span> <span class="title class_">UpdatedServiceProcessor</span>());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (emptyServiceAutoClean) &#123;</span><br><span class="line"></span><br><span class="line">           Loggers.SRV_LOG.info(<span class="string">&quot;open empty service auto clean job, initialDelay : &#123;&#125; ms, period : &#123;&#125; ms&quot;</span>,</span><br><span class="line">                   cleanEmptyServiceDelay, cleanEmptyServicePeriod);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// delay 60s, period 20s;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// This task is not recommended to be performed frequently in order to avoid</span></span><br><span class="line">           <span class="comment">// the possibility that the service cache information may just be deleted</span></span><br><span class="line">           <span class="comment">// and then created due to the heartbeat mechanism</span></span><br><span class="line"><span class="comment">// 清除注册表中的空service</span></span><br><span class="line">           <span class="comment">// 会操作这个集群</span></span><br><span class="line">           GlobalExecutor.scheduleServiceAutoClean(<span class="keyword">new</span> <span class="title class_">EmptyServiceAutoClean</span>(), cleanEmptyServiceDelay,</span><br><span class="line">                   cleanEmptyServicePeriod);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Loggers.SRV_LOG.info(<span class="string">&quot;listen for service meta change&quot;</span>);</span><br><span class="line">           consistencyService.listen(KeyBuilder.SERVICE_META_KEY_PREFIX, <span class="built_in">this</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.error(<span class="string">&quot;listen for service meta change failed!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="上报本地注册表任务"><a href="#上报本地注册表任务" class="headerlink" title="上报本地注册表任务"></a>上报本地注册表任务</h5><p>上报注册表任务一看就知道是一个定时任务，我们来看一下这个任务具体的run方法。就是遍历所有的名称空间下的所有的服务，然后针对这些服务生成校验和，然后获取Nacos服务列表，发送出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// key=namespaceId value是一个集合，集合中是当前namespace中的所有的service的名称</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; allServiceNames = getAllServiceNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allServiceNames.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String namespaceId : allServiceNames.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServiceChecksum</span> <span class="variable">checksum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceChecksum</span>(namespaceId);</span><br><span class="line"><span class="comment">// namespaceId -&gt; 所有的服务名称</span></span><br><span class="line">            <span class="comment">// 遍历所有的namespace </span></span><br><span class="line">            <span class="keyword">for</span> (String serviceName : allServiceNames.get(namespaceId)) &#123;</span><br><span class="line">                <span class="comment">// 若当前服务不归当前server负责就跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!distroMapper.responsible(serviceName)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 从注册表中获取当前遍历的服务</span></span><br><span class="line">                <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (service == <span class="literal">null</span> || service.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 计算校验和</span></span><br><span class="line">                service.recalculateChecksum();</span><br><span class="line"><span class="comment">// 将计算好的校验和放入map</span></span><br><span class="line">                checksum.addItem(serviceName, service.getChecksum());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 发给其他服务器的时候 发送是这个</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line"><span class="comment">// 将当前namespace所有服务的校验和封装进去</span></span><br><span class="line">            msg.setData(JacksonUtils.toJson(checksum));</span><br><span class="line"><span class="comment">// 获取到所有的nacos</span></span><br><span class="line">            Collection&lt;Member&gt; sameSiteServers = memberManager.allMembers();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sameSiteServers == <span class="literal">null</span> || sameSiteServers.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 遍历发送</span></span><br><span class="line">            <span class="keyword">for</span> (Member server : sameSiteServers) &#123;</span><br><span class="line">                <span class="comment">// 跳过当前server</span></span><br><span class="line">                <span class="keyword">if</span> (server.getAddress().equals(NetUtils.localServer())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 同步器发送</span></span><br><span class="line">                synchronizer.send(server.getAddress(), msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.SRV_LOG.error(<span class="string">&quot;[DOMAIN-STATUS] Exception while sending service status&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        GlobalExecutor.scheduleServiceReporter(<span class="built_in">this</span>, switchDomain.getServiceStatusSynchronizationPeriodMillis(),</span><br><span class="line">                                               TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续分析一下发送状态同步是怎么做的，这就要研究 synchronizer.send(server.getAddress(), msg)这个方法了，进入方法内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String serverIP, Message msg)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (serverIP == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">10</span>);</span><br><span class="line">       </span><br><span class="line">       params.put(<span class="string">&quot;statuses&quot;</span>, msg.getData());</span><br><span class="line">       params.put(<span class="string">&quot;clientIP&quot;</span>, NetUtils.localServer());</span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://&quot;</span> + serverIP + <span class="string">&quot;:&quot;</span> + EnvUtil.getPort() + EnvUtil.getContextPath()</span><br><span class="line">               + UtilsAndCommons.NACOS_NAMING_CONTEXT + <span class="string">&quot;/service/status&quot;</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (IPUtil.containsPort(serverIP)) &#123;</span><br><span class="line">           url = <span class="string">&quot;http://&quot;</span> + serverIP + EnvUtil.getContextPath() + UtilsAndCommons.NACOS_NAMING_CONTEXT</span><br><span class="line">                   + <span class="string">&quot;/service/status&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 发送Post请求</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           HttpClient.asyncHttpPostLarge(url, <span class="literal">null</span>, JacksonUtils.toJson(params), <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;String&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(RestResult&lt;String&gt; result)</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!result.ok()) &#123;</span><br><span class="line">                       Loggers.SRV_LOG.warn(<span class="string">&quot;[STATUS-SYNCHRONIZE] failed to request serviceStatus, remote server: &#123;&#125;&quot;</span>,</span><br><span class="line">                               serverIP);</span><br><span class="line">       </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                   Loggers.SRV_LOG.warn(<span class="string">&quot;[STATUS-SYNCHRONIZE] failed to request serviceStatus, remote server: &quot;</span> + serverIP, throwable);</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancel</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;[STATUS-SYNCHRONIZE] failed to request serviceStatus, remote server: &quot;</span> + serverIP, e);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="从其他Nacos获取最新注册表并更新到本地"><a href="#从其他Nacos获取最新注册表并更新到本地" class="headerlink" title="从其他Nacos获取最新注册表并更新到本地"></a>从其他Nacos获取最新注册表并更新到本地</h5><p>开始分析第二个任务，这个任务不是定时任务而是一个无限循环，从队列里面取出来一个发生了状态变更的service，然后启动一个线程来处理更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UpdatedServiceProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get changed service from other server asynchronously</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceKey</span> <span class="variable">serviceKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他服务发生了变更，全都放在这个队列中</span></span><br><span class="line">                    <span class="comment">// 从这个队列里面取出来一个状态发生了变更的服务</span></span><br><span class="line">                    serviceKey = toBeUpdatedServicesQueue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Loggers.EVT_LOG.error(<span class="string">&quot;[UPDATE-DOMAIN] Exception while taking item from LinkedBlockingDeque.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (serviceKey == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 另外启动一个线程来完成一个ServiceUpdate任务，</span></span><br><span class="line">                GlobalExecutor.submitServiceUpdate(<span class="keyword">new</span> <span class="title class_">ServiceUpdater</span>(serviceKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.EVT_LOG.error(<span class="string">&quot;[UPDATE-DOMAIN] Exception while update service: &#123;&#125;&quot;</span>, serviceKey, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>进入ServiceUpdater这个类，这个类是一个线程类，重点就是看一下run方法，内部调用的是updatedHealthStatus(namespaceId, serviceName, serverIP)，所以还要点进去看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ServiceUpdater</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        String namespaceId;</span><br><span class="line"></span><br><span class="line">        String serviceName;</span><br><span class="line"></span><br><span class="line">        String serverIP;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ServiceUpdater</span><span class="params">(ServiceKey serviceKey)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.namespaceId = serviceKey.getNamespaceId();</span><br><span class="line">            <span class="built_in">this</span>.serviceName = serviceKey.getServiceName();</span><br><span class="line">            <span class="built_in">this</span>.serverIP = serviceKey.getServerIP();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                updatedHealthStatus(namespaceId, serviceName, serverIP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Loggers.SRV_LOG</span><br><span class="line">                        .warn(<span class="string">&quot;[DOMAIN-UPDATER] Exception while update service: &#123;&#125; from &#123;&#125;, error: &#123;&#125;&quot;</span>, serviceName,</span><br><span class="line">                                serverIP, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的更新方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Update health status of instance in service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> namespaceId namespace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName service name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverIP    source server Ip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatedHealthStatus</span><span class="params">(String namespaceId, String serviceName, String serverIP)</span> &#123;</span><br><span class="line">   <span class="comment">// 同步器从其他server获取指定服务的数据</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> synchronizer.get(serverIP, UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">    <span class="type">JsonNode</span> <span class="variable">serviceJson</span> <span class="operator">=</span> JacksonUtils.toObj(msg.getData());</span><br><span class="line"><span class="comment">// 过去这个服务所有的实例</span></span><br><span class="line">    <span class="type">ArrayNode</span> <span class="variable">ipList</span> <span class="operator">=</span> (ArrayNode) serviceJson.get(<span class="string">&quot;ips&quot;</span>);</span><br><span class="line">    <span class="comment">// 这个map是存的是所有的instance的健康状态</span></span><br><span class="line">    <span class="comment">// key -&gt; ip+port value = healthy </span></span><br><span class="line">    Map&lt;String, String&gt; ipsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(ipList.size());</span><br><span class="line">    <span class="comment">// 遍历实例</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ipList.size(); i++) &#123;</span><br><span class="line"><span class="comment">// 格式是 ip:prot_healthy</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ipList.get(i).asText();</span><br><span class="line">        String[] strings = ip.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="comment">// 将遍历的instance的地址和健康状态放入map</span></span><br><span class="line">        ipsMap.put(strings[<span class="number">0</span>], strings[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从注册表中获取当前服务的</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 当前注册表中该服务所有instance</span></span><br><span class="line">    List&lt;Instance&gt; instances = service.allIPs();</span><br><span class="line">    <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line"><span class="comment">//获取来自于其他nacos该服务的所有instance</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> Boolean.parseBoolean(ipsMap.get(instance.toIpAddr()));</span><br><span class="line">        <span class="comment">// 如果当前注册表中的instance的状态和外来的不一致</span></span><br><span class="line">        <span class="keyword">if</span> (valid != instance.isHealthy()) &#123;</span><br><span class="line">            <span class="comment">// 发生变更 以外来的为准</span></span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            instance.setHealthy(valid);</span><br><span class="line">            Loggers.EVT_LOG.info(<span class="string">&quot;&#123;&#125; &#123;SYNC&#125; IP-&#123;&#125; : &#123;&#125;:&#123;&#125;@&#123;&#125;&quot;</span>, serviceName,</span><br><span class="line">                                 (instance.isHealthy() ? <span class="string">&quot;ENABLED&quot;</span> : <span class="string">&quot;DISABLED&quot;</span>), instance.getIp(), instance.getPort(),</span><br><span class="line">                                 instance.getClusterName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 只要有一个发生变更了 </span></span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="comment">// 向client发送推送 详见服务端发送UDP推送</span></span><br><span class="line">        pushService.serviceChanged(service);</span><br><span class="line">        <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            List&lt;Instance&gt; allIps = service.allIPs();</span><br><span class="line">            <span class="keyword">for</span> (Instance instance : allIps) &#123;</span><br><span class="line">                stringBuilder.append(instance.toIpAddr()).append(<span class="string">&quot;_&quot;</span>).append(instance.isHealthy()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Loggers.EVT_LOG</span><br><span class="line">                .debug(<span class="string">&quot;[HEALTH-STATUS-UPDATED] namespace: &#123;&#125;, service: &#123;&#125;, ips: &#123;&#125;&quot;</span>, service.getNamespaceId(),</span><br><span class="line">                       service.getName(), stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定时清理空Service"><a href="#定时清理空Service" class="headerlink" title="定时清理空Service"></a>定时清理空Service</h5><p>第三个任务是一个典型的定时任务，开启后60S后执行，每20S执行一次，来看看具体是怎么做空Service清除的。主要做事情有几步：</p><ol><li>遍历所有的service取出来当前服务负责的</li><li>如果某个服务是空的，那么不要直接删除而是看它被判定为空的次数是不是大于阈值3</li><li>删除服务并且通过同步服务通知到其他Nacos Server</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空Service即为没有instance的Service</span></span><br><span class="line">GlobalExecutor.scheduleServiceAutoClean(<span class="keyword">new</span> <span class="title class_">EmptyServiceAutoClean</span>(), cleanEmptyServiceDelay,</span><br><span class="line">        cleanEmptyServicePeriod);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parallel flow opening threshold</span></span><br><span class="line"><span class="comment">// 这是一个并行流的阈值，一个namespace下的service数量超过100的时候，会将注册表创建为一个并行流</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parallelSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">// serviceMap就是注册表内层map</span></span><br><span class="line">    serviceMap.forEach((namespace, stringServiceMap) -&gt; &#123;</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Service&gt;&gt; stream = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果当前遍历的这个元素（namespace），包含的服务的数量超出了并行流阈值</span></span><br><span class="line">        <span class="comment">// 生产一个并行流</span></span><br><span class="line">        <span class="keyword">if</span> (stringServiceMap.size() &gt; parallelSize) &#123;</span><br><span class="line">            stream = stringServiceMap.entrySet().parallelStream();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stream = stringServiceMap.entrySet().stream();</span><br><span class="line">        &#125;</span><br><span class="line">        stream.filter(entry -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">// 当前遍历的服务是需要当前server负责的，通过过滤</span></span><br><span class="line">            <span class="keyword">return</span> distroMapper.responsible(serviceName);</span><br><span class="line">            <span class="comment">// 这里处理的server一定就是当前server负责的</span></span><br><span class="line">            <span class="comment">// 元素不空则进行操作 -&gt; </span></span><br><span class="line">        &#125;).forEach(entry -&gt; stringServiceMap.computeIfPresent(entry.getKey(), (serviceName, service) -&gt; &#123;</span><br><span class="line">           <span class="comment">// 这个服务是空的</span></span><br><span class="line">            <span class="keyword">if</span> (service.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// To avoid violent Service removal, the number of times the Service</span></span><br><span class="line">                <span class="comment">// experiences Empty is determined by finalizeCnt, and if the specified</span></span><br><span class="line">                <span class="comment">// value is reached, it is removed</span></span><br><span class="line"><span class="comment">// service.getFinalizeCount() -&gt; 记录的是这个service被判断为空的次数 3次 </span></span><br><span class="line">                <span class="comment">// 为空的次数超过了最大允许值，就删除这个服务</span></span><br><span class="line">                <span class="keyword">if</span> (service.getFinalizeCount() &gt; maxFinalizeCount) &#123;</span><br><span class="line">                    Loggers.SRV_LOG.warn(<span class="string">&quot;namespace : &#123;&#125;, [&#123;&#125;] services are automatically cleaned&quot;</span>, namespace,</span><br><span class="line">                                         serviceName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 通过同步服务remove</span></span><br><span class="line">                        easyRemoveService(namespace, serviceName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Loggers.SRV_LOG.error(<span class="string">&quot;namespace : &#123;&#125;, [&#123;&#125;] services are automatically clean has &quot;</span></span><br><span class="line">                                              + <span class="string">&quot;error : &#123;&#125;&quot;</span>, namespace, serviceName, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 计数器+1</span></span><br><span class="line">                service.setFinalizeCount(service.getFinalizeCount() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                Loggers.SRV_LOG</span><br><span class="line">                    .debug(<span class="string">&quot;namespace : &#123;&#125;, [&#123;&#125;] The number of times the current service experiences &quot;</span></span><br><span class="line">                           + <span class="string">&quot;an empty instance is : &#123;&#125;&quot;</span>, namespace, serviceName,</span><br><span class="line">                           service.getFinalizeCount());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不为空的话就把判定为空的次数设置为0</span></span><br><span class="line">                service.setFinalizeCount(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个步骤在这个方法中已经体现了，现在还有一点不情况的是如何通过同步服务通知到其他Nacos Server，就是用的同步服务的remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">easyRemoveService</span><span class="params">(String namespaceId, String serviceName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;specified service not exist, serviceName : &quot;</span> + serviceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consistencyService.remove(KeyBuilder.buildServiceMetaKey(namespaceId, serviceName));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos-Tutorial&quot;&gt;&lt;a href=&quot;#Nacos-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;Nacos Tutorial&quot;&gt;&lt;/a&gt;Nacos Tutorial&lt;/h1&gt;&lt;h2 id=&quot;Nacos总览&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
    <category term="SpringCloud Alibaba" scheme="http://example.com/tags/SpringCloud-Alibaba/"/>
    
  </entry>
  
</feed>
