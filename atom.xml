<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰色と青</title>
  
  <subtitle>Eurekawm&#39;s Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-27T10:41:01.001Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>sean</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL优化相关</title>
    <link href="http://example.com/2022/03/27/MySQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/03/27/MySQL%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/</id>
    <published>2022-03-27T09:56:07.000Z</published>
    <updated>2022-03-27T10:41:01.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="explain执行计划的几种坏情况"><a href="#explain执行计划的几种坏情况" class="headerlink" title="explain执行计划的几种坏情况"></a>explain执行计划的几种坏情况</h2><ol><li>Using join buffer (Block Nested Loop) 关联查询的时候没加索引</li><li>Using filesort 用了文件排序 数据是无序的，在文件或者是内存中作了排序 这种情况用覆盖索引来解决</li><li>Using temporary 使用了临时表，去重复，排序，DISTINCT GROUP BY ORDER BY 如果是无序的 要一个临时表来做这些东西 所以加一个索引就好了</li></ol><h2 id="索引注意事项"><a href="#索引注意事项" class="headerlink" title="索引注意事项"></a>索引注意事项</h2><ol><li>全值匹配</li><li>最左前缀</li><li>字段函数处理 索引失效</li><li>where条件上对加了索引的字段各种计算</li><li>类型转换导致索引失效     数据转到字符串要失效的 而字符转数字不会</li><li>范围查询右侧的列索引失效     这种情况把确定的放在前面，范围的放在后面</li><li>不等于操作 索引失效     这种相当于扫描了一大片</li><li>IS     NULL可以使用索引 IS NOT NULL不可以使用 IS NULL可以直接在b+树上面找，所以一般加一个非空约束     LIKE NOT LIKE同理</li><li>LIKE查询以%开头的，开头无法确定就无法走b+树     严禁左模糊或全模糊</li><li>OR前后存在非索引列，索引失效     比如前面用了索引，后面的全表扫描了，那不如不用</li><li>字符集的转换会导致索引失效     因此要统一字符集</li></ol><p>一般性建议：</p><ol><li>如果使用的是单列索引，尽量选择对当前query过滤性比较好的索引</li><li>使用组合索引，当前query过滤性越好的放在越前面</li><li>使用组合索引，使用包含了where子句中更多字段的索引</li><li>使用组合索引，有范围查询的时候，把查询字段放在索引最后面</li></ol><h2 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h2><ol><li>在左外连接关联查询的时候如果是不加索引，执行计划的extra里面会有一个Using join buffer，此时我们需要在被驱动表（右边的表）的条件上加上一个索引，来提升效率</li><li>对于内连接来说，查询优化器是可以决定谁作为驱动谁作为被驱动的，如果表的连接条件中，只能有一个字段作为索引，那么这个字段所在的表会被作为被驱动表，     如果连接条件都是有索引的，那么把小表作为驱动表</li><li>出现了Using join buffer(Blocked nested loop)给数据量大的表的连接条件加一个索引，不能加索引的时候，调整join buffer的大小，越大越好</li></ol><p>一般性建议：</p><ol><li>被驱动表的JOIN字段加了索引</li><li>需要JOIN的字段数据类型是一样的</li><li>LEFT JOIN的时候  选择小表为驱动表</li><li>INNER  JOIN的时候会MySQL会自己选择小表</li><li>能关联就不用子查询</li><li>衍生表不能建立索引</li></ol><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><p>子查询为什么效率不高</p><ol><li>子查询的时候会为内层查询结果建立一个临时表，然后外层查询从其中获得记录，查询完毕之后又销毁这些临时表，这样造成了大量的磁盘IO和CPU开销，产生大量的慢查询</li><li>子查询内层查询的临时表无论是在内存还是在磁盘都是没有索引的</li><li>对返回结果集比较大的子查询，对其查询性能的影响也比较大</li></ol><p>子查询优化</p><ol><li>优化成连接查询</li></ol><h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><p>MySQL中有两种排序方式 index 和 filesort</p><p>index方式是索引保证了有序性，不需要在排序了，效率更高</p><p>filesort一般是在内存中进行排序，占用更多cpu，如果排序的量比较大可能还要落盘，效率低</p><p>优化建议：</p><ol><li>在where 和 order by 子句中使用索引，目的是在where的时候避免全表扫描，order by 的时候避免使用filesort</li><li>尽量使用index完成order     by，如果where 和 order by是相同的列就用单索引，如果是不同就使用联合索引</li><li>无法使用index就要优化filesort</li></ol><p>ORDER BY的几种索引失效的情况</p><ol><li>order by的时候不加limit限制。这种情况优化器觉得是你大量的回表，然后在取数据，这种还不如全表走一遍然后再用filesort。优化方式就是不select *，而是用覆盖索引</li><li>order by 顺序错误</li><li>order by     规则不一致 比如实际上是以升序做的索引，但是order by的时候是降序（要反都反）</li></ol><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271813099.png" alt="未命名图片" style="zoom:50%;" /><ul><li><p>index不绝对比filesort快</p></li><li><p><strong>场景</strong>:<strong>查询年龄为</strong>30<strong>岁的，且学生编号小于</strong>101000<strong>的学生，按用户名称排序</strong> </p></li><li><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271815745.png" alt="未命名图片"></p></li></ul><p>Type是all，而且用了filesort， 全表扫描加文件排序，最差的一种情况，是需要优化的</p><p>方案1:为了去掉filesort我们在age和name上面建立一个索引</p><p>方案2:尽量让where的过滤条件和排序使用上索引，在age stuno name上建立联合索引</p><p>在这里第二种更快，虽然是用了filesort，但是条件范围已经过了了很多数据，然后即使再排序也是没关系的，只有很少的数据是需要排序的</p><p>结论：</p><ol><li>两个索引同时存在，MySQL自动选择最佳方案，随着数据量变化，索引也是会变化的</li><li>当范围条件和group     by和order by字段二选一的时候优先观察条件字段过滤的数据量，当过滤的数据量多，且需要排序的字段不多时，优先把索引放在条件字段上面</li></ol><h2 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a>分组优化</h2><p>分组和排序其实优化原理差不多</p><ol><li>group by是先排序再分组，按照左前缀法则</li><li>无法使用索引的时候，增大max_length_for_sort_data和sort_buffer_size</li><li>where效率高于having，能写在where的限定条件就不用having了</li><li>减少使用group by，order by，distinct这些操作，因为很耗cpu资源，可以放在业务中</li><li>包含了以上的查询的语句，where过滤出来的数量集在1000以内</li></ol><h2 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h2><p>一般分页查询的时候，通过创建索引可以比较好提升查询性能，但是有一个问题如果是limit 20000,10</p><p>那么MySQL实际查询的时候是丢弃了前面20000个记录，只返回了10个，代价是很大的</p><p>优化思路：</p><ol><li>在索引上面完成分页操作然后回表取值 EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id &#x3D; a.id</li><li>该方案适用于主键自增的情况，把limit转化为某个位置的查询 EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</li></ol><h2 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h2><p>什么是覆盖索引</p><p>一个索引包含了满足查询结果的数据就是覆盖索引</p><p>覆盖索引的利弊</p><p>优点：</p><ol><li>避免了回表。在覆盖索引上面就获取了所需的数据，避免了对主键的二次查询，减少了IO操作，提高了效率</li><li>随机IO变成了顺序IO。由于覆盖索引是按照值顺序来存储的，对于IO密集的范围查询，对比从磁盘读取每一行数据的IO要少很多（回表的时候，可能主键对应的数据是不在同一个页上面的，所以要进行多次IO加载数据页），因此是把随机IO变成了顺序IO</li></ol><p>缺点：</p><ol><li>索引字段的维护是有代价的，不好的索引既浪费了空间又不能加速查询</li></ol><h2 id="如何给字符串加索引"><a href="#如何给字符串加索引" class="headerlink" title="如何给字符串加索引"></a>如何给字符串加索引</h2><p>一般方法是前缀索引：</p><p>原因：</p><ol><li>如果一个字段很长，加索引的话就浪费了太多空间了</li></ol><p>前缀索引长度：</p><ol><li>如果长度不够可能出现重复的情况，那么就要判断多次，区分度越高，重复的键值就更少。区分度计算方法 count(distinct left(column,lent)) &#x2F; count(8)。按照阿里巴巴的规则一般20个字符长度的前缀索引区分度在90%以上</li><li>使用前缀索引的时候，定义好长度，既节约了空间也可以减少查询的成本。</li></ol><p>注意点：前缀索引会影响到覆盖索引的使用。</p><p>因为前缀索引截断了字符串，你无法通过这样的索引来获取整个列的值。就算你的前缀索引包含了所有的值，InnoDB还是会回表查询一次的。</p><p>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p><p>场景：如何对身份证来做前缀索引</p><ol><li>前面6位是区号，重复的概率是很大的，因此如果要在做前缀索引的话，至少是要12位的。但是这样的浪费了太多空间，一个数据页存放的数据就变少了。</li><li>存储身份证的时候倒过来，这样后6位的区分度就很高了</li><li>加一个字段来存身份证的hash值     查询的时候SQL可以这样写：select userinfo from t where id_card_crc &#x3D;     crc32(‘user_id_card_number’) and id_card &#x3D; ‘user_id_card_number’，这样的话，索引就只占了4字节</li></ol><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优 化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数</p><p>例子：SELECT * FROM T WHERE key &gt; ‘a’ AND key LIKE ‘%b’</p><ol><li>如果没有ICP，这种查询是先找到满足key &gt; ‘a’ 的数据，然后回表判断，把符合条件LIKE ‘%b’的数据返回。这种可能需要回表的数据为100，然后筛选出来满足条件的数据为10个</li><li>开启了ICP的话，在查询的时候先找到key &gt;     ‘a’的数据，然后先不回表，再在索引里面判断一下是否满足LIKE ‘%b’这个条件，然后回表。这样操作可能回表的次数就只有10次了。</li></ol><p>使用ICP的话就先筛选了一些不满足条件的数据，然后在回表，这样就减少了回表的次数，也就减少了随机IO的发生。</p><p>案例：SELECT * FROM user WHERE name LIKE ‘张%’ AND age &#x3D;10 AND ismale &#x3D; 1</p><ol><li><p>不使用ICP的情况</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271824683.png" alt="1ds"></p></li><li><p>使用了ICP的情况<img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271825969.png" alt="121"></p></li></ol><p>ICP的使用条件</p><ol><li>只能用于二级索引，因为聚集索引这种情况，完整的记录已经被读入到innoDB缓冲区，这种情况ICP不能减少回表</li><li>explain     的type类型应该是range ref eq_ref ref_or_null</li><li>where条件的字段必须在索引列中才能用ICP筛选</li><li>ICP可以用于InnoDB和MyISAM引擎</li><li>当SQL使用覆盖索引的时候不能使用ICP优化（既然都不回表了当然不用ICP优化了）</li></ol><p>总结：ICP就是为了优化回表的</p><h2 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h2><p>案例：维护一个居民系统， 每个人都有唯一的身份证，业务端保证写入的身份证是唯一的</p><p>那么我们从性能角度考虑用唯一索引还是普通索引呢？<br> 建立一个表：</p><p>mysql&gt; create table test(</p><p>id int primary key,</p><p>k int not null,</p><p>name varchar(16),</p><p>index (k)</p><p>)engine&#x3D;InnoDB;</p><p>查询过程： select id from test where k&#x3D;5</p><ol><li>普通索引查询过程，查到第一个满足条件k&#x3D;5的继续找下一条，直到不满足条件</li><li>唯一索引，查到第一个满足条件k&#x3D;5，直接返回结果</li></ol><p>其实查询过程的性能差距很小，InnoDB是以数据页为单位的，因为两条数据是极大可能在一个页中，在内存中比较是很快的所以这两种索引，在查询的时候性能是差不多的</p><p>插入过程：</p><p>先介绍一下change buffer。如果要更新一个数据页的时候，如果这个数据页是没有在内存中，那么在不影响一致性的情况下，InnoDB会把这次更新写入到change buffer中，下次你要读这个页的时候，把这个页加载到内存中，然后进行一个merge 操作，把change buffer中和这个页有关的数据合并起来。这样做的原因一是减少了磁盘IO，而是每次插入记录如果要加载页到buffer pool，这其实是要占用内存的。change buffer是buffer pool里面的一部分，是不能无限增大的，可以通过innodb_change_buffer_size来限制。</p><p>唯一索引是不能使用change buffer的。原因是本身他已经是唯一约束了，比如我插入一个（4，400），先要判断一下是否有这个数据，这设计到加载一个页到内存中，既然你已经加载数据页到内存中了，那么就没必要把更新操作写在changebuffer中了。</p><p>现在开始分析插入数据的情况下两种索引的性能区别：</p><ol><li><p>要更新的目标页就在内存中： </p></li><li><ol><li>唯一索引：找到3，5之间的位置，判断是否有冲突，然后插入</li><li>普通索引：找到3，5之间的位置，直接插入</li></ol></li><li><p>要更新的页在磁盘中</p></li><li><ol><li>唯一索引：将数据页读人到内存中，判断有无冲突，插入</li><li>普通索引：将插入数据记录在change buffer中</li></ol></li></ol><p>将数据页读取到内存中是很重的操作，因此唯一索引在插入操作的时候是比普通索引性能低的，而普通索引插入数据的时候，使用了change buffer，减少了很多的磁盘IO。</p><p>change buffer的使用场景：</p><ol><li>change buffer只限于普通索引，不适用于唯一索引</li><li>对于写多读少的业务来说 change     buffer是很有用的，因为merge操作是要读取数据的时候才会进行的，在这之前写操作相当于是缓存到了change     buffer，那么尽量的少merge，也就是尽量缓存多点写操作是更好的（账单，日志）</li><li>如果是一个业务是写入后立即就要查询的，更新记录先写在change     buffer中然后立马加载数据页到内存然后merge，这样随机访问IO不会降低，还要维护change buffer，这种情况change     buffer起了反作用</li></ol><p>总结：</p><ol><li>唯一索引和普通索引在查询的时候性能是差不多的，在更新上建议使用普通索引，普通索引在和change buffer配合的时候，对于大数据量的写入是很好的。</li><li>如果写入伴随查询，建议关闭changebuffer。</li><li>由于唯一索引用不上change     buffer的优化，我们可以在业务上保证唯一性，然后使用索引的时候还是使用普通索引，如果碰上了大量插入行为， 系统性能下降，可以通过唯一索引这方面来排查。</li></ol><h2 id="其他优化点"><a href="#其他优化点" class="headerlink" title="其他优化点"></a>其他优化点</h2><h3 id="EXISTS-和-IN的区分"><a href="#EXISTS-和-IN的区分" class="headerlink" title="EXISTS 和 IN的区分"></a>EXISTS 和 IN的区分</h3><p>优化的时候还是要遵循小表驱动大表来的</p><p>例如：SELECT * FROM A WHERE A.id IN (SELECT code FROM B)</p><p>这种情况B的数据量小，就是一个小表驱动大表的例子。如果A表的数据量小，那么这个SQL就可以改为<br> SELECT * FROM A WHERE EXISTS (SELECT code FROM B WHERE B.code &#x3D; A.id)</p><p>优化的关键在于AB两表谁大谁小</p><h3 id="COUNT相关"><a href="#COUNT相关" class="headerlink" title="COUNT相关"></a>COUNT相关</h3><ol><li>count(*) count(1)是差不多的</li><li>使用MyISAM统计行数是O(1)的复杂度，InnoDB是O(n)级别。MyISAM表中有一个meta信息，里面有一个row_count来记录行数。     InnoDB只能全表扫描</li><li>count(具体字段)尽量来采取二级索引，如果是使用了聚集索引，就相当于把数据都在加载到内存中了，使用二级索引占用空间更小。count(*)     count(1)也是自动选一个占用空间更小的二级索引来统计的。</li></ol><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT(*)"></a>SELECT(*)</h3><p>尽量不使用这个原因如下：</p><ol><li>转换的时候会查询数据字典为把*转换为所有列名，大大耗费时间和资源</li><li>无法使用覆盖索引</li></ol><h3 id="LIMIT-1-优化"><a href="#LIMIT-1-优化" class="headerlink" title="LIMIT 1 优化"></a>LIMIT 1 优化</h3><ol><li>普通索引的情况，全表扫描的时候确定结果集只有一条，那么加上LIMIT 1，找到一条就不继续找了， 这样就加快了查询的时间</li><li>如果是使用的唯一索引就无效了</li></ol><h3 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h3><p>只要有可能，在代码中多使用COMMIT，这会释放这些资源：</p><ol><li>回滚段用于恢复数据的信息</li><li>被程序获取的锁</li><li>redo &#x2F; undo     log buffer 中的空间</li><li>管理上述3种资源的花费</li></ol><h2 id="MySQL-ACID特性"><a href="#MySQL-ACID特性" class="headerlink" title="MySQL ACID特性"></a>MySQL ACID特性</h2><ol><li>原子性：事务里面的操作要么都成功，要么都失败</li><li>一致性：一个事务执行前后从一个合法性状态到另一个合法性状态，语意上的合法性，而不是语法性的，和具体的业务是有关的 比如     A余额200 向B转账300，A的余额为-100，这时数据是不一致的，因为你定义了一个状态，余额必须&gt;&#x3D;0。A向B转了50，但是B没有增加，这时数据也是不一致的，因为你定义了一个状态，总额是不变的。</li><li>一个事务的执行是不能被其他事务干扰，一个事务内部的操作和使用的数据对并发的其他事务是隔离的，并发的事务是互不干扰的。</li><li>持久性：事务提交的时候，他对数据库中数据的改变是永久性的。</li></ol><p>总结：原子性是基础，隔离性是手段，一致性是约束条件，持久性是目的。</p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271830719.png" alt="21" style="zoom: 33%;" /><h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><h3 id="没有redo-log的时候两个问题"><a href="#没有redo-log的时候两个问题" class="headerlink" title="没有redo log的时候两个问题"></a>没有redo log的时候两个问题</h3><ol><li>修改量和刷盘的工作量不成正比，修改几条数据，但是刷盘的时候是以页为单位的，一次刷16KB</li><li>刷盘是一个随机IO过程</li></ol><p>一个优化的思路就是，修改数据之后先不刷盘，先记录一下修改了那些内容，比如把XX表空间XX页的XX行数据从XX修改为XX。InnoDB采用了WAL技术，也就是先写日志再写磁盘，只有日志写成功了，才算事务执行成功了。日志就是redo log，然后未刷盘的脏数据在MySQL崩溃的时候会丢失，没关系的，redo log可以恢复。</p><p>好处：</p><ol><li>降低了刷盘频率</li><li>redo log占用的空间小</li></ol><p>特点：</p><ol><li>redo log 是顺序写入的</li><li>事务执行的时候，redo     log是不断记录的</li></ol><p>redo log的组成</p><p>可以简单分为两个部分</p><ol><li>redo log buffer保存在内存中，是易失性的，服务启动的时候申请的一大片空间，是由多个redo log block组成的，一个block512kb，可以通过innodb_log_buffer_size设置redo     log buffer大小，默认16m，最大4GB，最小1m。 </li><li>redo log     file是在磁盘的，是持久的</li></ol><h3 id="更新数据redo-log的流转过程"><a href="#更新数据redo-log的流转过程" class="headerlink" title="更新数据redo log的流转过程"></a>更新数据redo log的流转过程</h3><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271834659.png" alt="12121"></p><ol><li>加载磁盘的数据页到内存buffer pool中</li><li>更新数据</li><li>WAL 先在内存中写redo log</li><li>把redo log     buffer写入到redo log file</li><li>定期刷脏数据</li></ol><p>redo log的刷盘策略：</p><p>redo log buffer 刷盘不是真的刷到磁盘中去，而是刷入到文件缓存中page cache中。真正的写入是由操作系统来决定的。redo log日志有3种策略刷盘。innodb_flush_log_ad_trx_commit来配置。</p><ol><li>设置为0，提交事务的时候不刷盘，系统默认 master thread 线程每秒一次同步</li><li>设置为1，提交事务立即刷盘 默认值</li><li>设置为2，提交事务的时候把redo log     buffer 写入到page cache中，然后由os决定刷盘时机</li></ol><p>redo log block 由日志头 数据区 日志尾3部分组成，分别为12 492 8字节，总计512字节。机械磁盘一个扇区也是512字节，所以磁盘对一个block的写入是原子性的。</p><p>redo log file相关参数设置：</p><ol><li>innodb_log_group_home_dir，redo log file存放的路径，这个路径有两个文件     ib_logfile0 ib_logfile1</li><li>innodb_log_files_in_group     redo log 文件个数</li><li>innodb_log_file_size     单个redo log文件大小，默认48M，如果写满了从头覆盖</li></ol><p>总结：redo log保证了事务的持久性</p><h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>undo log是事务原子性和一致性的保证，在事务更新数据的前置操作是写入到一个undo log的。</p><p>事务要保证原子性，要么都完成，要么都失败，但是有时候会出现执行到一半的情况。</p><ol><li>服务器本身的错误，比如操作系统错误，断电等等</li><li>输入rollback指令</li></ol><p> 针对这些情况，我们需要回滚数据，具体怎么回滚我们需要记录一下操作执行之前的数据情况。比如insert的时候，记录一下这个数据的主键，然后回滚的时候根据这个主键去删除数据。MySQL把这些为了回滚记录的内容称为撤销日志（undo log）。undo log的产生，会让redo log 产生，因为undo log也要持久化的保证。</p><p>Undo Log的作用：</p><ol><li>回滚数据，只是逻辑层面来恢复数据</li><li>MVCC，用户读取一行数据的时候，如果数据被其他线程锁定了，通过读取undo log之前的行信息，来做到非锁定读取</li></ol><p>Undo Log的生命周期，假如有两个值A&#x3D;1，B&#x3D;2，修改为3，4</p><ol><li>start transaction</li><li>记录A&#x3D;1到undo log</li><li>修改数据 A&#x3D;3</li><li>记录A&#x3D;3到redo log</li><li>记录B&#x3D;2到undo log</li><li>修订B&#x3D;4</li><li>记录B&#x3D;4到redo log</li><li>把redo log刷入磁盘</li><li>commit</li></ol><p>1-8任意时刻宕机都不会影响，因为事务没提交，事务不会影响到磁盘的数据</p><p>8-9之间宕机，恢复之后可以回滚，也可继续完成事务的提交，因为redo log已经持久化了</p><p>在9之后宕机，没关系，可以根据redo log恢复数据，刷到磁盘</p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271838881.png" alt="2121" style="zoom:50%;" /><h2 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a>MVCC实现</h2><h3 id="MVCC的核心：隐藏字段-undo-log-readview"><a href="#MVCC的核心：隐藏字段-undo-log-readview" class="headerlink" title="MVCC的核心：隐藏字段 undo log readview"></a>MVCC的核心：隐藏字段 undo log readview</h3><p>两个隐藏字段 trx_id roll_pointer，undo log串成链</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271839807.png" alt="2121111"></p><p>什么是readview？就是事务A在使用MVCC的时候进行快照读的时候产生的读试图。事务启动的时候，会产生当前数据库的快照，InnoDB为每个事务构建了一个数组用来放置所有的活跃的事务ID（启动了，但没起胶）</p><h3 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h3><ol><li>读未提交的时候， 直接读取最新的数据</li><li>串行化的时候用锁来访问记录</li><li>使用可重复读和读已提交，都必须保证可以读到已经提交的事务修改的数据，核心问题是版本链中的数据哪些是对当前事务可见的</li></ol><h3 id="ReadView组成："><a href="#ReadView组成：" class="headerlink" title="ReadView组成："></a>ReadView组成：</h3><ol><li>creator_trx_id     创建这个ReadView的事务ID</li><li>trx_ids，当前活跃的事务id，是个数组</li><li>up_limit_trx_id 活跃事务最小的ID</li><li>low_limit_trx_id 系统分配给下一个事务的id</li></ol><h3 id="ReadView的规则-："><a href="#ReadView的规则-：" class="headerlink" title="ReadView的规则 ："></a>ReadView的规则 ：</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见 </p><ol><li><p>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问     它自己修改过的记录，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id     值，表明生成该版本的事务在当前     事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id     值，表明生成该版本的事     务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </p></li><li><p>如果被访问版本的trx_id属性值在ReadView的 up_limit_id     和 low_limit_id     之间，那就需要判     断一下trx_id属性值是不是在 trx_ids 列表中。 </p></li><li><ol><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ol></li></ol><h3 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h3><ol><li>获取自己的事务ID</li><li>获取ReadView</li><li>查询得到的数据，和ReadView中的事务版本号比较</li><li>不符合ReadView规则，从undo     log链中获取数据</li><li>返回数据</li></ol><p>MVCC是通过undo log链+ReadView进行数据读取，ReadView规则帮助我们判断当前版本的数据是否可见，undo log链是保存了历史数据。</p><p>读已提交隔离级别的时候，每一次读取是重新获取一次ReadView。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203271840516.png" alt="111131"></p><p>因此每次获取到的ReadView可能是不同的，那么就可能会出现不可重复读和幻读。</p><p>可重复读的时候，事务在第一次SELECT的时候生成一个ReadView，这样的话，在这个事务的生命期间，后面所有的SELECT都是用的这个ReadView。</p><h3 id="MVCC带来了什么"><a href="#MVCC带来了什么" class="headerlink" title="MVCC带来了什么"></a>MVCC带来了什么</h3><ol><li>解决了读写互斥问题，提高了并发能力</li><li>降低了死锁概率，读取不加锁，写加行锁</li><li>解决了快照读问题，查询某个时间点的数据，只能查看这个时间点之前提交的事务的数据</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;explain执行计划的几种坏情况&quot;&gt;&lt;a href=&quot;#explain执行计划的几种坏情况&quot; class=&quot;headerlink&quot; title=&quot;explain执行计划的几种坏情况&quot;&gt;&lt;/a&gt;explain执行计划的几种坏情况&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Usin</summary>
      
    
    
    
    <category term="DB" scheme="http://example.com/categories/DB/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码分析</title>
    <link href="http://example.com/2022/03/25/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/25/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-24T16:54:01.000Z</published>
    <updated>2022-03-25T09:19:08.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="容器和Bean"><a href="#容器和Bean" class="headerlink" title="容器和Bean"></a>容器和Bean</h2><h3 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h3><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BaanFacroty是什么</p><ol><li>是ApplicationContext的父接口</li><li>他才是Spring的核心容器，ApplicationContext「实现」组合了他的功能，也就是ApplicationContext组合了BeanFactory</li></ol><p>BeanFactory的功能</p><ol><li>表面上看只有一个getBean</li><li>实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能, 都由它的实现类提供</li></ol><h4 id="ApplicationContext的拓展功能"><a href="#ApplicationContext的拓展功能" class="headerlink" title="ApplicationContext的拓展功能"></a>ApplicationContext的拓展功能</h4><p>ApplicationContext是BeanFactory的实现，然后还实现了其他的几个接口，这相当于在BeanFactory的基础上拥有了其他的能力，ApplicationContext实现了这些接口之后就有了以下的能力。</p><ol><li>处理国际化资源能力</li><li>对通配符匹配资源「类路径磁盘路径等」的能力</li><li>事件发布能力</li><li>环境信息读取能力</li></ol><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203251131753.png" alt="image-20220325113157729"></p><h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><h4 id="BeanFactory实现的特点"><a href="#BeanFactory实现的特点" class="headerlink" title="BeanFactory实现的特点"></a>BeanFactory实现的特点</h4><p>DefaultListableBeanFactory，BeanFacroty的核心实现，通过Bean的描述信息BeanDefination类「class，scope，初始化，销毁」来创建Bean，管理Bean的整个生命周期。</p><p>可是对DefaultListableBeanFactory增加一些Bean工厂的后置处理器补充一下 Bean定义，针对Bean有一些Bean的后置，给Bean的生命周期个个阶段提供扩展，例如InternalAutowiredAnnotationProcessor 给Bean自动填充。</p><p>BeanFactory不会做的事情：</p><ol><li>不会主动调用 BeanFactory 后处理器</li><li>不会主动添加Bean后置处理器</li><li>不会主动解析单例 也就是不会提前创建 只有用的时候才会创建</li><li>不会解析beanFactory 还不会解析 ${} 与 #{}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// bean 的定义（class, scope, 初始化, 销毁）</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">                BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(<span class="string">&quot;singleton&quot;</span>).getBeanDefinition();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给 BeanFactory 添加一些常用的后处理器</span></span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanFactory 后处理器主要功能，补充了一些 bean 定义</span></span><br><span class="line">        beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -&gt; &#123;</span><br><span class="line">            beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bean 后处理器, 针对 bean 的生命周期的各个阶段提供扩展, 例如 @Autowired @Resource ...</span></span><br><span class="line">        beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream()</span><br><span class="line">                .sorted(beanFactory.getDependencyComparator())</span><br><span class="line">                .forEach(beanPostProcessor -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&quot;</span> + beanPostProcessor);</span><br><span class="line">            beanFactory.addBeanPostProcessor(beanPostProcessor);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beanFactory.preInstantiateSingletons(); <span class="comment">// 准备好所有单例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span></span><br><span class="line">        System.out.println(beanFactory.getBean(Bean1.class).getInter());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            学到了什么:</span></span><br><span class="line"><span class="comment">            a. beanFactory 不会做的事</span></span><br><span class="line"><span class="comment">                  bu</span></span><br><span class="line"><span class="comment">                   2. 不会主动添加 Bean 后处理器</span></span><br><span class="line"><span class="comment">                   3. 不会主动初始化单例</span></span><br><span class="line"><span class="comment">                   4. 不会解析beanFactory 还不会解析 $&#123; &#125; 与 #&#123; &#125;</span></span><br><span class="line"><span class="comment">            b. bean 后处理器会有排序的逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Common:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Autowired:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext的常见实现和特点"><a href="#ApplicationContext的常见实现和特点" class="headerlink" title="ApplicationContext的常见实现和特点"></a>ApplicationContext的常见实现和特点</h4><ol><li><p>ClassPathXmlApplicationContext基于 classpath 下 xml 格式的配置文件来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassPathXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;a02.xml&quot;</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">           System.out.println(name);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>FileSystemXmlApplicationContext 基于磁盘路径下 xml 格式的配置文件来创建 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(</span><br><span class="line">                       <span class="string">&quot;src\\main\\resources\\a02.xml&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">           System.out.println(name);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>AnnotationConfigApplicationContext 较为经典的容器, 基于 java 配置类来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>AnnotationConfigServletWebServerApplicationContext较为经典的容器, 基于 java 配置类来创建, 用于 web 环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">      <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">          System.out.println(name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>一个受 Spring 管理的 bean，生命周期主要阶段有</p><ol><li>创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象</li><li>依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系</li><li>初始化：回调各种 Aware 接口，调用对象的各种初始化方法</li><li>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）<ul><li>prototype 对象也能够销毁，不过需要容器这边主动调用</li></ul></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring源码分析&quot;&gt;&lt;a href=&quot;#Spring源码分析&quot; class=&quot;headerlink&quot; title=&quot;Spring源码分析&quot;&gt;&lt;/a&gt;Spring源码分析&lt;/h1&gt;&lt;h2 id=&quot;容器和Bean&quot;&gt;&lt;a href=&quot;#容器和Bean&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud OpenFeign源码分析</title>
    <link href="http://example.com/2022/03/24/SpringCloud-OpenFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/24/SpringCloud-OpenFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-24T03:56:36.000Z</published>
    <updated>2022-03-24T16:46:14.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud-OpenFeign源码分析"><a href="#SpringCloud-OpenFeign源码分析" class="headerlink" title="SpringCloud OpenFeign源码分析"></a>SpringCloud OpenFeign源码分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="OpenFeign简介"><a href="#OpenFeign简介" class="headerlink" title="OpenFeign简介"></a>OpenFeign简介</h3><h4 id="官网说明"><a href="#官网说明" class="headerlink" title="官网说明"></a>官网说明</h4><p>Declarative REST Client: Feign creates a dynamic implementation of an interface decorated with JAX-RS or Spring MVC annotations</p><p>声明式 REST 客户端：Feign 通过 JAX-RS 或 Spring MVC 注解装饰的方式，生成接口的动态实现</p><h4 id="综合说明"><a href="#综合说明" class="headerlink" title="综合说明"></a>综合说明</h4><p>官网这段话什么意思？OpenFeign可以将提供者的Restful服务伪装成为接口进行消费，消费者只需要使用 feign接口+注解即可调用提供者的服务，无需RestTemplate。</p><p>注意： OpenFeign只和消费者有关，和提供者没有任何关系。</p><h4 id="Ribbon和OpenFeign"><a href="#Ribbon和OpenFeign" class="headerlink" title="Ribbon和OpenFeign"></a>Ribbon和OpenFeign</h4><p>OpenFeign默认集成了Ribbon作为负载均衡组件，OpenFeign是工作在客户端的使用，在发起RPC使用的就是Ribbon的负载均衡功能。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="重要注解解析"><a href="#重要注解解析" class="headerlink" title="重要注解解析"></a>重要注解解析</h3><h4 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h4><p>在SpringBoot中存在大量的@EnableXxx这种注解。它们的作用是，开启某项功能。其实它们本质上是为了导入某个类来完成某项功能。所以这个注解一般会组合一个@Import注解用于导入类。导入的类一般有三种：</p><ol><li>配置类：一般以Configuration结尾，完成自动配置</li><li>选择器：一般以Selector结尾，完成自动选择</li><li>注册器：一般以Registrar结尾，完成自动注册</li></ol><p>这里的@EnableFeignClients就是扫描那些申明为@FeignClient的接口，然后import一个自动注册Bean，把@FeignClient的类注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans for interfaces that declare they are feign clients (via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.cloud.openfeign.FeignClient&#125; &lt;code&gt;<span class="doctag">@FeignClient</span>&lt;/code&gt;).</span></span><br><span class="line"><span class="comment"> * Configures component scanning directives for use with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.annotation.Configuration&#125;</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;<span class="doctag">@Configuration</span>&lt;/code&gt; classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 导入一个类</span></span><br><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment"> * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(&quot;org.my.pkg&quot;)&#125; instead of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages=&quot;org.my.pkg&quot;)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array of &#x27;basePackages&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages to scan for annotated components.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #value()&#125; is an alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment"> * package names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array of &#x27;basePackages&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 扫描的基本包</span></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment"> * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment"> * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the array of &#x27;basePackageClasses&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 扫描某个Bean所在包下所有的FeignClients</span></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A custom &lt;code&gt;<span class="doctag">@Configuration</span>&lt;/code&gt; for all feign clients. Can contain override</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;<span class="doctag">@Bean</span>&lt;/code&gt; definition for the pieces that make up the client, for instance</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> feign.codec.Decoder&#125;, &#123;<span class="doctag">@link</span> feign.codec.Encoder&#125;, &#123;<span class="doctag">@link</span> feign.Contract&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FeignClientsConfiguration for the defaults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list of default configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 导入一些自定义的 Feign需要的配置类</span></span><br><span class="line">Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List of classes annotated with <span class="doctag">@FeignClient</span>. If not empty, disables classpath</span></span><br><span class="line"><span class="comment"> * scanning.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list of FeignClient classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 指定有@FeignClient注解的接口，可以是多个，启用后不再包扫描</span></span><br><span class="line">Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h4><p>详细见注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FeignClient &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of the service with optional protocol prefix. Synonym for &#123;<span class="doctag">@link</span> #name()</span></span><br><span class="line"><span class="comment"> * name&#125;. A name must be specified for all clients, whether or not a url is provided.</span></span><br><span class="line"><span class="comment"> * Can be specified as property key, eg: $&#123;propertyKey&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the name of the service with optional protocol prefix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// value 就是要消费的微服务提供者的名称 默认是HTTP 必须指定</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The service id with optional protocol prefix. Synonym for &#123;<span class="doctag">@link</span> #value() value&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> use &#123;<span class="doctag">@link</span> #name() name&#125; instead</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the service id with optional protocol prefix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">String <span class="title function_">serviceId</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This will be used as the bean name instead of name if present, but will not be used</span></span><br><span class="line"><span class="comment"> * as a service id.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bean name instead of name if present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">//  优先级高于 name value serviceId 其实也是指定服务名称</span></span><br><span class="line">String <span class="title function_">contextId</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The service id with optional protocol prefix. Synonym for &#123;<span class="doctag">@link</span> #value()</span></span><br><span class="line"><span class="comment"> * value&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the &lt;code&gt;<span class="doctag">@Qualifier</span>&lt;/code&gt; value for the feign client.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 给FeignClient指定一个名字 避免多个FeignClient存在的时候因为同名 注入失败</span></span><br><span class="line">String <span class="title function_">qualifier</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an absolute URL or resolvable hostname (the protocol is optional).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 要访问的服务的Host，这里就是直连而不是负载均衡了</span></span><br><span class="line">String <span class="title function_">url</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether 404s should be decoded instead of throwing FeignExceptions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">decode404</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A custom configuration class for the feign client. Can contain override</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;<span class="doctag">@Bean</span>&lt;/code&gt; definition for the pieces that make up the client, for instance</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> feign.codec.Decoder&#125;, &#123;<span class="doctag">@link</span> feign.codec.Encoder&#125;, &#123;<span class="doctag">@link</span> feign.Contract&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FeignClientsConfiguration for the defaults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list of configurations for feign client</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] configuration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fallback class for the specified Feign client interface. The fallback class must</span></span><br><span class="line"><span class="comment"> * implement the interface annotated by this annotation and be a valid spring bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> fallback class for the specified Feign client interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// fallback类</span></span><br><span class="line">Class&lt;?&gt; fallback() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a fallback factory for the specified Feign client interface. The fallback</span></span><br><span class="line"><span class="comment"> * factory must produce instances of fallback classes that implement the interface</span></span><br><span class="line"><span class="comment"> * annotated by &#123;<span class="doctag">@link</span> FeignClient&#125;. The fallback factory must be a valid spring bean.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> feign.hystrix.FallbackFactory for details.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> fallback factory for the specified Feign client interface</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">Class&lt;?&gt; fallbackFactory() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> path prefix to be used by all method-level mappings. Can be used with or</span></span><br><span class="line"><span class="comment"> * without &lt;code&gt;<span class="doctag">@RibbonClient</span>&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 用path就不用@RequestMapping 方法级别的mapping</span></span><br><span class="line">String <span class="title function_">path</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether to mark the feign proxy as a primary bean. Defaults to true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 如果一个FeignClient有多个实现类，用这个来标记就会优先注入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">primary</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要API解析"><a href="#重要API解析" class="headerlink" title="重要API解析"></a>重要API解析</h3><h4 id="FeignClientSpecification类"><a href="#FeignClientSpecification类" class="headerlink" title="FeignClientSpecification类"></a>FeignClientSpecification类</h4><p>FeignClientSpecification是一个FeignClient生成规范，他是NamedContextFactory.Specification的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specification with name and configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// SpringCloud的规范</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span> &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] getConfiguration();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BeanDefination接口"><a href="#BeanDefination接口" class="headerlink" title="BeanDefination接口"></a>BeanDefination接口</h4><p>是一个Bean定义器，是一个Bean的定义，描述了一个Bean的各种属性，可以根据它生成一个Bean。</p><h4 id="BeanDefinationRegistry接口"><a href="#BeanDefinationRegistry接口" class="headerlink" title="BeanDefinationRegistry接口"></a>BeanDefinationRegistry接口</h4><p>BeanDefinationRegistry是BeanDefination的注册器，把BeanDefination注册到map，通过名称获取BeanDefination。</p><h4 id="FeignContext"><a href="#FeignContext" class="headerlink" title="FeignContext"></a>FeignContext</h4><p>一个典型的上下文，是一个子容器，每个FeignClient有一个子容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignContext</span> <span class="keyword">extends</span> <span class="title class_">NamedContextFactory</span>&lt;FeignClientSpecification&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FeignContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(FeignClientsConfiguration.class, <span class="string">&quot;feign&quot;</span>, <span class="string">&quot;feign.client.name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstanceWithoutAncestors</span><span class="params">(String name, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BeanFactoryUtils.beanOfType(getContext(name), type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Map&lt;String, T&gt; <span class="title function_">getInstancesWithoutAncestors</span><span class="params">(String name, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getContext(name).getBeansOfType(type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add javadoc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">NamedContextFactory</span>&lt;C <span class="keyword">extends</span> <span class="title class_">NamedContextFactory</span>.Specification&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">DisposableBean</span>, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertyName;</span><br><span class="line"><span class="comment">// 该map的key我FeignClient名称 其所要调用的微服务名</span></span><br><span class="line">    <span class="comment">// value为组装这个FeignClient所必须的组件所在的Spring子容器</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 这个map是存放@EnableFeignClients和@FeignClient两个注解中的Configuration属性值</span></span><br><span class="line">    <span class="comment">// 这个属性值只有两类 第一类只有一个其key为字符串 default+当前启动类全限定类名</span></span><br><span class="line">    <span class="comment">// 例如default.com.abc.Comsumer8080 value为@EnableFeignClients的default Configuration属性值</span></span><br><span class="line">    <span class="comment">// 第二类有多个key = 当前@FeignClient名称，value为这个client的注解的configuration属性值</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FeignClient创建"><a href="#FeignClient创建" class="headerlink" title="FeignClient创建"></a>FeignClient创建</h3><h4 id="FeignClient自动注册"><a href="#FeignClient自动注册" class="headerlink" title="FeignClient自动注册"></a>FeignClient自动注册</h4><p>在@EnableFeignClients里面有一个@Import(FeignClientsRegistrar.class)，导入了这个注册类，他是ImportBeanDefinitionRegistrar接口实现类，里面有一个registerBeanDefinations方法，也就是把FeignClient注册到Spring的map中，交给容器来管理。我们看一下怎么做的</p><ol><li>将@EnableFeignClients直接中的defaultConfiguration注册到一个缓存map</li><li>完成了3项工作<ol><li>扫描所有的带了@FeignClient的接口</li><li>将每个@FeignClient注解的defaultConfiguration注册到一个map</li><li>根据@FeignClient注解元数据生成一个FeignClientFactoryBean的BeanDefination 并将这个BeanDefination放入一个map</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">       </span><br><span class="line">registerDefaultConfiguration(metadata, registry);</span><br><span class="line">registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RegisterDefaultConfiguration方法分析"><a href="#RegisterDefaultConfiguration方法分析" class="headerlink" title="RegisterDefaultConfiguration方法分析"></a>RegisterDefaultConfiguration方法分析</h5><p> 进入这个方法内部先分析参数metadata和registry</p><ul><li>metadata 包含了@EnableFeignClients和@SpringBootApplication两个注解的元数据</li><li>registry  BeanDefination注册器</li></ul><p>经过registerDefaultConfiguration方法，FeignClientSpecification的BeanDefination就被注册到了map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取到EnableFeignClients注解的属性值 </span></span><br><span class="line">Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">           <span class="comment">// 第二个属性把class类变为了string属性</span></span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defaultAttrs != <span class="literal">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line">           <span class="comment">// 如果当前注解所标注的类为闭合类</span></span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 注册这个defaultConfiguration的属性</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体如何注册</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span><br><span class="line"><span class="params">Object configuration)</span> &#123;</span><br><span class="line">       <span class="comment">// 先生成一个Builder 然后利用这个Builder生成一个FeignClientSpecification 的BeanDefination</span></span><br><span class="line">       <span class="comment">// 也就是一个FeignClient的生成规范 为将来的FeignClient生成提供规范</span></span><br><span class="line"><span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">builder.addConstructorArgValue(name);</span><br><span class="line">builder.addConstructorArgValue(configuration);</span><br><span class="line">       <span class="comment">// 把这个BeanDefination注册到Map中去 </span></span><br><span class="line">registry.registerBeanDefinition(</span><br><span class="line">name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RegisterFeignClients方法分析"><a href="#RegisterFeignClients方法分析" class="headerlink" title="RegisterFeignClients方法分析"></a>RegisterFeignClients方法分析</h5><p>第一步注册了FeignClient的定义信息，接下来就开始分析注册FeignClient。 就是扫描标记了@FeignClient的接口放入候选组件集合中，如果@EnableFeignClients注解里面有clients属性，就把这些接口添加进去，不进行包扫描了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个扫描器</span></span><br><span class="line"><span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">scanner</span> <span class="operator">=</span> getScanner();</span><br><span class="line">scanner.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; basePackages;</span><br><span class="line"><span class="comment">// 获取到@EnableFeignClient的属性</span></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">    <span class="comment">// 为扫描器添加一个扫描@FeignClient的过滤器</span></span><br><span class="line"><span class="type">AnnotationTypeFilter</span> <span class="variable">annotationTypeFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">FeignClient.class);</span><br><span class="line">   <span class="comment">// 获取里面的clients属性 如果不为空就禁用类路径扫描</span></span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="literal">null</span> ? <span class="literal">null</span></span><br><span class="line">: (Class&lt;?&gt;[]) attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (clients == <span class="literal">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">            <span class="comment">// 获取@EnableFeignClients直接指定的基本包 就是那几个指定FeignClient所在包的属性 （value basePackages）</span></span><br><span class="line">            <span class="comment">// 获取的结果就是注解中指定的FeignClient所在包的path，并用Set装起来</span></span><br><span class="line">            <span class="comment">// 如果都没有的话 则添加当前注解标注的类所在的包添加进去</span></span><br><span class="line">basePackages = getBasePackages(metadata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 指定了clients属性 不进行包扫描 直接放入</span></span><br><span class="line"><span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">basePackages = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">AbstractClassTestingTypeFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractClassTestingTypeFilter</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(ClassMetadata metadata)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">cleaned</span> <span class="operator">=</span> metadata.getClassName().replaceAll(<span class="string">&quot;\\$&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">scanner.addIncludeFilter(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AllTypeFilter</span>(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历这些基本包 将其中的@FeignClient标记的接口找到 放入候选组件里面</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">.findCandidateComponents(basePackage);</span><br><span class="line">            <span class="comment">// 遍历这些候选组件 放入map中</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="comment">// 只处理由@FeignClient标注的</span></span><br><span class="line"><span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// verify annotated class is an interface</span></span><br><span class="line"><span class="type">AnnotatedBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    <span class="comment">// 获取注解元数据</span></span><br><span class="line"><span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">                    <span class="comment">// 断言是一个接口 </span></span><br><span class="line">Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line"><span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line"><span class="comment">// 获取注解属性</span></span><br><span class="line">Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">.getAnnotationAttributes(</span><br><span class="line">FeignClient.class.getCanonicalName());</span><br><span class="line"><span class="comment">// 获取client name 比如微服务名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getClientName(attributes);</span><br><span class="line">                    <span class="comment">//  注册接口的configuration属性对应的配置类到map</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line"><span class="comment">// 将FeignClientFactoryBean的BeanDefination注册到map</span></span><br><span class="line">registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FeignClient自动配置"><a href="#FeignClient自动配置" class="headerlink" title="FeignClient自动配置"></a>FeignClient自动配置</h4><p>前面自动注册的代码我们是从注解下手，接下来我们要从spring.factories下手，因为OpenFeign作为一个SpringBoot程序，一定是有自动配置类的，我们通过这个自动配置类就可以研究出来OpenFeign是怎么完成自动配置的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241951955.png" alt="image-20220324195148905"></p><p>我们先看FeignAutoConfiguration自动配置类，首先是创建Feign的上下文， 里面有一个容器，容器里面是两个Map，第一个是存放Feign需要的组件，用的是子容器，另一个是放配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是创建Feign的上下文</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FeignContext <span class="title function_">feignContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">FeignContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FeignContext</span>();</span><br><span class="line">context.setConfigurations(<span class="built_in">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这两个就是要用的的容器</span></span><br><span class="line"><span class="comment">// key -&gt; FeignClient名字 value -&gt; 子容器</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">// 这个map是存放@EnableFeignClients和@FeignClient两个注解中的Configuration属性值</span></span><br><span class="line">   <span class="comment">// 这个属性值只有两类 第一类只有一个其key为字符串 default+当前启动类全限定类名</span></span><br><span class="line">   <span class="comment">// 例如default.com.abc.Comsumer8080 value为@EnableFeignClients的default Configuration属性值</span></span><br><span class="line">   <span class="comment">// 第二类有多个key = 当前@FeignClient名称，value为这个client的注解的configuration属性值</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>我们启动之后，创建好context之后，configurations就会有两个配置。name为default+启动类的全限定类名和name为微服务名称的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203242022931.png" alt="image-20220324202236900"></p><h4 id="FeignClient创建-1"><a href="#FeignClient创建-1" class="headerlink" title="FeignClient创建"></a>FeignClient创建</h4><p>我们之前把FeignClientFactoryBean的DefinationBean注册到了map中，所以这个工厂Bean就可以为我们生产FeignClient了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context</span></span><br><span class="line"><span class="comment"> * information</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">// org.springframework.cloud.openfeign.FeignClientFactoryBean#getTarget</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 启动的时候已经有FeignContext了</span></span><br><span class="line"><span class="type">FeignContext</span> <span class="variable">context</span> <span class="operator">=</span> applicationContext.getBean(FeignContext.class);</span><br><span class="line">       <span class="comment">// 从子容器中获取一个Builder</span></span><br><span class="line">Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> feign(context);</span><br><span class="line"><span class="comment">// 如果URL属性为空说明要采用负载均衡方式调用</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(url)) &#123;</span><br><span class="line">           <span class="comment">// 不是以http开头的加上http</span></span><br><span class="line"><span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">url = <span class="string">&quot;http://&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">url = name;</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 获得一个规范的url</span></span><br><span class="line">           <span class="comment">// 不是以/开头的path加上/ 以/结尾的path删除末尾的/</span></span><br><span class="line">url += cleanPath();</span><br><span class="line">           <span class="comment">// 返回一个负载均衡调用</span></span><br><span class="line"><span class="keyword">return</span> (T) loadBalance(builder, context,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(type, name, url));</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">// 不为空采用直连方式 直接调用提供者</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(url) &amp;&amp; !url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">url = <span class="string">&quot;http://&quot;</span> + url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="built_in">this</span>.url + cleanPath();</span><br><span class="line">       <span class="comment">// 从子容器中获取Client</span></span><br><span class="line"><span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> getOptional(context, Client.class);</span><br><span class="line"><span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line"><span class="comment">// not load balancing because we have a url,</span></span><br><span class="line"><span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">client = ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> FeignBlockingLoadBalancerClient) &#123;</span><br><span class="line"><span class="comment">// not load balancing because we have a url,</span></span><br><span class="line"><span class="comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span></span><br><span class="line">client = ((FeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line">&#125;</span><br><span class="line">builder.client(client);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Targeter</span> <span class="variable">targeter</span> <span class="operator">=</span> get(context, Targeter.class);</span><br><span class="line"><span class="keyword">return</span> (T) targeter.target(<span class="built_in">this</span>, builder, context,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(type, name, url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从子容器中获取组件</span></span><br><span class="line"><span class="keyword">protected</span> Feign.Builder <span class="title function_">feign</span><span class="params">(FeignContext context)</span> &#123;</span><br><span class="line"><span class="type">FeignLoggerFactory</span> <span class="variable">loggerFactory</span> <span class="operator">=</span> get(context, FeignLoggerFactory.class);</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> loggerFactory.create(type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @formatter:off</span></span><br><span class="line">Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> get(context, Feign.Builder.class)</span><br><span class="line"><span class="comment">// required values</span></span><br><span class="line">.logger(logger)</span><br><span class="line">.encoder(get(context, Encoder.class))</span><br><span class="line">.decoder(get(context, Decoder.class))</span><br><span class="line">.contract(get(context, Contract.class));</span><br><span class="line"><span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从当前FeignClient的子容器中获取指定类型的实例</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(FeignContext context, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">       <span class="comment">// 从FeignClient的上下文中的context中的contexts中指定feign名称contextId的子容器中获取指定type实例</span></span><br><span class="line"><span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> context.getInstance(contextId, type);</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;No bean found of type &quot;</span> + type + <span class="string">&quot; for &quot;</span> + contextId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们分析FeignClient是怎么被创建出来的，也就是上面代码段的第25行，我们接着进入内部方法可以找到feign.Feign.Builder#target(feign.Target<T>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">target</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">    <span class="comment">// key 方法名 value 方法处理器 有几个方法就有几个处理器</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">    <span class="comment">// key 方法 value方法处理器 </span></span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Method, MethodHandler&gt;();</span><br><span class="line">    <span class="comment">// 默认的方法处理器 </span></span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123; <span class="comment">// 如果是默认方法 就放入这个集合</span></span><br><span class="line">      <span class="type">DefaultMethodHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodHandler</span>(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 网络请求就是这里发出</span></span><br><span class="line">  <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> factory.create(target, methodToHandler);</span><br><span class="line">    <span class="comment">// 反射机制创建的Feign JDK动态代理</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">proxy</span> <span class="operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FeignClient发送请求"><a href="#FeignClient发送请求" class="headerlink" title="FeignClient发送请求"></a>FeignClient发送请求</h3><p>上面有个关键信息，FeignClient是通过JDK动态代理创建出来的，然后看到这个InvocationHandler，我们这里肯定是创建了一个和Feign有关的InvocationHandler，所以我们要清楚这个factory.create(target, methodToHandler)到底是创建的什么。</p><p>这里是FeignInvocationHandler的创建方法，dispatch就是上面的methodToHandler，就是一个map key&#x3D;method value&#x3D;方法处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Default</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandlerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> InvocationHandler <span class="title function_">create</span><span class="params">(Target target, Map&lt;Method, MethodHandler&gt; dispatch)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectiveFeign</span>.FeignInvocationHandler(target, dispatch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是FeignInvocationHandler他是InvocationHandler接口的实现类，必然有一个invoke方法来真正调用我们的业务逻辑。这里做的事情就是过滤一些没有必要代理的方法之后，用那个方法处理器map根据具体method选出来的方法处理器来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Target target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map &lt; Method,</span><br><span class="line">    MethodHandler &gt; dispatch;</span><br><span class="line">    FeignInvocationHandler(Target target, Map &lt; Method, MethodHandler &gt; dispatch) &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = checkNotNull(target, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.dispatch = checkNotNull(dispatch, <span class="string">&quot;dispatch for %s&quot;</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">otherHandler</span> <span class="operator">=</span> args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="literal">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排除一些基本方法，然后从dispatch发出请求</span></span><br><span class="line">        <span class="comment">// dispatch就是方法处理器map，根据这个method选出一个方法处理器执行就好了</span></span><br><span class="line">        <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入invoke方法，因为是OpenFeign实现的方法所以我们应该找到feign.SynchronousMethodHandler#invoke，这里首先是通过参数构建出一个请求模版，里面的参数是请求方式，URL之类的调用executeAndDecode方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123; </span><br><span class="line">    <span class="comment">// 通过参数构建一个请求模版 </span></span><br><span class="line">    <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br><span class="line">    <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> findOptions(argv);</span><br><span class="line">    <span class="type">Retryer</span> <span class="variable">retryer</span> <span class="operator">=</span> <span class="built_in">this</span>.retryer.clone();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发起调用</span></span><br><span class="line">            <span class="keyword">return</span> executeAndDecode(template, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RetryableException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                retryer.continueOrPropagate(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(RetryableException th) &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> th.getCause();</span><br><span class="line">                <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> th;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">                logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入executeAndDecode内部，找到关键一行代码 response &#x3D; client.execute(request, options)，这里的Client就是我们要要使用的负载均衡器，如果@FeignClient声明的时候指定了URL，那就是直连方法请求，我们默认是使用的Ribbon的C负载均衡。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203250029330.png" alt="image-20220325002936288"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">executeAndDecode</span><span class="params">(RequestTemplate template, Options options)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> targetRequest(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.execute(request, options);</span><br><span class="line">        <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 12</span></span><br><span class="line">        response = response.toBuilder().request(request).requestTemplate(template).build();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">            logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decoder != <span class="literal">null</span>) <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line"></span><br><span class="line">    CompletableFuture &lt; Object &gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span> &lt; &gt;();</span><br><span class="line">    asyncResponseHandler.handleResponse(resultFuture, metadata.configKey(), response, metadata.returnType(), elapsedTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resultFuture.isDone()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Response handling not done&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultFuture.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CompletionException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="literal">null</span>) <span class="keyword">throw</span> cause;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入response &#x3D; client.execute(request, options)内部，feign.Client.Default#execute方法，因为指定了URL那么就不使用负载均行，而是起一个HTTP连接然后发送请求，获取应答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> convertAndSend(request, options);</span><br><span class="line">    <span class="keyword">return</span> convertResponse(connection, request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h3><p>上面发起请求是直连的情况下，如果要用到Ribbon那么在 response &#x3D; client.execute(request, options)这里使用的Client就不再是默认的Client了，而是 org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient#execute。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URI</span> <span class="variable">asUri</span> <span class="operator">=</span> URI.create(request.url());</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientName</span> <span class="operator">=</span> asUri.getHost();</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uriWithoutHost</span> <span class="operator">=</span> cleanUrl(request.url(), clientName);</span><br><span class="line">        FeignLoadBalancer.<span class="type">RibbonRequest</span> <span class="variable">ribbonRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FeignLoadBalancer</span>.RibbonRequest(<span class="built_in">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line"></span><br><span class="line">        <span class="type">IClientConfig</span> <span class="variable">requestConfig</span> <span class="operator">=</span> getClientConfig(options, clientName);</span><br><span class="line">        <span class="comment">// 发起负载均行模式请求</span></span><br><span class="line">        <span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClientException e) &#123;</span><br><span class="line">        <span class="type">IOException</span> <span class="variable">io</span> <span class="operator">=</span> findIOException(e);</span><br><span class="line">        <span class="keyword">if</span> (io != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> io;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException &#123;</span><br><span class="line">    LoadBalancerCommand &lt; T &gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 选择一个主机发起请求</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(<span class="keyword">new</span> <span class="title class_">ServerOperation</span> &lt; T &gt; () &#123;<span class="meta">@Override</span> <span class="keyword">public</span> Observable &lt; T &gt; call(Server server) &#123;</span><br><span class="line">                <span class="type">URI</span> <span class="variable">finalUri</span> <span class="operator">=</span> reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                <span class="type">S</span> <span class="variable">requestForServer</span> <span class="operator">=</span> (S) request.replaceUri(finalUri);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="built_in">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).toBlocking().single();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ClientException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (ClientException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud-OpenFeign源码分析&quot;&gt;&lt;a href=&quot;#SpringCloud-OpenFeign源码分析&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud OpenFeign源码分析&quot;&gt;&lt;/a&gt;SpringCloud</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="RPC" scheme="http://example.com/tags/RPC/"/>
    
    <category term="SpringCloud" scheme="http://example.com/tags/SpringCloud/"/>
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud GateWay源码分析</title>
    <link href="http://example.com/2022/03/23/SpringCloud-GateWay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/23/SpringCloud-GateWay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-23T08:03:20.000Z</published>
    <updated>2022-03-24T03:34:43.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GateWay工作原理"><a href="#GateWay工作原理" class="headerlink" title="GateWay工作原理"></a>GateWay工作原理</h1><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="Route-路由"><a href="#Route-路由" class="headerlink" title="Route 路由"></a>Route 路由</h3><p>一个请求路径经过网关的一系列的转换得到真正的请求路径，由后面的Predicate和Filter组成。</p><h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p>类似Java8的断言函数，一个请求路径经过一个断言函数，判断出来它是否匹配我们设定好的predicate条件，返回一个Bool。</p><h3 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h3><p>通过断言之后，有一系列的Filter构建成一个Filter Chain进行后置的处理。</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>请求发到网关，先通过处理器映射器找到对应的处理器，然后处理器组装后面一系列的过滤器，然后经过处理器链执行。</p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203232104728.png" alt="image-20220323210445662" style="zoom: 50%;" /><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="配置类解析"><a href="#配置类解析" class="headerlink" title="配置类解析"></a>配置类解析</h3><p>GateWay作为一个SpringBoot程序直接供我们使用，肯定是有一个自动配置类的，我们直接找到GateWay的自动配置类。按照SpringBoot的规定，直接看spring.factories里面的自动配置类。下图标红的第一个是一些警告信息，第二个就是真正的自动配置了，先来观察第一个配置类。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203232213138.png" alt="image-20220323221303108"></p><p>GateWay是基于WebFlux的，如果我们引入的Spring MVC的依赖是会报错的，下面的代码就是原因。我们可以看到第一个方法有一个@ConditionalOnClass(name &#x3D; “org.springframework.web.servlet.DispatcherServlet”)，这个条件注解说明了，如果有DispatcherServlet这个类，就会发出警告信息 和Gateway不兼容，然后看第二个方法@ConditionalOnMissingClass(“org.springframework.web.reactive.DispatcherHandler”)，他的意思就是如果缺少了这个类，那么也会发出警告 这个组件是必须的。其实这个类就是GateWay的一个关键组件，处理器映射器！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(GatewayAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayClassPathWarningAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory</span><br><span class="line">.getLog(GatewayClassPathWarningAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BORDER</span> <span class="operator">=</span> <span class="string">&quot;\n\n**********************************************************\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.springframework.web.servlet.DispatcherServlet&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SpringMvcFoundOnClasspathConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringMvcFoundOnClasspathConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">log.warn(BORDER</span><br><span class="line">+ <span class="string">&quot;Spring MVC found on classpath, which is incompatible with Spring Cloud Gateway at this time. &quot;</span></span><br><span class="line">+ <span class="string">&quot;Please remove spring-boot-starter-web dependency.&quot;</span> + BORDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;org.springframework.web.reactive.DispatcherHandler&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebfluxMissingFromClasspathConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WebfluxMissingFromClasspathConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">log.warn(BORDER + <span class="string">&quot;Spring Webflux is missing from the classpath, &quot;</span></span><br><span class="line">+ <span class="string">&quot;which is required for Spring Cloud Gateway at this time. &quot;</span></span><br><span class="line">+ <span class="string">&quot;Please add spring-boot-starter-webflux dependency.&quot;</span> + BORDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再看GatewayDiscoveryClientAutoConfiguration这个配置类，做的事情就是从配置文件中初始化Predicate，Filter，初始化定位器等等。在启动的时候就吧配置文件里面的东西读取过来注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(GatewayAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(CompositeDiscoveryClientAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DispatcherHandler.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayDiscoveryClientAutoConfiguration</span> &#123;</span><br><span class="line"><span class="comment">// 获取断言</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;PredicateDefinition&gt; <span class="title function_">initPredicates</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;PredicateDefinition&gt; definitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add a predicate that matches the url at /serviceId?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add a predicate that matches the url at /serviceId/**</span></span><br><span class="line">        <span class="comment">// 断言是放在PredicateDefinition里面的</span></span><br><span class="line"><span class="type">PredicateDefinition</span> <span class="variable">predicate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PredicateDefinition</span>();</span><br><span class="line">predicate.setName(normalizeRoutePredicateName(PathRoutePredicateFactory.class));</span><br><span class="line">predicate.addArg(PATTERN_KEY, <span class="string">&quot;&#x27;/&#x27;+serviceId+&#x27;/**&#x27;&quot;</span>);</span><br><span class="line">definitions.add(predicate);</span><br><span class="line"><span class="keyword">return</span> definitions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;FilterDefinition&gt; <span class="title function_">initFilters</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;FilterDefinition&gt; definitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a filter that removes /serviceId by default</span></span><br><span class="line"><span class="type">FilterDefinition</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDefinition</span>();</span><br><span class="line">filter.setName(normalizeFilterFactoryName(RewritePathGatewayFilterFactory.class));</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;&#x27;/&#x27; + serviceId + &#x27;/(?&lt;remaining&gt;.*)&#x27;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replacement</span> <span class="operator">=</span> <span class="string">&quot;&#x27;/$&#123;remaining&#125;&#x27;&quot;</span>;</span><br><span class="line">filter.addArg(REGEXP_KEY, regex);</span><br><span class="line">filter.addArg(REPLACEMENT_KEY, replacement);</span><br><span class="line">definitions.add(filter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> definitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DiscoveryLocatorProperties <span class="title function_">discoveryLocatorProperties</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">DiscoveryLocatorProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscoveryLocatorProperties</span>();</span><br><span class="line">properties.setPredicates(initPredicates());</span><br><span class="line">properties.setFilters(initFilters());</span><br><span class="line"><span class="keyword">return</span> properties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.cloud.discovery.reactive.enabled&quot;,</span></span><br><span class="line"><span class="meta">matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReactiveDiscoveryClientRouteDefinitionLocatorConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.discovery.locator.enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DiscoveryClientRouteDefinitionLocator <span class="title function_">discoveryClientRouteDefinitionLocator</span><span class="params">(</span></span><br><span class="line"><span class="params">ReactiveDiscoveryClient discoveryClient,</span></span><br><span class="line"><span class="params">DiscoveryLocatorProperties properties)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiscoveryClientRouteDefinitionLocator</span>(discoveryClient, properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> In favor of the native reactive service discovery capability.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.cloud.discovery.reactive.enabled&quot;,</span></span><br><span class="line"><span class="meta">havingValue = &quot;false&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BlockingDiscoveryClientRouteDefinitionLocatorConfiguration</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化资源定位器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.cloud.gateway.discovery.locator.enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DiscoveryClientRouteDefinitionLocator <span class="title function_">discoveryClientRouteDefinitionLocator</span><span class="params">(</span></span><br><span class="line"><span class="params">DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiscoveryClientRouteDefinitionLocator</span>(discoveryClient, properties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于Gateway真正的配置类其实就是一些组件的注入而已。</p><h3 id="DispatcherHandler分析"><a href="#DispatcherHandler分析" class="headerlink" title="DispatcherHandler分析"></a>DispatcherHandler分析</h3><p>一个请求发送到Gateway的时候，先触发NioEventLoop#processSelectKey()，这是一个读取请求，所以Key是READ，请求调度器负责请求分发，将请求参数封装成为<code>ServerWebExchange</code> 它的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServerWebExchange</span> <span class="keyword">implements</span> <span class="title class_">ServerWebExchange</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;HttpMethod&gt; SAFE_METHODS = Arrays.asList(HttpMethod.GET, HttpMethod.HEAD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ResolvableType</span> <span class="variable">FORM_DATA_TYPE</span> <span class="operator">=</span></span><br><span class="line">ResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ResolvableType</span> <span class="variable">MULTIPART_DATA_TYPE</span> <span class="operator">=</span> ResolvableType.forClassWithGenerics(</span><br><span class="line">MultiValueMap.class, String.class, Part.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, String&gt;&gt; EMPTY_FORM_DATA =</span><br><span class="line">Mono.just(CollectionUtils.unmodifiableMultiValueMap(<span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String, String&gt;(<span class="number">0</span>)))</span><br><span class="line">.cache();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; EMPTY_MULTIPART_DATA =</span><br><span class="line">Mono.just(CollectionUtils.unmodifiableMultiValueMap(<span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String, Part&gt;(<span class="number">0</span>)))</span><br><span class="line">.cache();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerHttpRequest request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerHttpResponse response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Mono&lt;WebSession&gt; sessionMono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LocaleContextResolver localeContextResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, String&gt;&gt; formDataMono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; multipartDataMono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> notModified;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Function&lt;String, String&gt; urlTransformer = url -&gt; url;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Object logId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">logPrefix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装好了参数之后，请求交给了<code>org.springframework.web.reactive.DispatcherHandler#handle</code> 方法来处理，从这里就开始对应上面的图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> createNotFoundError();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 1.遍历所有的 handlerMapping</span></span><br><span class="line"><span class="keyword">return</span> Flux.fromIterable(<span class="built_in">this</span>.handlerMappings)</span><br><span class="line">  <span class="comment">// 2.获取对应的handlerMapping ，比如常用的 RequestMappingHandlerMapping、RoutePredicateHandlerMapping</span></span><br><span class="line">.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">.next()</span><br><span class="line">.switchIfEmpty(createNotFoundError())</span><br><span class="line"><span class="comment">// 3.获取对应的适配器，调用对应的处理器</span></span><br><span class="line">.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line"><span class="comment">// 4.返回处理结果</span></span><br><span class="line">.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，可以带入SpringMVC的DispatcherServlet#doDispatch来了解。类似MVC，我们在这里会依次调用HandlerMapping，HandlerAdapter，HandlerResultHandler。</p><table><thead><tr><th>框架</th><th>SpringCloud Gateway</th><th>SpringMVC</th></tr></thead><tbody><tr><td>请求分发</td><td>DispatcherHandler</td><td>DispatcherServlet</td></tr><tr><td>请求映射</td><td>HandlerMapping</td><td>HandlerMapping</td></tr><tr><td>请求适配</td><td>HanderAdapter</td><td>HanderAdapter</td></tr><tr><td>请求处理</td><td>WebHandler</td><td>Handler</td></tr></tbody></table><p>HandlerMapping是处理路径到handler的映射，我们点到mapping.getHandler(exchange)内部看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Object&gt; <span class="title function_">getHandler</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getHandlerInternal(exchange).map(handler -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(exchange.getLogPrefix() + <span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"><span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line"><span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (<span class="built_in">this</span>.corsConfigurationSource != <span class="literal">null</span> ? <span class="built_in">this</span>.corsConfigurationSource.getCorsConfiguration(exchange) : <span class="literal">null</span>);</span><br><span class="line"><span class="type">CorsConfiguration</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> getCorsConfiguration(handler, exchange);</span><br><span class="line">config = (config != <span class="literal">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.corsProcessor.process(config, exchange) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line"><span class="keyword">return</span> REQUEST_HANDLED_HANDLER;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class="line"><span class="comment">// don&#x27;t handle requests on management port if set and different than server port</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.managementPortType == DIFFERENT &amp;&amp; <span class="built_in">this</span>.managementPort != <span class="literal">null</span></span><br><span class="line">&amp;&amp; exchange.getRequest().getURI().getPort() == <span class="built_in">this</span>.managementPort) &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上下文设置网关处理mapper这个映 射属性</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class="line"><span class="comment">// 寻找并匹配路由</span></span><br><span class="line"><span class="keyword">return</span> lookupRoute(exchange)</span><br><span class="line"><span class="comment">// .log(&quot;route-predicate-handler-mapping&quot;, Level.FINER) //name this</span></span><br><span class="line">.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(</span><br><span class="line"><span class="string">&quot;Mapping [&quot;</span> + getExchangeDesc(exchange) + <span class="string">&quot;] to &quot;</span> + r);</span><br><span class="line">&#125;</span><br><span class="line">exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class="line"><span class="keyword">return</span> Mono.just(webHandler);</span><br><span class="line">&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No RouteDefinition found for [&quot;</span></span><br><span class="line">+ getExchangeDesc(exchange) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Mono&lt;Route&gt; <span class="title function_">lookupRoute</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.routeLocator.getRoutes()</span><br><span class="line"><span class="comment">// 获取所有路由信息（配置文件）</span></span><br><span class="line">.concatMap(route -&gt; Mono.just(route).filterWhen(r -&gt; &#123;</span><br><span class="line"><span class="comment">// 遍历路由信息</span></span><br><span class="line"><span class="comment">// 根据url和断言条件匹配路由</span></span><br><span class="line"><span class="comment">// gatewayPredicateRouteAttr -&gt; order_route</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());</span><br><span class="line"><span class="comment">// 调用断言工厂，进行路由匹配 这里是断言处理 然后过滤一下 返回一个匹配的路由</span></span><br><span class="line"><span class="keyword">return</span> r.getPredicate().apply(exchange);</span><br><span class="line">&#125;)</span><br><span class="line">.doOnError(e -&gt; logger.error(</span><br><span class="line"><span class="string">&quot;Error applying predicate for route: &quot;</span> + route.getId(),</span><br><span class="line">e))</span><br><span class="line">.onErrorResume(e -&gt; Mono.empty()))</span><br><span class="line">.next()</span><br><span class="line">.map(route -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Route matched: &quot;</span> + route.getId());</span><br><span class="line">&#125;</span><br><span class="line">validateRoute(route, exchange);</span><br><span class="line"><span class="keyword">return</span> route;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值Route的结构如下，其实也就是我yml里面配置的路由。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Route</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URI uri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPredicate&lt;ServerWebExchange&gt; predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; gatewayFilters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置路由：路由id、路由到微服务的uri、断言</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order_route</span>  <span class="comment">#路由ID，全局唯一，建议配合服务名</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://mall-order</span>  <span class="comment">#lb 整合负载均衡器ribbon,loadbalancer</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line"><span class="comment">#       </span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-color,</span> <span class="string">red</span>  <span class="comment">#添加请求头</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestParameter=color,</span> <span class="string">blue</span>   <span class="comment"># 添加请求参数</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PrefixPath=/mall-order</span>  <span class="comment"># 添加前缀 对应微服务需要配置context-path</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CheckAuth=fox,男</span>  <span class="comment">#配置自定义的过滤器工厂</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://mall-user</span>  <span class="comment">#lb 整合负载均衡器ribbon,loadbalancer</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br></pre></td></tr></table></figure><p>上面那行获取所有路由信息的方法this.routeLocator.getRoutes()，一句话就是利用PropertiesRouteDifinationLocator(因为我们是写在配置文件的，所有定位器是基于配置文件)来根据配置文件获取路由定义，然后把路由定义转化为路由信息。</p><p>然后protected Mono<Route> lookupRoute(ServerWebExchange exchange)方法做的事情就是通过RouteLocator找到所有的路由信息，遍历，然后给请求绑定上下文，然后进入org.springframework.cloud.gateway.handler.AsyncPredicate.AndAsyncPredicate#apply异步断言。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241130614.png" alt="11"></p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241131277.png" alt="Untitled"></p><p>来到org.springframework.cloud.gateway.handler.AsyncPredicate.AndAsyncPredicate#apply方法我们看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Publisher&lt;Boolean&gt; <span class="title function_">apply</span><span class="params">(T t)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.just(delegate.test(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入test方法，这里是最终进行断言的地方，也就是调用路由断言工厂开始进行路由断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;PathPattern&gt; pathPatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.pathPatternParser) &#123;</span><br><span class="line">pathPatternParser.setMatchOptionalTrailingSeparator(</span><br><span class="line">config.isMatchOptionalTrailingSeparator());</span><br><span class="line">config.getPatterns().forEach(pattern -&gt; &#123;</span><br><span class="line"><span class="type">PathPattern</span> <span class="variable">pathPattern</span> <span class="operator">=</span> <span class="built_in">this</span>.pathPatternParser.parse(pattern);</span><br><span class="line">pathPatterns.add(pathPattern);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayPredicate</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="comment">// path = /order/findByUserId/1</span></span><br><span class="line"><span class="type">PathContainer</span> <span class="variable">path</span> <span class="operator">=</span> parsePath(</span><br><span class="line">exchange.getRequest().getURI().getRawPath());</span><br><span class="line"><span class="comment">// pathPatterns = /order/** 然后这里正则匹配</span></span><br><span class="line">Optional&lt;PathPattern&gt; optionalPathPattern = pathPatterns.stream()</span><br><span class="line">.filter(pattern -&gt; pattern.matches(path)).findFirst();</span><br><span class="line"><span class="comment">// 如果匹配到了一个就返回一个true </span></span><br><span class="line"><span class="keyword">if</span> (optionalPathPattern.isPresent()) &#123;</span><br><span class="line"><span class="type">PathPattern</span> <span class="variable">pathPattern</span> <span class="operator">=</span> optionalPathPattern.get();</span><br><span class="line">traceMatch(<span class="string">&quot;Pattern&quot;</span>, pathPattern.getPatternString(), path, <span class="literal">true</span>);</span><br><span class="line"><span class="type">PathMatchInfo</span> <span class="variable">pathMatchInfo</span> <span class="operator">=</span> pathPattern.matchAndExtract(path);</span><br><span class="line">putUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">traceMatch(<span class="string">&quot;Pattern&quot;</span>, config.getPatterns(), path, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> String.format(<span class="string">&quot;Paths: %s, match trailing slash: %b&quot;</span>,</span><br><span class="line">config.getPatterns(), config.isMatchOptionalTrailingSeparator());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此结束寻找并匹配路由方法，现在回到getHandlerInternal方法内部，在匹配到了一个路由之后，开始下一步操作，先删掉之前我们设置的旧的路由信息gatewayPredicateRouteAttr，然后添加一个网关路由属性，绑定的就是之前匹配上的那个路由信息 route。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class="line"><span class="comment">// don&#x27;t handle requests on management port if set and different than server port</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.managementPortType == DIFFERENT &amp;&amp; <span class="built_in">this</span>.managementPort != <span class="literal">null</span></span><br><span class="line">&amp;&amp; exchange.getRequest().getURI().getPort() == <span class="built_in">this</span>.managementPort) &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.empty();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 上下文设置网关处理mapper这个映射属性</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class="line">  <span class="comment">// 寻找并匹配路由</span></span><br><span class="line"><span class="keyword">return</span> lookupRoute(exchange)</span><br><span class="line"><span class="comment">// .log(&quot;route-predicate-handler-mapping&quot;, Level.FINER) //name this</span></span><br><span class="line">.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class="line">    <span class="comment">//移除上下文中旧的属性 gatewayPredicateRouteAttr -&gt; order_route</span></span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(</span><br><span class="line"><span class="string">&quot;Mapping [&quot;</span> + getExchangeDesc(exchange) + <span class="string">&quot;] to &quot;</span> + r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定一个网关路由信息 将来会用来做负载均衡。</span></span><br><span class="line"><span class="comment">// gatewayPredicateRouteAttr -&gt; </span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class="line"><span class="comment">// 最后返回一个处理器对象webHandler 交给适配器来处理</span></span><br><span class="line"><span class="keyword">return</span> Mono.just(webHandler);</span><br><span class="line">&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line"><span class="comment">// 如果没找到任何的路由就返回一个空</span></span><br><span class="line">exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No RouteDefinition found for [&quot;</span></span><br><span class="line">+ getExchangeDesc(exchange) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由信息绑定好了如下：</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241132877.png" alt="22"></p><h3 id="调用Handler处理请求"><a href="#调用Handler处理请求" class="headerlink" title="调用Handler处理请求"></a>调用Handler处理请求</h3><p>回到最初的起点，既然已经找到了handler那么就开始处理了，具体的处理逻辑是在invokeHandler()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> createNotFoundError();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 1.遍历所有的 handlerMapping</span></span><br><span class="line"><span class="keyword">return</span> Flux.fromIterable(<span class="built_in">this</span>.handlerMappings)</span><br><span class="line">  <span class="comment">// 2.获取对应的handlerMapping ，比如常用的 RequestMappingHandlerMapping、RoutePredicateHandlerMapping</span></span><br><span class="line">.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">.next()</span><br><span class="line">.switchIfEmpty(createNotFoundError())</span><br><span class="line"><span class="comment">// 3.获取对应的适配器，调用对应的处理器</span></span><br><span class="line">.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line"><span class="comment">// 4.返回处理结果</span></span><br><span class="line">.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入方法内部，可以看到这段代码首先是拿到所有Adapter，这里我们需要的是一个支持WebHandler的SimpleHandlerAdapter来处理。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241132430.png" alt="33"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Mono&lt;HandlerResult&gt; <span class="title function_">invokeHandler</span><span class="params">(ServerWebExchange exchange, Object handler)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter handlerAdapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (handlerAdapter.supports(handler)) &#123;</span><br><span class="line"><span class="keyword">return</span> handlerAdapter.handle(exchange, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No HandlerAdapter: &quot;</span> + handler));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">****<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> WebHandler.class.isAssignableFrom(handler.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;HandlerResult&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange, Object handler)</span> &#123;</span><br><span class="line"><span class="type">WebHandler</span> <span class="variable">webHandler</span> <span class="operator">=</span> (WebHandler) handler;</span><br><span class="line">Mono&lt;Void&gt; mono = webHandler.handle(exchange);</span><br><span class="line"><span class="keyword">return</span> mono.then(Mono.empty());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入SimpleHandlerAdapter#handle的方法内部，真正处理的方法是Mono<Void> mono &#x3D; webHandler.handle(exchange);由于我们是gateway场景，所有使用的是org.springframework.cloud.gateway.handler.FilteringWebHandler#handle方法。找到这个方法点进去看看。</p><p>这个方法有几个重点：</p><ol><li>获取路由信息</li><li>获取filter</li><li>获取全局filter 适配器模式 把GlobalFilter包装成为GateWayFilter</li><li>合并filter，生成一个过滤器链</li><li>执行filter链  责任链模式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="comment">// 获取之前设置好的路由属性，一个Route对象，里面包括了</span></span><br><span class="line"><span class="comment">// &#123;&#x27;id&#x27;:&#x27;order_route&#x27;,&#x27;uri&#x27;:&#x27;lb://mall-order&#x27;,&#x27;predicate&#x27;:[&#x27;/order/**&#x27;],&#x27;filters&#x27;:[]&#125;</span></span><br><span class="line"><span class="type">Route</span> <span class="variable">route</span> <span class="operator">=</span> exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line"><span class="comment">// 获取Filter 比如在路由里面加上的添加请求头的Filter </span></span><br><span class="line"><span class="comment">// geteway的过滤器是添加了才有</span></span><br><span class="line"> List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();</span><br><span class="line">  <span class="comment">// 获取全局过滤器</span></span><br><span class="line">List&lt;GatewayFilter&gt; combined = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.globalFilters);</span><br><span class="line">combined.addAll(gatewayFilters);</span><br><span class="line"><span class="comment">// 排序并生产过滤器链</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(combined);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Sorted gatewayFilterFactories: &quot;</span> + combined);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultGatewayFilterChain</span>(combined).filter(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始进入到Filter链的内部看一下这个责任链执行的时候到底是做了什么逻辑，责任链模式不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultGatewayFilterChain</span> <span class="keyword">implements</span> <span class="title class_">GatewayFilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">DefaultGatewayFilterChain(List&lt;GatewayFilter&gt; filters) &#123;</span><br><span class="line"><span class="built_in">this</span>.filters = filters;</span><br><span class="line"><span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">DefaultGatewayFilterChain</span><span class="params">(DefaultGatewayFilterChain parent, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.filters = parent.getFilters();</span><br><span class="line"><span class="built_in">this</span>.index = index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;GatewayFilter&gt; <span class="title function_">getFilters</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> filters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.defer(() -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; filters.size()) &#123;</span><br><span class="line"><span class="type">GatewayFilter</span> <span class="variable">filter</span> <span class="operator">=</span> filters.get(<span class="built_in">this</span>.index);</span><br><span class="line"><span class="type">DefaultGatewayFilterChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultGatewayFilterChain</span>(<span class="built_in">this</span>,</span><br><span class="line"><span class="built_in">this</span>.index + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> filter.filter(exchange, chain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Mono.empty(); <span class="comment">// complete</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于每个chain做的是什么任务，比如我们是一个添加请求头的Filter，那么我们就会调用这个链，我们链调用完了是会向下传递的，但是这里还不是最终的发起请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddRequestHeaderGatewayFilterFactory</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractNameValueGatewayFilterFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(NameValueConfig config)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange,</span></span><br><span class="line"><span class="params">GatewayFilterChain chain)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ServerWebExchangeUtils.expand(exchange, config.getValue());</span><br><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest().mutate()</span><br><span class="line">.header(config.getName(), value).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange.mutate().request(request).build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> filterToStringCreator(AddRequestHeaderGatewayFilterFactory.<span class="built_in">this</span>)</span><br><span class="line">.append(config.getName(), config.getValue()).toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们此时请求的uri还是没变的，我们需要在某个地方改变这个请求uri，发起调用。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241133165.png" alt="44"></p><p>实际上要到了<code>LoadBalancerClientFilter</code> 才开始真正构建实际请求。主要的步骤是：</p><ol><li>获取url也就是根据上一个filter处理后加入的新的GATEWAY_REQUEST_URL_ATTR属性。</li><li>获取服务实例</li><li>构建实际的请求uri，旧的uri和服务实例的IP port整合</li><li>绑定新的uri到上下文</li><li>交给下游处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;Duplicates&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line"><span class="comment">// 获取 url ==&gt; lb://mall-order/order/findOrderByUserId/1</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">url</span> <span class="operator">=</span> exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);</span><br><span class="line"><span class="type">String</span> <span class="variable">schemePrefix</span> <span class="operator">=</span> exchange.getAttribute(GATEWAY_SCHEME_PREFIX_ATTR);</span><br><span class="line"><span class="keyword">if</span> (url == <span class="literal">null</span></span><br><span class="line">|| (!<span class="string">&quot;lb&quot;</span>.equals(url.getScheme()) &amp;&amp; !<span class="string">&quot;lb&quot;</span>.equals(schemePrefix))) &#123;</span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line">addOriginalRequestUrl(exchange, url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;LoadBalancerClientFilter url before: &quot;</span> + url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择一个服务实例 拿到他的IP端口等等信息</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> choose(exchange);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> NotFoundException.create(properties.isUse404(),</span><br><span class="line"><span class="string">&quot;Unable to find instance for &quot;</span> + url.getHost());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原始的uri &lt;http://localhost:8888/order/findOrderByUserId/1&gt;</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> exchange.getRequest().getURI();</span><br><span class="line"><span class="type">String</span> <span class="variable">overrideScheme</span> <span class="operator">=</span> instance.isSecure() ? <span class="string">&quot;https&quot;</span> : <span class="string">&quot;http&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (schemePrefix != <span class="literal">null</span>) &#123;</span><br><span class="line">overrideScheme = url.getScheme();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建新的uri </span></span><br><span class="line"><span class="type">URI</span> <span class="variable">requestUrl</span> <span class="operator">=</span> loadBalancer.reconstructURI(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">DelegatingServiceInstance</span>(instance, overrideScheme), uri);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;LoadBalancerClientFilter url chosen: &quot;</span> + requestUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定信息到上下文中</span></span><br><span class="line">exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);</span><br><span class="line"><span class="comment">// 执行下一个操作 </span></span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> ServiceInstance <span class="title function_">choose</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> loadBalancer.choose(</span><br><span class="line">         ((URI)exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR)).getHost());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面第三部替换uri的结果</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203241134716.png" alt="55"></p><p>来到下游过滤器也就是<code>NettyRoutingFilter</code> ，已经在上游filter设置好了uri，我们在这里直接发起请求就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;Duplicates&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line"><span class="comment">// 获取请求uri</span></span><br><span class="line">   <span class="type">URI</span> <span class="variable">requestUrl</span> <span class="operator">=</span> exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">scheme</span> <span class="operator">=</span> requestUrl.getScheme();</span><br><span class="line"><span class="keyword">if</span> (isAlreadyRouted(exchange)</span><br><span class="line">|| (!<span class="string">&quot;http&quot;</span>.equals(scheme) &amp;&amp; !<span class="string">&quot;https&quot;</span>.equals(scheme))) &#123;</span><br><span class="line"><span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line">setAlreadyRouted(exchange);</span><br><span class="line"><span class="comment">// 构建请求</span></span><br><span class="line"><span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">HttpMethod</span> <span class="variable">method</span> <span class="operator">=</span> HttpMethod.valueOf(request.getMethodValue());</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> requestUrl.toASCIIString();</span><br><span class="line"></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">filtered</span> <span class="operator">=</span> filterRequest(getHeadersFilters(), exchange);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">DefaultHttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpHeaders</span>();</span><br><span class="line">filtered.forEach(httpHeaders::set);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">preserveHost</span> <span class="operator">=</span> exchange</span><br><span class="line">.getAttributeOrDefault(PRESERVE_HOST_HEADER_ATTRIBUTE, <span class="literal">false</span>);</span><br><span class="line"><span class="type">Route</span> <span class="variable">route</span> <span class="operator">=</span> exchange.getAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line"></span><br><span class="line">Flux&lt;HttpClientResponse&gt; responseFlux = getHttpClient(route, exchange)</span><br><span class="line">.headers(headers -&gt; &#123;</span><br><span class="line">headers.add(httpHeaders);</span><br><span class="line"><span class="comment">// Will either be set below, or later by Netty</span></span><br><span class="line">headers.remove(HttpHeaders.HOST);</span><br><span class="line"><span class="keyword">if</span> (preserveHost) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> request.getHeaders().getFirst(HttpHeaders.HOST);</span><br><span class="line">headers.add(HttpHeaders.HOST, host);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发起请求</span></span><br><span class="line">&#125;).request(method).uri(url).send((req, nettyOutbound) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">nettyOutbound</span><br><span class="line">.withConnection(connection -&gt; log.trace(<span class="string">&quot;outbound route: &quot;</span></span><br><span class="line">+ connection.channel().id().asShortText()</span><br><span class="line">+ <span class="string">&quot;, inbound: &quot;</span> + exchange.getLogPrefix()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nettyOutbound.send(request.getBody().map(<span class="built_in">this</span>::getByteBuf));</span><br><span class="line">&#125;).responseConnection((res, connection) -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Defer committing the response until all route filters have run</span></span><br><span class="line"><span class="comment">// Put client response as ServerWebExchange attribute and write</span></span><br><span class="line"><span class="comment">// response later NettyWriteResponseFilter</span></span><br><span class="line">exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);</span><br><span class="line">exchange.getAttributes().put(CLIENT_RESPONSE_CONN_ATTR, connection);</span><br><span class="line"></span><br><span class="line"><span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line"><span class="comment">// put headers and status so filters can modify the response</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line"></span><br><span class="line">res.responseHeaders().forEach(</span><br><span class="line">entry -&gt; headers.add(entry.getKey(), entry.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">contentTypeValue</span> <span class="operator">=</span> headers.getFirst(HttpHeaders.CONTENT_TYPE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(contentTypeValue)) &#123;</span><br><span class="line">exchange.getAttributes().put(ORIGINAL_RESPONSE_CONTENT_TYPE_ATTR,</span><br><span class="line">contentTypeValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setResponseStatus(res, response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure headers filters run after setting status so it is</span></span><br><span class="line"><span class="comment">// available in response</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">filteredResponseHeaders</span> <span class="operator">=</span> HttpHeadersFilter.filter(</span><br><span class="line">getHeadersFilters(), headers, exchange, Type.RESPONSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!filteredResponseHeaders</span><br><span class="line">.containsKey(HttpHeaders.TRANSFER_ENCODING)</span><br><span class="line">&amp;&amp; filteredResponseHeaders</span><br><span class="line">.containsKey(HttpHeaders.CONTENT_LENGTH)) &#123;</span><br><span class="line"><span class="comment">// It is not valid to have both the transfer-encoding header and</span></span><br><span class="line"><span class="comment">// the content-length header.</span></span><br><span class="line"><span class="comment">// Remove the transfer-encoding header in the response if the</span></span><br><span class="line"><span class="comment">// content-length header is present.</span></span><br><span class="line">response.getHeaders().remove(HttpHeaders.TRANSFER_ENCODING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exchange.getAttributes().put(CLIENT_RESPONSE_HEADER_NAMES,</span><br><span class="line">filteredResponseHeaders.keySet());</span><br><span class="line"></span><br><span class="line">response.getHeaders().putAll(filteredResponseHeaders);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Mono.just(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">responseTimeout</span> <span class="operator">=</span> getResponseTimeout(route);</span><br><span class="line"><span class="keyword">if</span> (responseTimeout != <span class="literal">null</span>) &#123;</span><br><span class="line">responseFlux = responseFlux</span><br><span class="line">.timeout(responseTimeout, Mono.error(<span class="keyword">new</span> <span class="title class_">TimeoutException</span>(</span><br><span class="line"><span class="string">&quot;Response took longer than timeout: &quot;</span> + responseTimeout)))</span><br><span class="line">.onErrorMap(TimeoutException.class,</span><br><span class="line">th -&gt; <span class="keyword">new</span> <span class="title class_">ResponseStatusException</span>(HttpStatus.GATEWAY_TIMEOUT,</span><br><span class="line">th.getMessage(), th));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> responseFlux.then(chain.filter(exchange));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GateWay工作原理&quot;&gt;&lt;a href=&quot;#GateWay工作原理&quot; class=&quot;headerlink&quot; title=&quot;GateWay工作原理&quot;&gt;&lt;/a&gt;GateWay工作原理&lt;/h1&gt;&lt;h2 id=&quot;重要概念&quot;&gt;&lt;a href=&quot;#重要概念&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="SpringCloud" scheme="http://example.com/tags/SpringCloud/"/>
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="GateWay" scheme="http://example.com/tags/GateWay/"/>
    
  </entry>
  
  <entry>
    <title>Nacos源码分析</title>
    <link href="http://example.com/2022/03/21/Nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/21/Nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-20T16:26:41.000Z</published>
    <updated>2022-03-23T08:04:12.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos-Tutorial"><a href="#Nacos-Tutorial" class="headerlink" title="Nacos Tutorial"></a>Nacos Tutorial</h1><h2 id="Nacos总览"><a href="#Nacos总览" class="headerlink" title="Nacos总览"></a>Nacos总览</h2><h3 id="nacos服务健康探测机制与保护阈值"><a href="#nacos服务健康探测机制与保护阈值" class="headerlink" title="nacos服务健康探测机制与保护阈值"></a>nacos服务健康探测机制与保护阈值</h3><p>引入第一个问题，健康探测机制，服务注册中心都必须是要有的</p><p>nacos健康探测机制，分成两种，临时实例、持久化实例，针对不同的实例，他的健康探测机制不太一样，dubbo服务注册的时候要带上一个参数[ephemeral]，可以取值为两个，临时和持久化</p><p>默认情况下都不用去主动设置这个参数，默认都是ephemeral，临时实例</p><p>临时的话，默认每隔5s上报一次心跳，nacos如果15s没收到心跳就标记为不健康，超过30s没收到就摘除这个服务实例</p><p>持久化的话，nacos主动探测，20s探测一次，即使探测失败，也就是不健康状态，但是不会摘除这个服务实例</p><p>默认情况下，不健康的实例是不返回的，但是如果健康实例比例太低，会导致健康实例请求压力过大，被打死，引发服务雪崩，所以有保护阈值的概念</p><p>保护阈值，可以设置为0~1之间的比例，如果健康实例比例太低，则把不健康实例一起返回，此时会让很多请求走到不健康实例，会导致请求失败，但是可以避免健康实例的请求流量过大被打死，牺牲了一致性，得到了可用性 </p><h3 id="服务雪崩问题以及nacos健康保护阈值"><a href="#服务雪崩问题以及nacos健康保护阈值" class="headerlink" title="服务雪崩问题以及nacos健康保护阈值"></a>服务雪崩问题以及nacos健康保护阈值</h3><p>服务雪崩问题，nacos健康保护阈值</p><p>库存服务有10台机器，10个服务实例，订单服务会大范围的去调用库存服务，假设每个库存服务实例单机可以抗每秒500次请求，QPS 500，高峰 QPS 500 * 10 &#x3D; 5000，某一天，库存服务实例10个，里面有5个都崩溃了</p><p>5台机器都是虚拟机，部署在一个物理机，物理机故障了，就会导致5个虚拟机一起故障了这样子</p><p>每秒5000次请求，都会发送给剩下的5台健康的实例，平均每台实例会收到每秒1000次请求，远远超出了单机极限QPS，800，1000已经超过了。 </p><p>nacos有一个保护阈值， 比如设置为0.8 那么10台实例挂了两台都是没关系的，不会触发保护机制，订单服务会去请求这些剩下的8个健康实例，如果挂了4个，剩下6个，如果订单服务来请求，可能扛不住，如果设置阈值为0.6，所以nacos会返回订单服务6个健康的实例和4个挂了的实例，订单那边请求失败，但是不会把机器打垮，防止雪崩。</p><h3 id="保护阈值机制开启后的CAP问题分析"><a href="#保护阈值机制开启后的CAP问题分析" class="headerlink" title="保护阈值机制开启后的CAP问题分析"></a>保护阈值机制开启后的CAP问题分析</h3><p>一句话， 开了保护阈值机制打开了，会保障可用性，牺牲了一致性，订单看起来这些实例就不是一致。如果不打开保护阈值机制，那么请求的都是健康的服务实例，那么订单服务看起来都是一致的。</p><h3 id="自研Distro分布式一致性协议分析"><a href="#自研Distro分布式一致性协议分析" class="headerlink" title="自研Distro分布式一致性协议分析"></a>自研Distro分布式一致性协议分析</h3><p>nacos基础原理+开发实战+核心功能+数据模型，重点要给大家讲解一下nacos的内核原理</p><p>服务注册这块，允许大量的服务实例来注册，在nacos集群里管理所有的服务实例数据，针对你的nacos里管理的服务实例数据服务发现，注册（写操作），存储（nacos集群存放服务实例数据），发现（读操作），针对临时服务实例数据的存储</p><p>灵魂拷问：服务注册找nacos集群里哪个节点来发起？服务实例数据是存储在哪个nacos节点里？发现的时候找的是nacos哪个节点？</p><p>nacos集群启动之后按如下原则运作：</p><p>1、nacos每个节点都可以处理写请求，收到请求后，路由，根据ip:port路由算法，计算所属节点，把请求转发到负责这个数据的节点去，负责节点解析请求在本机里进行内存存储，定期执行同步任务，把本机负责的数据同步到其他节点，所以每个节点都有全量数据的存储</p><p>distro分布式一致性协议里，设计了一个定时sync同步机制和任务</p><p>关键点，仅仅按照这套算法来运行，会导致数据分片，data partition，每个nacos节点仅仅负责和管理了一部分的服务实例数据</p><p>提出第一种服务发现读数据的时候，nacos节点上没有你要的服务实例的数据，写路由+数据分片+读路由的架构设计，可用性的问题，优点是数据是强一致的，CAP，C，牺牲掉A，可用性就没有了，并不是nacos采用的方案，CP</p><p>nacos默认提供的AP，保证可用性</p><p>通过各个节点 定时同步数据的机制，可以确保说什么，每个节点除了处理自己负责的那部分数据写入，自己也会不断的把自己的数据同步给别的节点，定时的不断的接收到别的节点同步过来的数据</p><p>对于你的每一个节点来说，他会发现你这个节点上，会有所有节点的数据都汇总到你这里来，你这里会源源不断的接收到集群里完整的服务实例数据，保证最终一致性的概念，最终每个节点都会有集群里最新的数据</p><p>时间差问题-&gt;最终一致性，牺牲掉了一致性，AP，CP</p><p>2、新加入的nacos节点会拉取全量数据，轮询所有nacos节点，发送请求拉取全量数据，所以其实每个nacos节点上都会有所有注册上来的临时服务实例的数据</p><p>3、nacos每个节点都会定期发送心跳给其他的节点，心跳请求会进行数据校验，主要是交换数据的校验值，如果发现要是其他机器上的数据跟自己不一致，就会全量拉取数据进行补齐</p><p>4、nacos每个节点都可以处理读请求，因为有全量数据</p><p>distro协议是兼顾CAP中的AP的，在这个协议之下，所有节点通过定期数据同步，还有心跳校验实现节点数据最终一致，让每个节点都有全量数据，这样的话，如果有节点宕机崩溃都是没关系的</p><p>另外网络分区的话，也是没事的，因为不同的网络分区里就是读写分区中的nacos节点就可以了，就是没办法互相同步数据了，数据会不一致（通过MD5来校验的），但是一旦分区问题恢复了，心跳校验机制运作起来，数据会自动补齐的</p><h3 id="基于Raft协议的弱CP机制"><a href="#基于Raft协议的弱CP机制" class="headerlink" title="基于Raft协议的弱CP机制"></a>基于Raft协议的弱CP机制</h3><p>我如果是基于路由转发的这种方式， 数据集中在一个服务器上，这样是不可行的，会把机器打垮。如果是全量复制，数据也是强一致的，但是这种同步全量复制机制是很重的，写入性能非常低。</p><p>Distro这种是异步复制，保障的是最终一致性，再加上心跳机制，各个节点最终是一致的，但是有时间差问题，牺牲了一致性。即使崩溃了，也有一个机器有几乎全量数据。</p><p>首先Nacos集群通过Raft协议来选举，选举成为leader的节点才能接受读请求，然后接受读请求这一段时间服务是不可用，因为有一个raft日志同步过程（半数节点以上），但是Nacos的Raft不是标准的两阶段提交（2.0之后是标准的Raft两阶段提交），所以Nacos是有是一个弱CP机制的。有一个问题，半数节点同步了，其他节点呢？Nacos是通过注册心跳来解决，Nacos主节点发送心跳（zip）的时候附带了主节点上一些服务信息，然后从节点如果发现自己少了这些，那么就主动call注解点来拉取。</p><h3 id="临时实例和持久实例"><a href="#临时实例和持久实例" class="headerlink" title="临时实例和持久实例"></a>临时实例和持久实例</h3><ul><li>临时实例：默认情况，注册在内存注册表中，不会持久化到磁盘文件，健康检查是client模式，client主动上报，5S一次，Server 检查心跳情况，15秒没上报就设置为不健康，30S没上报就删除实例</li><li>持久化实例：注册到内存注册表之后，还会写入到磁盘文件，心跳检测是Server主动去检测client心跳是拉模式，20S检查一次，检测失败会把实例标记为不健康，但不会清除，因为持久化了</li></ul><p>使用场景：临时实例是存在突发流量横向扩展服务，适用于互联网，持久实例是相对固定的实例。</p><h2 id="Naocs-源码分析"><a href="#Naocs-源码分析" class="headerlink" title="Naocs 源码分析"></a>Naocs 源码分析</h2><h3 id="Nacos-Client源码分析"><a href="#Nacos-Client源码分析" class="headerlink" title="Nacos Client源码分析"></a>Nacos Client源码分析</h3><h4 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h4><p>Instance类，代表一个服务实例，一些基础信息，一个实例隶属于一个服务，一个集群</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instance</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">742906310567291979L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unique id of this instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String instanceId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance ip.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance weight.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">1.0D</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * instance health status.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">healthy</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If instance is enabled to accept request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If instance is ephemeral.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ephemeral</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cluster information of instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String clusterName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service information of instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user extended attributes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceInfo类，包含一个Instance列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInfo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">jsonFromServer</span> <span class="operator">=</span> EMPTY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLITER</span> <span class="operator">=</span> <span class="string">&quot;@@&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 服务名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String clusters; <span class="comment">// 一个服务可能有多个集群</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">cacheMillis</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Instance&gt; hosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Instance&gt;(); <span class="comment">// 当前服务所有的服务实例列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastRefTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">checksum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">allIPs</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamingService 接口，它有一个实现类NacosNamingService，可以完成Client到Server的各种通信，注册&#x2F;取消注册，订阅取消等等</p><h4 id="Nacos启动流程"><a href="#Nacos启动流程" class="headerlink" title="Nacos启动流程"></a>Nacos启动流程</h4><p>Nacos启动是根据事件监听机制，监听到web服务器启动之后，就开始自动注册。自动注册之前的逻辑先跳过，直接来看到底是怎么注册的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> namingService();</span><br><span class="line"><span class="comment">// 微服务名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> registration.getServiceId();</span><br><span class="line"><span class="comment">// 分组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> nacosDiscoveryProperties.getGroup();</span><br><span class="line"><span class="comment">// 生成instance </span></span><br><span class="line"><span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用注册逻辑</span></span><br><span class="line">namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">instance.getIp(), instance.getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line"><span class="comment">// rethrow a RuntimeException if the registration is failed.</span></span><br><span class="line"><span class="comment">// issue : https://github.com/alibaba/spring-cloud-alibaba/issues/1132</span></span><br><span class="line">rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入的是NacosNamingService类的registerInstance方法，其实还是一个封装instance，然后注册的，进入到这个重载方法内部，有几步需要做的：</p><ol><li>验证instance是否合法</li><li>获取groupSerce名称 例如 my_default_group@@order_service</li><li>开始心跳  </li><li>发起注册</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="comment">// 是否是临时实例 构建Beat信息</span></span><br><span class="line">            <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            <span class="comment">// 开始心跳</span></span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看一下心跳信息有什么内容，其实就是当前实例的一些东西， 加上间隔时间。默认是5S发送一次心跳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeatInfo <span class="title function_">buildBeatInfo</span><span class="params">(String groupedServiceName, Instance instance)</span> &#123;</span><br><span class="line">        <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeatInfo</span>();</span><br><span class="line">        beatInfo.setServiceName(groupedServiceName);</span><br><span class="line">        beatInfo.setIp(instance.getIp());</span><br><span class="line">        beatInfo.setPort(instance.getPort());</span><br><span class="line">        beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">        beatInfo.setWeight(instance.getWeight());</span><br><span class="line">        beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">        beatInfo.setScheduled(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 心跳间隔 默认5秒</span></span><br><span class="line">        beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line">        <span class="keyword">return</span> beatInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码执行顺序可以看出，既然先执行发送心跳，但是此时还没注册上去，发送心跳必然找不到服务啊？其实这是一个延迟任务，点进发送心跳的源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add beat information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName service name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beatInfo    beat information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> &#123;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[BEAT] adding beat: &#123;&#125; to beat map.&quot;</span>, beatInfo);</span><br><span class="line"><span class="comment">// key的格式为 groupId@@微服务名称##ip##port</span></span><br><span class="line"><span class="comment">// 这个key是固定了主机了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> buildKey(serviceName, beatInfo.getIp(), beatInfo.getPort());</span><br><span class="line">        <span class="type">BeatInfo</span> <span class="variable">existBeat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//fix #1733 again</span></span><br><span class="line"><span class="comment">// dom2Beat是一个缓存map，key是主机，value=主机发送的心跳信息beat</span></span><br><span class="line"><span class="comment">// 前面的心跳停了才发送新的心跳</span></span><br><span class="line">        <span class="keyword">if</span> ((existBeat = dom2Beat.put(key, beatInfo)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            existBeat.setStopped(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始定时任务 5S之后开始任务 在结束之前又开始一个新的任务</span></span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">        MetricsMonitor.getDom2BeatSizeMonitor().set(dom2Beat.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看一下BeatTask的run方法，其实就是使用httpClient发起调用，然后结束之前把任务再添加今天循环调用而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nextTime</span> <span class="operator">=</span> beatInfo.getPeriod();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发送心跳 PUT 请求</span></span><br><span class="line">                <span class="type">JsonNode</span> <span class="variable">result</span> <span class="operator">=</span> serverProxy.sendBeat(beatInfo, BeatReactor.<span class="built_in">this</span>.lightBeatEnabled);</span><br><span class="line">                <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> result.get(<span class="string">&quot;clientBeatInterval&quot;</span>).asLong();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">lightBeatEnabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                    lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="built_in">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nextTime = interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> NamingResponseCode.OK;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                    code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果发现此实例在nacos server上面没有注册，那么就执行注册的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                    <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">                    instance.setPort(beatInfo.getPort());</span><br><span class="line">                    instance.setIp(beatInfo.getIp());</span><br><span class="line">                    instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                    instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                    instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                    instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                    instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                    instance.setEphemeral(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                                NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                        JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception unknownEx) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, unknown exception msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                        JacksonUtils.toJson(beatInfo), unknownEx.getMessage(), unknownEx);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 再次嵌套调用</span></span><br><span class="line">                executorService.schedule(<span class="keyword">new</span> <span class="title class_">BeatTask</span>(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入JsonNode result &#x3D; serverProxy.sendBeat(beatInfo, BeatReactor.this.lightBeatEnabled);把BeatInfo拆开放入map，发送过去，是一个PUT请求，请求url &#x3D; nacos&#x2F;v1&#x2F;ns&#x2F;instance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonNode <span class="title function_">sendBeat</span><span class="params">(BeatInfo beatInfo, <span class="type">boolean</span> lightBeatEnabled)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">            NAMING_LOGGER.debug(<span class="string">&quot;[BEAT] &#123;&#125; sending beat to server: &#123;&#125;&quot;</span>, namespaceId, beatInfo.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">8</span>);</span><br><span class="line">        Map&lt;String, String&gt; bodyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!lightBeatEnabled) &#123;</span><br><span class="line">            bodyMap.put(<span class="string">&quot;beat&quot;</span>, JacksonUtils.toJson(beatInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, beatInfo.getServiceName());</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, beatInfo.getCluster());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, beatInfo.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(beatInfo.getPort()));</span><br><span class="line">        <span class="comment">// 发送Beat心跳</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/beat&quot;</span>, params, bodyMap, HttpMethod.PUT);</span><br><span class="line">        <span class="keyword">return</span> JacksonUtils.toObj(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到上文的注册逻辑，点进去看一下注册实例是怎么做的，其实就是两件事情</p><ol><li>把instace这个对象拆开，放入parmas</li><li>发起post请求，地址为 nacos&#x2F;v1&#x2F;ns&#x2F;instance</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>, namespaceId, serviceName,</span><br><span class="line">                instance);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line">        <span class="comment">// 权重</span></span><br><span class="line">        params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">        params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">        <span class="comment">// 健康度</span></span><br><span class="line">        params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">        params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">        params.put(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.toJson(instance.getMetadata()));</span><br><span class="line">        <span class="comment">// nacos/v1/ns/instance</span></span><br><span class="line">        reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入 reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);来看一些是怎么做的，一句话总结就是 如果有多个nacos节点，那么就轮训尝试注册，直到成功或是尝试次数达到了nacos服务数量。 如果是单节点，默认尝试次数为3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span><br><span class="line"><span class="params">                         String method)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;no server available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">NacosException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>();</span><br><span class="line"><span class="comment">// domain不为空，先连接这个，默认尝试次数3</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用服务注册</span></span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是一个重要的信息如果是多个nacos节点，其实是随机找个nacos节点来注册的</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(servers.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">server</span> <span class="operator">=</span> servers.get(index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, server, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 该server连接失败 ，连接下一个</span></span><br><span class="line">                index = (index + <span class="number">1</span>) % servers.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NAMING_LOGGER.error(<span class="string">&quot;request: &#123;&#125; failed, servers: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>, api, servers, exception.getErrCode(),</span><br><span class="line">                exception.getErrMsg());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(exception.getErrCode(),</span><br><span class="line">                <span class="string">&quot;failed to req API:&quot;</span> + api + <span class="string">&quot; after all servers(&quot;</span> + servers + <span class="string">&quot;) tried: &quot;</span> + exception.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后面发送HTTP POST请求的代码就不再细看了，是使用NameServerProxy来做，里面调用的是HttpClient发送的请求，请求的地址是<a href="http://127.0.0.1:8848/nacos/v1/ns/instance%E3%80%82">http://127.0.0.1:8848/nacos/v1/ns/instance。</a></p><h4 id="Nacos获取所有服务"><a href="#Nacos获取所有服务" class="headerlink" title="Nacos获取所有服务"></a>Nacos获取所有服务</h4><p>直接说结论，是在NamingServiceProxy里面调用获取服务列表的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">queryList</span><span class="params">(String serviceName, String clusters, <span class="type">int</span> udpPort, <span class="type">boolean</span> healthyOnly)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">8</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">        params.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">        params.put(<span class="string">&quot;udpPort&quot;</span>, String.valueOf(udpPort));</span><br><span class="line">        params.put(<span class="string">&quot;clientIP&quot;</span>, NetUtils.localIP());</span><br><span class="line">        params.put(<span class="string">&quot;healthyOnly&quot;</span>, String.valueOf(healthyOnly));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP请求 调用服务列表</span></span><br><span class="line">        <span class="keyword">return</span> reqApi(UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance/list&quot;</span>, params, HttpMethod.GET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Nacos定时更新本地服务"><a href="#Nacos定时更新本地服务" class="headerlink" title="Nacos定时更新本地服务"></a>Nacos定时更新本地服务</h4><p>容器在启动的时候创建了一个<code>NacosWatch</code> Bean，这个Bean就是和服务订阅有关的，看一下关键的方法    namingService.subscribe(properties.getService(), properties.getGroup(),这里就是订阅服务的地方了。我们看一些具体是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.running.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line"><span class="type">EventListener</span> <span class="variable">eventListener</span> <span class="operator">=</span> listenerMap.computeIfAbsent(buildKey(),</span><br><span class="line">event -&gt; <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> NamingEvent) &#123;</span><br><span class="line">List&lt;Instance&gt; instances = ((NamingEvent) event)</span><br><span class="line">.getInstances();</span><br><span class="line">Optional&lt;Instance&gt; instanceOptional = selectCurrentInstance(</span><br><span class="line">instances);</span><br><span class="line">instanceOptional.ifPresent(currentInstance -&gt; &#123;</span><br><span class="line">resetIfNeeded(currentInstance);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> nacosServiceManager</span><br><span class="line">.getNamingService(properties.getNacosProperties());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">namingService.subscribe(properties.getService(), properties.getGroup(),</span><br><span class="line">Arrays.asList(properties.getClusterName()), eventListener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;namingService subscribe failed, properties:&#123;&#125;&quot;</span>, properties, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.watchFuture = <span class="built_in">this</span>.taskScheduler.scheduleWithFixedDelay(</span><br><span class="line"><span class="built_in">this</span>::nacosServicesWatch, <span class="built_in">this</span>.properties.getWatchDelay());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用层级很深，最后来到的是HostReactor下的subscribe方法，里面有一个关键的 getServiceInfo(serviceName, clusters);这里就是过去服务信息了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceName, String clusters, EventListener eventListener)</span> &#123;</span><br><span class="line">        notifier.registerListener(serviceName, clusters, eventListener);</span><br><span class="line">        getServiceInfo(serviceName, clusters);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入这个方法内部，就是现在本地注册表中获取，如果没有这个服务那就先创建一个，然后向server发送get请求获取服务，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.debug(<span class="string">&quot;failover-mode: &quot;</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line"><span class="comment">// 构建key 请求格式为 groupId@@微服务ID@@cluster名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">        <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">            <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从当前client本地注册表中获取当前服务 本地注册表是个map </span></span><br><span class="line"><span class="comment">// key -&gt; groupId@@微服务ID@@cluster名称 value -&gt; serviceinfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="comment">// 如果为空 （第一次启动肯定是空的）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == serviceObj) &#123;</span><br><span class="line"><span class="comment">// 创建个空的服务 没有任何提供者实例</span></span><br><span class="line">            serviceObj = <span class="keyword">new</span> <span class="title class_">ServiceInfo</span>(serviceName, clusters);</span><br><span class="line">            <span class="comment">// 放入注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line">            <span class="comment">// 临时缓存 主要是使用这个缓存的key 不能重复 </span></span><br><span class="line"><span class="comment">// 只要服务名称出现在这个缓存map中，就表示这个服务正在被更新</span></span><br><span class="line">            updatingMap.put(serviceName, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"><span class="comment">// 开始更新服务</span></span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line"><span class="comment">// 更新完了 删掉</span></span><br><span class="line">            updatingMap.remove(serviceName);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line"><span class="comment">// 如果注册表中有了这个服务 而且临时缓存中有了这个服务</span></span><br><span class="line">            <span class="comment">// 那这个服务就是正在被更新 那就等一会儿</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATE_HOLD_INTERVAL &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// hold a moment waiting for update finish</span></span><br><span class="line">                <span class="keyword">synchronized</span> (serviceObj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serviceObj.wait(UPDATE_HOLD_INTERVAL);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        NAMING_LOGGER</span><br><span class="line">                                .error(<span class="string">&quot;[getServiceInfo] serviceName:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定时任务启动 定时更新本地注册表中的当前服务</span></span><br><span class="line">        scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们先来看 updateServiceNow(serviceName, clusters);这个方法就是调用了一个updateService方法，那直接来看updateService就好，里面就是获取本地注册表和远程注册表的服务，然后做一个合并操作，合并就是在processServiceJson(result);处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateService</span><span class="params">(String serviceName, String clusters)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">// 在本地注册表中获取当前服务 </span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldService</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 向server发送get请求 获取服务</span></span><br><span class="line">            <span class="comment">// 返回的serviceinfo是以json串形式出现的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> serverProxy.queryList(serviceName, clusters, pushReceiver.getUdpPort(), <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(result)) &#123;</span><br><span class="line"><span class="comment">// 将来自于server的serviceinfo更新到本地 </span></span><br><span class="line">                processServiceJson(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldService != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (oldService) &#123;</span><br><span class="line">                    oldService.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析processServiceJson(result);之前要达成一个共识，来自server的数据是一个最新的数据，其实就是合并新旧数据的过程，没什么特别的地方。至此，我们清楚了是如果请求server获取最新数据然后与本地合并了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">processServiceJson</span><span class="params">(String json)</span> &#123;</span><br><span class="line"><span class="comment">// 吧来自server的json处理为ServiceInfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> JacksonUtils.toObj(json, ServiceInfo.class);</span><br><span class="line"><span class="comment">// 本地注册表中的ServiceInfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldService</span> <span class="operator">=</span> serviceInfoMap.get(serviceInfo.getKey());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pushEmptyProtection &amp;&amp; !serviceInfo.validate()) &#123;</span><br><span class="line">            <span class="comment">//empty or error push, just ignore</span></span><br><span class="line">            <span class="keyword">return</span> oldService;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 本地注册表中存在当前服务 </span></span><br><span class="line">        <span class="keyword">if</span> (oldService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为了安全起见，默认服务器的数据是最新的</span></span><br><span class="line">            <span class="keyword">if</span> (oldService.getLastRefTime() &gt; serviceInfo.getLastRefTime()) &#123;</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;out of date data received, old-t: &quot;</span> + oldService.getLastRefTime() + <span class="string">&quot;, new-t: &quot;</span></span><br><span class="line">                        + serviceInfo.getLastRefTime());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把来自service的serviceinfo替换掉本地注册表的</span></span><br><span class="line">            serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 遍历本地注册表服务中的所有实例</span></span><br><span class="line">            Map&lt;String, Instance&gt; oldHostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Instance&gt;(oldService.getHosts().size());</span><br><span class="line">            <span class="keyword">for</span> (Instance host : oldService.getHosts()) &#123;</span><br><span class="line"><span class="comment">// ip:port 作为key，instance作为value放进去</span></span><br><span class="line">                oldHostMap.put(host.toInetAddr(), host);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历来自于server的服务的所有实例</span></span><br><span class="line">            Map&lt;String, Instance&gt; newHostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Instance&gt;(serviceInfo.getHosts().size());</span><br><span class="line">            <span class="keyword">for</span> (Instance host : serviceInfo.getHosts()) &#123;</span><br><span class="line"><span class="comment">// ip:port 作为key，instance作为value放进去</span></span><br><span class="line">                newHostMap.put(host.toInetAddr(), host);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该set存的是两个map old 与 new 都有的client </span></span><br><span class="line"><span class="comment">// 但他们的instance不同，会把来自server的instance写入</span></span><br><span class="line">            Set&lt;Instance&gt; modHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line"><span class="comment">// 只有newHostMap存在的intstance，也就是新增的</span></span><br><span class="line">            Set&lt;Instance&gt; newHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line"><span class="comment">// 只有oldHostMap有，也就是server端没有的instance</span></span><br><span class="line">            Set&lt;Instance&gt; remvHosts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Instance&gt;();</span><br><span class="line">            <span class="comment">// 遍历来自server的</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, Instance&gt;&gt; newServiceHosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Instance&gt;&gt;(</span><br><span class="line">                    newHostMap.entrySet());</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : newServiceHosts) &#123;</span><br><span class="line">                <span class="type">Instance</span> <span class="variable">host</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="comment">// 本地注册表中也有这个 ip:port 但是两个instance不同，就放入modMap</span></span><br><span class="line">                <span class="keyword">if</span> (oldHostMap.containsKey(key) &amp;&amp; !StringUtils</span><br><span class="line">                        .equals(host.toString(), oldHostMap.get(key).toString())) &#123;</span><br><span class="line">                    modHosts.add(host);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注册表中不存在这个ip:prot 那就写入到newMap 说明这个主机是新增的</span></span><br><span class="line">                <span class="keyword">if</span> (!oldHostMap.containsKey(key)) &#123;</span><br><span class="line">                    newHosts.add(host);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历本地注册表中服务的instane</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : oldHostMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">Instance</span> <span class="variable">host</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (newHostMap.containsKey(key)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注册表中存在  但是来自server的serviceInfo不存在</span></span><br><span class="line">                <span class="keyword">if</span> (!newHostMap.containsKey(key)) &#123;</span><br><span class="line"><span class="comment">// 加入到remvMap</span></span><br><span class="line">                    remvHosts.add(host);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增了 log</span></span><br><span class="line">            <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;new ips(&quot;</span> + newHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(newHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除了 log</span></span><br><span class="line">            <span class="keyword">if</span> (remvHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;removed ips(&quot;</span> + remvHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(remvHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发生变更了 </span></span><br><span class="line">            <span class="keyword">if</span> (modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 变更心跳 instance改了 心跳也要改才行</span></span><br><span class="line">                updateBeatInfo(modHosts);</span><br><span class="line">                NAMING_LOGGER.info(<span class="string">&quot;modified ips(&quot;</span> + modHosts.size() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                        + JacksonUtils.toJson(modHosts));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            serviceInfo.setJsonFromServer(json);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span> || remvHosts.size() &gt; <span class="number">0</span> || modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 只要发生了变更，就把发生变更的serviceInfo记录到缓存队列中</span></span><br><span class="line">                NotifyCenter.publishEvent(<span class="keyword">new</span> <span class="title class_">InstancesChangeEvent</span>(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                        serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">                DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果本地注册表中没有本服务直接写入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;init new ips(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line"><span class="comment">// 将来自server的serviceInfo记录到注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">            NotifyCenter.publishEvent(<span class="keyword">new</span> <span class="title class_">InstancesChangeEvent</span>(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                    serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">           </span><br><span class="line">  serviceInfo.setJsonFromServer(json);</span><br><span class="line">            DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        MetricsMonitor.getServiceInfoMapSizeMonitor().set(serviceInfoMap.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;current ips:(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们把视线回到上面的  scheduleUpdateIfAbsent(serviceName, clusters);这是一个定时更新本地数据的任务，我们进入方法内部，主要的工作就是创建一个异步对象放入map中，注意这里是DCL，然后启动任务。要想知道这个异步任务到底是做什么的，必须看一下UpdateTask这个类的run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleUpdateIfAbsent</span><span class="params">(String serviceName, String clusters)</span> &#123;</span><br><span class="line"><span class="comment">// 这是个缓存map key为groupid@@微服务名@@cluster</span></span><br><span class="line"><span class="comment">// value 是个定时异步操作对象 </span></span><br><span class="line"><span class="comment">// private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; futureMap = new HashMap&lt;String, ScheduledFuture&lt;?&gt;&gt;();</span></span><br><span class="line"><span class="comment">// 如果有这个异步对象 就返回</span></span><br><span class="line"><span class="comment">// 这种结构称为DCL 防止并发情况下重复写入</span></span><br><span class="line">        <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (futureMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个定时异步对象</span></span><br><span class="line">            ScheduledFuture&lt;?&gt; future = addTask(<span class="keyword">new</span> <span class="title class_">UpdateTask</span>(serviceName, clusters));</span><br><span class="line"><span class="comment">// 把这个定时异步任务放入缓存map</span></span><br><span class="line">            futureMap.put(ServiceInfo.getKey(serviceName, clusters), future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>run方法的分析如下，就是更新注册表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delayTime</span> <span class="operator">=</span> DEFAULT_DELAY;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 在本地注册表获取当前服务</span></span><br><span class="line">                <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (serviceObj == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 本地不存在这个服务，从server拉取并更新到本地</span></span><br><span class="line">                    updateService(serviceName, clusters);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理本地注册表粗存在当前服务的情况</span></span><br><span class="line"><span class="comment">// lastRefTime 当前instanc最后被访问的时间</span></span><br><span class="line">                <span class="comment">// serviceObj.getLastRefTime() 当前服务最后被访问的时间 来源于这个服务里面的所有</span></span><br><span class="line">                <span class="comment">// 实例中最晚被访问的时间</span></span><br><span class="line">                <span class="keyword">if</span> (serviceObj.getLastRefTime() &lt;= lastRefTime) &#123;</span><br><span class="line">                    <span class="comment">//  当前注册表需要更新了</span></span><br><span class="line">                    updateService(serviceName, clusters);</span><br><span class="line">                    serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// if serviceName already updated by push, we should not override it</span></span><br><span class="line">                    <span class="comment">// since the push data may be different from pull through force push</span></span><br><span class="line">                    refreshOnly(serviceName, clusters);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将来自注册表的这个最后访问时间更新到当前client缓存中</span></span><br><span class="line">                lastRefTime = serviceObj.getLastRefTime();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!notifier.isSubscribed(serviceName, clusters) &amp;&amp; !futureMap</span><br><span class="line">                        .containsKey(ServiceInfo.getKey(serviceName, clusters))) &#123;</span><br><span class="line">                    <span class="comment">// abort the update task</span></span><br><span class="line">                    NAMING_LOGGER.info(<span class="string">&quot;update task is stopped, service:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isEmpty(serviceObj.getHosts())) &#123;</span><br><span class="line">                    incFailCount();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                delayTime = serviceObj.getCacheMillis();</span><br><span class="line">                resetFailCount();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                incFailCount();</span><br><span class="line">                NAMING_LOGGER.warn(<span class="string">&quot;[NA] failed to update serviceName: &quot;</span> + serviceName, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 开始下一次定时更新任务就好了 循环执行</span></span><br><span class="line">                executor.schedule(<span class="built_in">this</span>, Math.min(delayTime &lt;&lt; failCount, DEFAULT_DELAY * <span class="number">60</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Nacos定时更新本地服务的就是以上流程，我们可以用一张流程图来概括这整个步骤：</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203210117403.png" alt="Nacos Client定时更新本地服务(1)"></p><h4 id="Nacos-Client获取要调用的服务的提供者列表"><a href="#Nacos-Client获取要调用的服务的提供者列表" class="headerlink" title="Nacos Client获取要调用的服务的提供者列表"></a>Nacos Client获取要调用的服务的提供者列表</h4><p>首先说结论，客户端是需要调用的时候才懒加载进来服务提供者信息。客户端是基于Ribbon负载均衡来做的，我们进入Ribbon的配置类，关键点就是这个ZoneAwareLoadBalancer类，这是在调用的时候才会创建的一个配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ILoadBalancer <span class="title function_">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span><br><span class="line"><span class="params">ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span><br><span class="line"><span class="params">IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 只有服务真正发生调用的时候才会创建这个类</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZoneAwareLoadBalancer</span>&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在进入这个ZoneAwareLoadBalancer， 前面都是一些初始化赋值操作，后面的restOfInit(clientConfig)才是配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DynamicServerListLoadBalancer</span><span class="params">(IClientConfig clientConfig, IRule rule, IPing ping,</span></span><br><span class="line"><span class="params">                                         ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span></span><br><span class="line"><span class="params">                                         ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(clientConfig, rule, ping);</span><br><span class="line">        <span class="built_in">this</span>.serverListImpl = serverList;</span><br><span class="line">        <span class="built_in">this</span>.filter = filter;</span><br><span class="line">        <span class="built_in">this</span>.serverListUpdater = serverListUpdater;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AbstractServerListFilter) &#123;</span><br><span class="line">            ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">        &#125;</span><br><span class="line">        restOfInit(clientConfig);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入 restOfInit(clientConfig)，过滤掉不重要东西，然后我们可以观察到 updateListOfServers(); 根据方法名字我们就可以推断出来，这就是一个获取服务提供者列表的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">primeConnection</span> <span class="operator">=</span> <span class="built_in">this</span>.isEnablePrimingConnections();</span><br><span class="line">    <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">    <span class="built_in">this</span>.setEnablePrimingConnections(<span class="literal">false</span>);</span><br><span class="line">    enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">    updateListOfServers();</span><br><span class="line">    <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="built_in">this</span>.getPrimeConnections() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getPrimeConnections()</span><br><span class="line">                .primeConnections(getReachableServers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;</span>, clientConfig.getClientName(), <span class="built_in">this</span>.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进去，发现获取服务列表的是serverListImpl.getUpdatedListOfServers();这里。这其实是loadBlancer接口，里面定义了 获取服务的方法，我们如果要获取服务实例，都是要继承这个接口的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateListOfServers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="literal">null</span>) &#123;</span><br><span class="line">        servers = serverListImpl.getUpdatedListOfServers();</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>,</span><br><span class="line">                getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="literal">null</span>) &#123;</span><br><span class="line">            servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>,</span><br><span class="line">                    getIdentifier(), servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下哪些类实现了这个接口，很明显Nacos也实现了这个方法，那么我们就直接进去看看nacos具体如何做的。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203211156633.png" alt="image-20220321115627566"></p><p>进入Nacos实现的这个方法内部，可以看到关键方法就是根据服务ID获取服务实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;NacosServer&gt; <span class="title function_">getServers</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> discoveryProperties.getGroup();</span><br><span class="line">            <span class="comment">// 根据服务ID获取服务实例</span></span><br><span class="line">List&lt;Instance&gt; instances = discoveryProperties.namingServiceInstance()</span><br><span class="line">.selectInstances(serviceId, group, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> instancesToServerList(instances);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;Can not get service instances from nacos, serviceId=&quot;</span> + serviceId,</span><br><span class="line">e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入方法内部，做的事情就是获取订阅的服务，然后根据返回的instance过滤出来可用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, String groupName, List&lt;String&gt; clusters, <span class="type">boolean</span> healthy,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> subscribe)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">       </span><br><span class="line">       ServiceInfo serviceInfo;</span><br><span class="line">       <span class="keyword">if</span> (subscribe) &#123;</span><br><span class="line">           <span class="comment">// 获取到要调用服务的serviceinfo</span></span><br><span class="line">           serviceInfo = hostReactor.getServiceInfo(NamingUtils.getGroupedName(serviceName, groupName),</span><br><span class="line">                   StringUtils.join(clusters, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           serviceInfo = hostReactor</span><br><span class="line">                   .getServiceInfoDirectlyFromServer(NamingUtils.getGroupedName(serviceName, groupName),</span><br><span class="line">                           StringUtils.join(clusters, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从所有服务列表中过滤出来可用的</span></span><br><span class="line">       <span class="keyword">return</span> selectInstances(serviceInfo, healthy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后进入具体的获取方法，我们之前已经解读过了，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.debug(<span class="string">&quot;failover-mode: &quot;</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line"><span class="comment">// 构建key 请求格式为 groupId@@微服务ID@@cluster名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">        <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">            <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从当前client本地注册表中获取当前服务 本地注册表是个map </span></span><br><span class="line"><span class="comment">// key -&gt; groupId@@微服务ID@@cluster名称 value -&gt; serviceinfo</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceObj</span> <span class="operator">=</span> getServiceInfo0(serviceName, clusters);</span><br><span class="line">        <span class="comment">// 如果为空 （第一次启动肯定是空的）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == serviceObj) &#123;</span><br><span class="line"><span class="comment">// 创建个空的服务 没有任何提供者实例</span></span><br><span class="line">            serviceObj = <span class="keyword">new</span> <span class="title class_">ServiceInfo</span>(serviceName, clusters);</span><br><span class="line">            <span class="comment">// 放入注册表</span></span><br><span class="line">            serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line">            <span class="comment">// 临时缓存 主要是使用这个缓存的key 不能重复 </span></span><br><span class="line"><span class="comment">// 只要服务名称出现在这个缓存map中，就表示这个服务正在被更新</span></span><br><span class="line">            updatingMap.put(serviceName, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"><span class="comment">// 开始更新服务</span></span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line"><span class="comment">// 更新完了 删掉</span></span><br><span class="line">            updatingMap.remove(serviceName);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line"><span class="comment">// 如果注册表中有了这个服务 而且临时缓存中有了这个服务</span></span><br><span class="line">            <span class="comment">// 那这个服务就是正在被更新 那就等一会儿</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATE_HOLD_INTERVAL &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// hold a moment waiting for update finish</span></span><br><span class="line">                <span class="keyword">synchronized</span> (serviceObj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serviceObj.wait(UPDATE_HOLD_INTERVAL);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        NAMING_LOGGER</span><br><span class="line">                                .error(<span class="string">&quot;[getServiceInfo] serviceName:&quot;</span> + serviceName + <span class="string">&quot;, clusters:&quot;</span> + clusters, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定时任务启动 定时更新本地注册表中的当前服务</span></span><br><span class="line">        scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们看一下过来出来可用服务是如何做的，一句话就是过滤不健康的不可用的权重小于0的服务，返回正常的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(ServiceInfo serviceInfo, <span class="type">boolean</span> healthy)</span> &#123;</span><br><span class="line">    List&lt;Instance&gt; list;</span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="literal">null</span> || CollectionUtils.isEmpty(list = serviceInfo.getHosts())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Instance&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代这个服务的所有instance</span></span><br><span class="line">    Iterator&lt;Instance&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="comment">// 服务非健康的 非可用 权重&lt;=0，从列表中去除</span></span><br><span class="line">        <span class="keyword">if</span> (healthy != instance.isHealthy() || !instance.isEnabled() || instance.getWeight() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回可用instance列表</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nacos-Server源码分析"><a href="#Nacos-Server源码分析" class="headerlink" title="Nacos Server源码分析"></a>Nacos Server源码分析</h3><h4 id="重要API介绍"><a href="#重要API介绍" class="headerlink" title="重要API介绍"></a>重要API介绍</h4><ol><li><p>InstanceController 处理客户端请求例如订阅 心跳</p></li><li><p>Service 代表了一个服务 （Service of Nacos server side） 引入了一个Service Cluster Instance模型，也就是一个实例集合，类似客户端的ServiceInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3470985546826874460L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * protect threshold.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 保护阈值 默认是0.8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">protectThreshold</span> <span class="operator">=</span> <span class="number">0.0F</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * application name of this service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group to classify services into different sets.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>RecordListener 数据监听接口 实现了这个接口Service就是一个监听器 范型指定正在监听的数据类型 Record instance也是继承了这个，所以 RecordListener 监听的各个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecordListener</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Record</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the listener was registered with this key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key candidate key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the listener was registered with this key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 判断监听器是否监听了这个key</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">interests</span><span class="params">(String key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the listener is to be removed by matching the &#x27;key&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if match success</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 判断监听器是否已经移除了这个key</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matchUnlistenKey</span><span class="params">(String key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Action to do if data of target key has changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   target key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value data of the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// key变化触发这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(String key, T value)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Action to do if data of target key has been removed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key target key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 指定key的数据被删除 触发这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDelete</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Record Nacos集群中传递的记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Record</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get the checksum of this record, usually for record comparison.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> checksum of record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getChecksum</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ServiceManager 是RecordListener<Intance>的实现类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceManager</span> <span class="keyword">implements</span> <span class="title class_">RecordListener</span>&lt;Service&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map(namespace, Map(group::serviceName, Service)).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 就是注册表了 外层是namespace 内层map key-&gt;serviceId value-&gt;service对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 来自于其他nacos变更数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingDeque&lt;ServiceKey&gt; toBeUpdatedServicesQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 同步器 service状态同步器 nacos集群同步用的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Synchronizer</span> <span class="variable">synchronizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceStatusSynchronizer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 一致性服务 基于raft数据同步的</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;consistencyDelegate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ConsistencyService consistencyService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SwitchDomain switchDomain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DistroMapper distroMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerMemberManager memberManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PushService pushService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RaftPeerSet raftPeerSet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxFinalizeCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">putServiceLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.auto-clean:false&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> emptyServiceAutoClean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.clean.initial-delay-ms:60000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cleanEmptyServiceDelay;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.naming.empty-service.clean.period-time-ms:20000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cleanEmptyServicePeriod;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Cluster 集群的实现，里面有两个集合为临时实例集合和持久实例集合，然后它属于一个Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cluster</span> <span class="keyword">extends</span> <span class="title class_">com</span>.alibaba.nacos.api.naming.pojo.Cluster <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLUSTER_NAME_SYNTAX</span> <span class="operator">=</span> <span class="string">&quot;[0-9a-zA-Z-]+&quot;</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8940123791150907510L</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * a addition for same site routing, can group multiple sites into a region, like Hangzhou, Shanghai, etc.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sitegroup</span> <span class="operator">=</span> StringUtils.EMPTY;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">defCkport</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">defIpPort</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> HealthCheckTask checkTask;</span><br><span class="line"><span class="comment">// 持久实例集合</span></span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Set&lt;Instance&gt; persistentInstances = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 临时实例集合</span></span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Set&lt;Instance&gt; ephemeralInstances = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> Service service;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@JsonIgnore</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">inited</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">private</span> Map&lt;String, String&gt; metadata = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>Instance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instance</span> <span class="keyword">extends</span> <span class="title class_">com</span>.alibaba.nacos.api.naming.pojo.Instance <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MAX_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">10000.0D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MIN_POSITIVE_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">0.01D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MIN_WEIGHT_VALUE</span> <span class="operator">=</span> <span class="number">0.00D</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6527721638428975306L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastBeat</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JsonIgnore</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">mockValid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 不健康状态的标记 为true的时候就表示实例为不健康 当前实例被标记</span></span><br><span class="line">    <span class="comment">// 对于临时实例，永久为false 即该属性对临时实例没有意义</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String tenant;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String app;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ONLY_DIGIT_AND_DOT</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d|\\.)+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPLITER</span> <span class="operator">=</span> <span class="string">&quot;_&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Server-处理client注册请求"><a href="#Server-处理client注册请求" class="headerlink" title="Server 处理client注册请求"></a>Server 处理client注册请求</h4><p>InstanceController就是处理和实例相关的信息，我们定位到这个类直接根据方法名找到对应方法就可以阅读源码了。直接定为到register方法，这里就是处理client注册请求的地方。具体做的事情：</p><ol><li>解析参数</li><li>通过请求参数组装instance</li><li>把instance写入注册表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@CanDistro</span></span><br><span class="line"> <span class="meta">@PostMapping</span></span><br><span class="line"> <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">final</span> <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils</span><br><span class="line">             .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">     <span class="comment">// 请求中不包含servicname 报错</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line"><span class="comment">// 合法检验</span></span><br><span class="line">     NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">     <span class="comment">// 通过请求参数组装instance</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> parseInstance(request);</span><br><span class="line">     <span class="comment">// 把instance写入注册表</span></span><br><span class="line">     serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们先来看如何通过请求参数组装一个instance，其实还是在加工上层方法传递过来的请求属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Instance <span class="title function_">parseInstance</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">        <span class="type">String</span> <span class="variable">app</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;app&quot;</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过请求中的各种属性值构建一个instance</span></span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getIpAddress(request);</span><br><span class="line">        instance.setApp(app);</span><br><span class="line">        instance.setServiceName(serviceName);</span><br><span class="line">        <span class="comment">// Generate simple instance id first. This value would be updated according to</span></span><br><span class="line">        <span class="comment">// INSTANCE_ID_GENERATOR.</span></span><br><span class="line">        instance.setInstanceId(instance.generateInstanceId());</span><br><span class="line">        instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line">        <span class="type">String</span> <span class="variable">metadata</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;metadata&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(metadata)) &#123;</span><br><span class="line">            instance.setMetadata(UtilsAndCommons.parseMetadata(metadata));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// instance验证合法检验 具体就是IP是否合法 权重是否为有效范围内</span></span><br><span class="line">        instance.validate();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看到底是怎么把instance注册到注册表中，这里是ServiceManager来管理的，上面提到这个类就是专门来管理服务注册之类的事情，进入registerInstance方法中，看它是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 如果没有service 就创建一个service 然后配置一些信息放入注册表 </span></span><br><span class="line">        createEmptyService(namespaceId, serviceName, instance.isEphemeral());</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM,</span><br><span class="line">                    <span class="string">&quot;service not found, namespace: &quot;</span> + namespaceId + <span class="string">&quot;, service: &quot;</span> + serviceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把instance写入到service</span></span><br><span class="line">        addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先看 createEmptyService(namespaceId, serviceName, instance.isEphemeral())，他最终调用的是createServiceIfAbsent方法，进入这个方法内部看看，其实就是如果在注册表中获取不到service，就创建一个，然后进行赋值，前面的其实都很清楚，关键是要看看 putServiceAndInit(service);是做了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createServiceIfAbsent</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> local, Cluster cluster)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 拿到一个service 如果没有就new 一个</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Loggers.SRV_LOG.info(<span class="string">&quot;creating empty service &#123;&#125;:&#123;&#125;&quot;</span>, namespaceId, serviceName);</span><br><span class="line">            service = <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">            <span class="comment">// 属性赋值</span></span><br><span class="line">            service.setName(serviceName);</span><br><span class="line">            service.setNamespaceId(namespaceId);</span><br><span class="line">            service.setGroupName(NamingUtils.getGroupName(serviceName));</span><br><span class="line">            <span class="comment">// now validate the service. if failed, exception will be thrown</span></span><br><span class="line">            service.setLastModifiedMillis(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">// 重新计算校验和</span></span><br><span class="line">            service.recalculateChecksum();</span><br><span class="line">            <span class="keyword">if</span> (cluster != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 和cluster建立联系</span></span><br><span class="line">                cluster.setService(service);</span><br><span class="line">                service.getClusterMap().put(cluster.getName(), cluster);</span><br><span class="line">            &#125;</span><br><span class="line">            service.validate();</span><br><span class="line">            <span class="comment">// 做了一些初始化</span></span><br><span class="line">            putServiceAndInit(service);</span><br><span class="line">            <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">                <span class="comment">// 对持久化服务加一个同步任务</span></span><br><span class="line">                addOrReplaceService(service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来到 putServiceAndInit(service);方法内部，做的事情就是写入注册表，开始心跳检测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putServiceAndInit</span><span class="params">(Service service)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">       <span class="comment">// 把service写入注册表 DCL写法 </span></span><br><span class="line">       putService(service);</span><br><span class="line">       service = getService(service.getNamespaceId(), service.getName());</span><br><span class="line">       <span class="comment">// 内部健康检测任务 定期清除过期instance 当前service所有的cluster所有的健康检查任务开启</span></span><br><span class="line">       service.init();</span><br><span class="line">    <span class="comment">// 给nacos的持久实例 临时实例添加监听</span></span><br><span class="line">       consistencyService</span><br><span class="line">               .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="literal">true</span>), service);</span><br><span class="line">       consistencyService</span><br><span class="line">               .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="literal">false</span>), service);</span><br><span class="line">       Loggers.SRV_LOG.info(<span class="string">&quot;[NEW-SERVICE] &#123;&#125;&quot;</span>, service.toJson());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>至此，createEmptyService(namespaceId, serviceName, instance.isEphemeral());方法说完了，然后开始第二步把instance写入到service，也就是addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);方法。进入这个方法内部，做的事情就是修改service的instance列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// ephemeral 默认是true 是否为临时实例 -&gt; 实例是否持久化 -&gt; AP or CP</span></span><br><span class="line">        <span class="comment">//com.alibaba.nacos.naming.ephemeral.namespaceId##serviceName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">        <span class="comment">// 从注册表获取service</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"><span class="comment">// 将要注册的instance写入到service中 也就是写入到注册表</span></span><br><span class="line">        <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">            <span class="comment">// 修改当前service的instance列表，这个修改是两者，一是添加二是删除</span></span><br><span class="line">            List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">            <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line">            instances.setInstanceList(instanceList);</span><br><span class="line">            consistencyService.put(key, instances);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入addIpAddresses(service, ephemeral, ips)方法，看看更新service的instance列表是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">updateIpAddresses</span><span class="params">(Service service, String action, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"><span class="comment">// 从其他nacos获取当前服务数据 临时实例</span></span><br><span class="line">        <span class="type">Datum</span> <span class="variable">datum</span> <span class="operator">=</span> consistencyService</span><br><span class="line">                .get(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), ephemeral));</span><br><span class="line"><span class="comment">// 获取本地注册表中当前服务的所有临时实例</span></span><br><span class="line">        List&lt;Instance&gt; currentIPs = service.allIPs(ephemeral);</span><br><span class="line">        Map&lt;String, Instance&gt; currentInstances = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(currentIPs.size());</span><br><span class="line">        Set&lt;String&gt; currentInstanceIds = Sets.newHashSet();</span><br><span class="line"><span class="comment">// 遍历注册表中所有实例 </span></span><br><span class="line">        <span class="keyword">for</span> (Instance instance : currentIPs) &#123;</span><br><span class="line">            <span class="comment">// ip:port -&gt; instance 写入到map中</span></span><br><span class="line">            currentInstances.put(instance.toIpAddr(), instance);</span><br><span class="line">            <span class="comment">// 把实例id写入到set中</span></span><br><span class="line">            currentInstanceIds.add(instance.getInstanceId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Instance&gt; instanceMap;</span><br><span class="line">    <span class="comment">// 外来的数据不为空</span></span><br><span class="line">        <span class="keyword">if</span> (datum != <span class="literal">null</span> &amp;&amp; <span class="literal">null</span> != datum.value) &#123;</span><br><span class="line">            <span class="comment">// 参数为外来的instances 和 本地currentInstances map</span></span><br><span class="line">            <span class="comment">// 做的事情大概就是把本地map的instance数据替换掉外来数据中相同主机（ip+port）的instance数据</span></span><br><span class="line">            instanceMap = setValid(((Instances) datum.value).getInstanceList(), currentInstances);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            instanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(ips.length);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 遍历注册的实例</span></span><br><span class="line">        <span class="keyword">for</span> (Instance instance : ips) &#123;</span><br><span class="line">            <span class="comment">// 如果当前service不包含这个instance的cluster那就创建一个</span></span><br><span class="line">            <span class="keyword">if</span> (!service.getClusterMap().containsKey(instance.getClusterName())) &#123;</span><br><span class="line">                <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cluster</span>(instance.getClusterName(), service);</span><br><span class="line">                <span class="comment">// cluster初始化的健康检测任务</span></span><br><span class="line">                cluster.init();</span><br><span class="line">                service.getClusterMap().put(instance.getClusterName(), cluster);</span><br><span class="line">                Loggers.SRV_LOG</span><br><span class="line">                        .warn(<span class="string">&quot;cluster: &#123;&#125; not found, ip: &#123;&#125;, will create new cluster with default configuration.&quot;</span>,</span><br><span class="line">                                instance.getClusterName(), instance.toJson());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 是删除操作吗？</span></span><br><span class="line">            <span class="keyword">if</span> (UtilsAndCommons.UPDATE_INSTANCE_ACTION_REMOVE.equals(action)) &#123;</span><br><span class="line">                instanceMap.remove(instance.getDatumKey());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 添加操作 </span></span><br><span class="line">                <span class="comment">// 把当前instance添加到外来的和本地数据综合之后的map中 也就是最新数据</span></span><br><span class="line">                <span class="type">Instance</span> <span class="variable">oldInstance</span> <span class="operator">=</span> instanceMap.get(instance.getDatumKey());</span><br><span class="line">                <span class="keyword">if</span> (oldInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance.setInstanceId(oldInstance.getInstanceId());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    instance.setInstanceId(instance.generateInstanceId(currentInstanceIds));</span><br><span class="line">                &#125;</span><br><span class="line">                instanceMap.put(instance.getDatumKey(), instance);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instanceMap.size() &lt;= <span class="number">0</span> &amp;&amp; UtilsAndCommons.UPDATE_INSTANCE_ACTION_ADD.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;ip list can not be empty, service: &quot;</span> + service.getName() + <span class="string">&quot;, ip list: &quot;</span> + JacksonUtils</span><br><span class="line">                            .toJson(instanceMap.values()));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 返回 最新数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(instanceMap.values());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到addInstance()方法，然后看最后两步，经过上面操作，我们获得了含有本地service信息，其他nacos服务传递过来的service信息合并后的最新的instance，再加上我们注册的instance的一个List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// ephemeral 默认是true 是否为临时实例 -&gt; 实例是否持久化 -&gt; AP or CP</span></span><br><span class="line">        <span class="comment">//com.alibaba.nacos.naming.ephemeral.namespaceId##serviceName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">        <span class="comment">// 从注册表获取service</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"><span class="comment">// 将要注册的instance写入到service中 也就是写入到注册表</span></span><br><span class="line">        <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">            <span class="comment">// 修改当前service的instance列表，这个修改是两者，一是添加二是删除</span></span><br><span class="line">            List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">            <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line">            <span class="comment">// 获取到最新的数据</span></span><br><span class="line">            instances.setInstanceList(instanceList);</span><br><span class="line">            <span class="comment">// 同步服务，同步这个数据到其他nacos服务器</span></span><br><span class="line">            consistencyService.put(key, instances);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="开启Service健康检测定时任务"><a href="#开启Service健康检测定时任务" class="headerlink" title="开启Service健康检测定时任务"></a>开启Service健康检测定时任务</h4><p>来到 putServiceAndInit(service);方法内部，上面已经分析如何写入到注册表，现在开始看如何心跳检测。进入putServiceAndInit(service)内部的service.init()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 开始定时清除过期instance</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line">    <span class="comment">// 遍历service的cluster</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">        entry.getValue().setService(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 开启每个cluster的健康检测</span></span><br><span class="line">        entry.getValue().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>看一下心跳检测是怎么做的，一句话就是5S检测一次，15S没发送心跳就把实例状态改为不健康，30S没收到就摘除这个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">scheduleCheck</span><span class="params">(ClientBeatCheckTask task)</span> &#123;</span><br><span class="line">       futureMap.computeIfAbsent(task.taskKey(),</span><br><span class="line">               <span class="comment">// 也就是5S检测一次</span></span><br><span class="line">               k -&gt; GlobalExecutor.scheduleNamingHealth(task, <span class="number">5000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 心跳检测的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 集群心跳任务检测，根据服务名取模到一个区间 就是一个服务 多个实例只有一个机器执行心跳检测</span></span><br><span class="line">           <span class="keyword">if</span> (!getDistroMapper().responsible(service.getName())) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 没开启健康检测就退出</span></span><br><span class="line">           <span class="keyword">if</span> (!getSwitchDomain().isHealthCheckEnabled()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 这个服务所有临时实例</span></span><br><span class="line">           List&lt;Instance&gt; instances = service.allIPs(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// first set health status of instances:</span></span><br><span class="line">           <span class="comment">// 超过15S就过期</span></span><br><span class="line">           <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">               <span class="comment">// 当前时间 - 实例上次心跳 &gt; 15秒</span></span><br><span class="line">               <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) &#123;</span><br><span class="line">                  <span class="comment">// mark标记是持久实例 如果instance是临时实例</span></span><br><span class="line">                   <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (instance.isHealthy()) &#123;</span><br><span class="line">                           <span class="comment">// 实例健康状态 -&gt; false</span></span><br><span class="line">                           instance.setHealthy(<span class="literal">false</span>);</span><br><span class="line">                           Loggers.EVT_LOG</span><br><span class="line">                                   .info(<span class="string">&quot;&#123;POS&#125; &#123;IP-DISABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client timeout after &#123;&#125;, last beat: &#123;&#125;&quot;</span>,</span><br><span class="line">                                           instance.getIp(), instance.getPort(), instance.getClusterName(),</span><br><span class="line">                                           service.getName(), UtilsAndCommons.LOCALHOST_SITE,</span><br><span class="line">                                           instance.getInstanceHeartBeatTimeOut(), instance.getLastBeat());</span><br><span class="line">                           <span class="comment">// 发布状态变更事件</span></span><br><span class="line">                           getPushService().serviceChanged(service);</span><br><span class="line">                           ApplicationUtils.publishEvent(<span class="keyword">new</span> <span class="title class_">InstanceHeartbeatTimeoutEvent</span>(<span class="built_in">this</span>, instance));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!getGlobalConfig().isExpireInstance()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// then remove obsolete instances:</span></span><br><span class="line">           <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line"><span class="comment">// 临时实例</span></span><br><span class="line">               <span class="keyword">if</span> (instance.isMarked()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果超过30S了 直接吧这个机器删掉</span></span><br><span class="line">               <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getIpDeleteTimeout()) &#123;</span><br><span class="line">                   <span class="comment">// delete instance</span></span><br><span class="line">                   Loggers.SRV_LOG.info(<span class="string">&quot;[AUTO-DELETE-IP] service: &#123;&#125;, ip: &#123;&#125;&quot;</span>, service.getName(),</span><br><span class="line">                           JacksonUtils.toJson(instance));</span><br><span class="line">                   <span class="comment">// 删除实例 这是不是删除的server的注册表</span></span><br><span class="line">                   deleteIp(instance);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;Exception while processing client beat time out.&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里的deleteIp(instance)是个异步，通过向nacos server发送一个请求，然后再做的删除，请求的就是InstanceController。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteIp</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            NamingProxy.<span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> NamingProxy.Request.newRequest();</span><br><span class="line">            request.appendParam(<span class="string">&quot;ip&quot;</span>, instance.getIp()).appendParam(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()))</span><br><span class="line">                    .appendParam(<span class="string">&quot;ephemeral&quot;</span>, <span class="string">&quot;true&quot;</span>).appendParam(<span class="string">&quot;clusterName&quot;</span>, instance.getClusterName())</span><br><span class="line">                    .appendParam(<span class="string">&quot;serviceName&quot;</span>, service.getName()).appendParam(<span class="string">&quot;namespaceId&quot;</span>, service.getNamespaceId());</span><br><span class="line">            <span class="comment">// 自己请求自己，发送Delete请求，删除实例</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://&quot;</span> + IPUtil.localHostIP() + IPUtil.IP_PORT_SPLITER + EnvUtil.getPort() + EnvUtil.getContextPath()</span><br><span class="line">                    + UtilsAndCommons.NACOS_NAMING_CONTEXT + <span class="string">&quot;/instance?&quot;</span> + request.toUrl();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// delete instance asynchronously:</span></span><br><span class="line">            HttpClient.asyncHttpDelete(url, <span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(RestResult&lt;String&gt; result)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!result.ok()) &#123;</span><br><span class="line">                        Loggers.SRV_LOG</span><br><span class="line">                                .error(<span class="string">&quot;[IP-DEAD] failed to delete ip automatically, ip: &#123;&#125;, caused &#123;&#125;, resp code: &#123;&#125;&quot;</span>,</span><br><span class="line">                                        instance.toJson(), result.getMessage(), result.getCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                    Loggers.SRV_LOG</span><br><span class="line">                            .error(<span class="string">&quot;[IP-DEAD] failed to delete ip automatically, ip: &#123;&#125;, error: &#123;&#125;&quot;</span>, instance.toJson(),</span><br><span class="line">                                    throwable);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancel</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.SRV_LOG</span><br><span class="line">                    .error(<span class="string">&quot;[IP-DEAD] failed to delete ip automatically, ip: &#123;&#125;, error: &#123;&#125;&quot;</span>, instance.toJson(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="开启Cluster的健康检测定时任务"><a href="#开启Cluster的健康检测定时任务" class="headerlink" title="开启Cluster的健康检测定时任务"></a>开启Cluster的健康检测定时任务</h4><p>service的健康检测我们已经了解了，现在开始看cluster的健康检测，直接进入cluster.init()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init cluster.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经初始化过了 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (inited) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个健康检查任务</span></span><br><span class="line">    checkTask = <span class="keyword">new</span> <span class="title class_">HealthCheckTask</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 开启定时任务</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(checkTask);</span><br><span class="line">    inited = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看一下HealthCheckTask的run()方法，还是一样的套路，在结束之前再重新开启一个任务。具体的任务是在healthCheckProcessor.process(this);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (distroMapper.responsible(cluster.getService().getName()) &amp;&amp; switchDomain</span><br><span class="line">                .isHealthCheckEnabled(cluster.getService().getName())) &#123;</span><br><span class="line">            <span class="comment">// 健康检查处理器处理</span></span><br><span class="line">            healthCheckProcessor.process(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                Loggers.EVT_LOG</span><br><span class="line">                        .debug(<span class="string">&quot;[HEALTH-CHECK] schedule health check task: &#123;&#125;&quot;</span>, cluster.getService().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Loggers.SRV_LOG</span><br><span class="line">                .error(<span class="string">&quot;[HEALTH-CHECK] error while process health check for &#123;&#125;:&#123;&#125;&quot;</span>, cluster.getService().getName(),</span><br><span class="line">                        cluster.getName(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cancelled) &#123;</span><br><span class="line">            <span class="comment">// 重复执行</span></span><br><span class="line">            HealthCheckReactor.scheduleCheck(<span class="built_in">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// worst == 0 means never checked</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getCheckRtWorst() &gt; <span class="number">0</span> &amp;&amp; switchDomain.isHealthCheckEnabled(cluster.getService().getName())</span><br><span class="line">                    &amp;&amp; distroMapper.responsible(cluster.getService().getName())) &#123;</span><br><span class="line">                <span class="comment">// TLog doesn&#x27;t support float so we must convert it into long</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span></span><br><span class="line">                        ((<span class="built_in">this</span>.getCheckRtLast() - <span class="built_in">this</span>.getCheckRtLastLast()) * <span class="number">10000</span>) / <span class="built_in">this</span>.getCheckRtLastLast();</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">this</span>.setCheckRtLastLast(<span class="built_in">this</span>.getCheckRtLast());</span><br><span class="line">                </span><br><span class="line">                <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> <span class="built_in">this</span>.getCluster();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (Loggers.CHECK_RT.isDebugEnabled()) &#123;</span><br><span class="line">                    Loggers.CHECK_RT.debug(<span class="string">&quot;&#123;&#125;:&#123;&#125;@&#123;&#125;-&gt;normalized: &#123;&#125;, worst: &#123;&#125;, best: &#123;&#125;, last: &#123;&#125;, diff: &#123;&#125;&quot;</span>,</span><br><span class="line">                            cluster.getService().getName(), cluster.getName(), cluster.getHealthChecker().getType(),</span><br><span class="line">                            <span class="built_in">this</span>.getCheckRtNormalized(), <span class="built_in">this</span>.getCheckRtWorst(), <span class="built_in">this</span>.getCheckRtBest(),</span><br><span class="line">                            <span class="built_in">this</span>.getCheckRtLast(), diff);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>healthCheckProcessor.process(this)，这是一个接口的实现类里面的处理方法，这个接口有很多实现类。我们这里用到的是最后一个，所以来看这个方法是什么样的。就是拿出来所有的持久而且是健康的实例，然后遍历，根据他们的IP port构建心跳，然后放入队列中，后面会有线程处理队列。这里其实就是对持久实例的健康检测，Server给Client发心跳。那么必须有一个对队列操作的对象。</p><p><img src="https://raw.githubusercontent.com/eurekawm/picgo/main/img/202203221208632.png" alt="image-20220322120835506"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(HealthCheckTask task)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取所有持久实例</span></span><br><span class="line">       List&lt;Instance&gt; ips = task.getCluster().allIPs(<span class="literal">false</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isEmpty(ips)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (Instance ip : ips) &#123;</span><br><span class="line">           <span class="comment">// 过期的就不管</span></span><br><span class="line">           <span class="keyword">if</span> (ip.isMarked()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (SRV_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                   SRV_LOG.debug(<span class="string">&quot;tcp check, ip is marked as to skip health check, ip:&quot;</span> + ip.getIp());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (!ip.markChecking()) &#123;</span><br><span class="line">               SRV_LOG.warn(<span class="string">&quot;tcp check started before last one finished, service: &quot;</span> + task.getCluster().getService()</span><br><span class="line">                       .getName() + <span class="string">&quot;:&quot;</span> + task.getCluster().getName() + <span class="string">&quot;:&quot;</span> + ip.getIp() + <span class="string">&quot;:&quot;</span> + ip.getPort());</span><br><span class="line">               </span><br><span class="line">               healthCheckCommon</span><br><span class="line">                       .reEvaluateCheckRT(task.getCheckRtNormalized() * <span class="number">2</span>, task, switchDomain.getTcpHealthParams());</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 生成一个心跳</span></span><br><span class="line">           <span class="type">Beat</span> <span class="variable">beat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Beat</span>(ip, task);</span><br><span class="line">           <span class="comment">// 放入队列中</span></span><br><span class="line">           taskQueue.add(beat);</span><br><span class="line">           MetricsMonitor.getTcpHealthCheckMonitor().incrementAndGet();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后看一下拿到队列了的这个beat是怎么处理的，拿到这个beat然后封装到list里，然后放到线程池里面执行，也就是给客户端发送请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Collection&lt;Callable&lt;Void&gt;&gt; tasks = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Beat</span> <span class="variable">beat</span> <span class="operator">=</span> taskQueue.poll(CONNECT_TIMEOUT_MS / <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">if</span> (beat == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tasks.add(<span class="keyword">new</span> <span class="title class_">TaskProcessor</span>(beat));</span><br><span class="line">    &#125; <span class="keyword">while</span> (taskQueue.size() &gt; <span class="number">0</span> &amp;&amp; tasks.size() &lt; NIO_THREAD_COUNT * <span class="number">64</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Future&lt;?&gt; f : GlobalExecutor.invokeAllTcpSuperSenseTask(tasks)) &#123;</span><br><span class="line">        f.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Nacos-Server处理注销请求"><a href="#Nacos-Server处理注销请求" class="headerlink" title="Nacos Server处理注销请求"></a>Nacos Server处理注销请求</h4><p>上面提到Service健康检查的时候如果发现实例已经30S没发送心跳，那么我们就会删除这个实例，具体的删除就是向InstanceController发送@Delete请求，那么我们现在就来分析Nacos Server在删除实例的时候具体是怎么做的，首先来到这个Controller的方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line">    <span class="meta">@DeleteMapping</span></span><br><span class="line">    <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deregister</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 前面是根据请求参数构建对象</span></span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getIpAddress(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">        NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;remove instance from non-exist service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除实例</span></span><br><span class="line">        serviceManager.removeInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键信息是在 serviceManager.removeInstance(namespaceId, serviceName, instance.isEphemeral(), instance)，具体来看这个方法是在干嘛，也很简单就是拿到service，对其加锁然后修改。具体还是要看内部的removeInstance方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Instance... ips)</span></span><br><span class="line">            <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 从注册表获取当前service</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">            <span class="comment">// 删除Instance实例</span></span><br><span class="line">            removeInstance(namespaceId, serviceName, ephemeral, service, ips);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来到removeInstance方法内部，和之前分析的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeInstance</span><span class="params">(String namespaceId, String serviceName, <span class="type">boolean</span> ephemeral, Service service,</span></span><br><span class="line"><span class="params">                               Instance... ips)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line"><span class="comment">// 从注册表中删除实例 这里是调用的还是 com.alibaba.nacos.naming.core.ServiceManager#updateIpAddresses</span></span><br><span class="line">       List&lt;Instance&gt; instanceList = substractIpAddresses(service, ephemeral, ips);</span><br><span class="line"></span><br><span class="line">       <span class="type">Instances</span> <span class="variable">instances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instances</span>();</span><br><span class="line">       instances.setInstanceList(instanceList);</span><br><span class="line"><span class="comment">// 发生了变更 把本次变更同步给其他nacos节点</span></span><br><span class="line">       consistencyService.put(key, instances);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Server处理心跳请求"><a href="#Server处理心跳请求" class="headerlink" title="Server处理心跳请求"></a>Server处理心跳请求</h4><p>同样的Server处理心跳请求也是在InstanceController，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line">   <span class="meta">@PutMapping(&quot;/beat&quot;)</span></span><br><span class="line">   <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line">   <span class="keyword">public</span> ObjectNode <span class="title function_">beat</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 创建一个Node，返回值就是这个 后面就是围绕这个node的操作</span></span><br><span class="line">       <span class="type">ObjectNode</span> <span class="variable">result</span> <span class="operator">=</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">       result.put(SwitchEntry.CLIENT_BEAT_INTERVAL, switchDomain.getClientBeatInterval());</span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">beat</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;beat&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       <span class="type">RsInfo</span> <span class="variable">clientBeat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(beat)) &#123;</span><br><span class="line">           clientBeat = JacksonUtils.toObj(beat, RsInfo.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> WebUtils</span><br><span class="line">               .optional(request, CommonParams.CLUSTER_NAME, UtilsAndCommons.DEFAULT_CLUSTER_NAME);</span><br><span class="line">       <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;ip&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">       <span class="comment">// 获取到客户端传递来的client端口 将来用来UDP通信</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(WebUtils.optional(request, <span class="string">&quot;port&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">       <span class="keyword">if</span> (clientBeat != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotBlank(clientBeat.getCluster())) &#123;</span><br><span class="line">               clusterName = clientBeat.getCluster();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// fix #2533</span></span><br><span class="line">               clientBeat.setCluster(clusterName);</span><br><span class="line">           &#125;</span><br><span class="line">           ip = clientBeat.getIp();</span><br><span class="line">           port = clientBeat.getPort();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">       <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">       NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">       Loggers.SRV_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] full arguments: beat: &#123;&#125;, serviceName: &#123;&#125;&quot;</span>, clientBeat, serviceName);</span><br><span class="line">       <span class="comment">// 获取当前注册表中的发送请求对应的client对应的Instance</span></span><br><span class="line">       <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> serviceManager.getInstance(namespaceId, serviceName, clusterName, ip, port);</span><br><span class="line">       <span class="comment">// 处理注册表中不存在该client的instance的情况</span></span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (clientBeat == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 如果请求中获取到的Beat，即client端的BeatInfo为空 请求中未携带心跳数据</span></span><br><span class="line">               result.put(CommonParams.CODE, NamingResponseCode.RESOURCE_NOT_FOUND);</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;[CLIENT-BEAT] The instance has been removed for health mechanism, &quot;</span></span><br><span class="line">                   + <span class="string">&quot;perform data compensation operations, beat: &#123;&#125;, serviceName: &#123;&#125;&quot;</span>, clientBeat, serviceName);</span><br><span class="line">           <span class="comment">// 注册表中没有这个instance 但是发送的请求中是有心跳信息的</span></span><br><span class="line">           <span class="comment">// 利用心跳信息创建一个</span></span><br><span class="line">           <span class="comment">// 注册请求还没到 心跳先到了 就是这种情况</span></span><br><span class="line">           instance = <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">           instance.setPort(clientBeat.getPort());</span><br><span class="line">           instance.setIp(clientBeat.getIp());</span><br><span class="line">           instance.setWeight(clientBeat.getWeight());</span><br><span class="line">           instance.setMetadata(clientBeat.getMetadata());</span><br><span class="line">           instance.setClusterName(clusterName);</span><br><span class="line">           instance.setServiceName(serviceName);</span><br><span class="line">           instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">           instance.setEphemeral(clientBeat.isEphemeral());</span><br><span class="line">           <span class="comment">// 注册到注册表中</span></span><br><span class="line">           serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.SERVER_ERROR,</span><br><span class="line">                   <span class="string">&quot;service not found: &quot;</span> + serviceName + <span class="string">&quot;@&quot;</span> + namespaceId);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (clientBeat == <span class="literal">null</span>) &#123;</span><br><span class="line">           clientBeat = <span class="keyword">new</span> <span class="title class_">RsInfo</span>();</span><br><span class="line">           clientBeat.setIp(ip);</span><br><span class="line">           clientBeat.setPort(port);</span><br><span class="line">           clientBeat.setCluster(clusterName);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 真正处理心跳</span></span><br><span class="line">       service.processClientBeat(clientBeat);</span><br><span class="line">       </span><br><span class="line">       result.put(CommonParams.CODE, NamingResponseCode.OK);</span><br><span class="line">       <span class="keyword">if</span> (instance.containsMetadata(PreservedMetadataKeys.HEART_BEAT_INTERVAL)) &#123;</span><br><span class="line">           result.put(SwitchEntry.CLIENT_BEAT_INTERVAL, instance.getInstanceHeartBeatInterval());</span><br><span class="line">       &#125;</span><br><span class="line">       result.put(SwitchEntry.LIGHT_BEAT_ENABLED, switchDomain.isLightBeatEnabled());</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入真正处理心跳的方法内部，我们可以看到就是根据service和心跳消息构建一个处理任务，处理任务就是找到对应的的instance更新其最后心跳事件 如果这个实例之前已经是不健康的了，现在心跳来了，那么就更新为健康的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processClientBeat</span><span class="params">(<span class="keyword">final</span> RsInfo rsInfo)</span> &#123;</span><br><span class="line">      <span class="comment">// 这个处理器实现了run方法</span></span><br><span class="line">      <span class="type">ClientBeatProcessor</span> <span class="variable">clientBeatProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientBeatProcessor</span>();</span><br><span class="line">      clientBeatProcessor.setService(<span class="built_in">this</span>);</span><br><span class="line">      clientBeatProcessor.setRsInfo(rsInfo);</span><br><span class="line">      <span class="comment">// 开启一个立即执行的任务 执行任务的run</span></span><br><span class="line">      HealthCheckReactor.scheduleNow(clientBeatProcessor);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 获取到注册表的service</span></span><br><span class="line">      <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="built_in">this</span>.service;</span><br><span class="line">      <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">          Loggers.EVT_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] processing beat: &#123;&#125;&quot;</span>, rsInfo.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从心跳信息中获取一些信息</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> rsInfo.getIp();</span><br><span class="line">      <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> rsInfo.getCluster();</span><br><span class="line">      <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> rsInfo.getPort();</span><br><span class="line">      <span class="comment">// 获取这个service对应的cluster</span></span><br><span class="line">      <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> service.getClusterMap().get(clusterName);</span><br><span class="line">      <span class="comment">// 获取临时实例 因为是客户端发送心跳到server</span></span><br><span class="line">      List&lt;Instance&gt; instances = cluster.allIPs(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 遍历临时实例</span></span><br><span class="line">      <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">          <span class="comment">// 如果这个实例的IP port和当前心跳的instance的相同</span></span><br><span class="line">          <span class="keyword">if</span> (instance.getIp().equals(ip) &amp;&amp; instance.getPort() == port) &#123;</span><br><span class="line">              <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                  Loggers.EVT_LOG.debug(<span class="string">&quot;[CLIENT-BEAT] refresh beat: &#123;&#125;&quot;</span>, rsInfo.toString());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 更新这个实例最新的心跳事件</span></span><br><span class="line">              instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line">              <span class="keyword">if</span> (!instance.isMarked() &amp;&amp; !instance.isHealthy()) &#123;</span><br><span class="line">                  <span class="comment">// 如果不是临时节点 而且之前标记为不健康</span></span><br><span class="line">                  <span class="comment">// 既然心跳都来了，那么就更新为健康的</span></span><br><span class="line">                  instance.setHealthy(<span class="literal">true</span>);</span><br><span class="line">                  Loggers.EVT_LOG</span><br><span class="line">                          .info(<span class="string">&quot;service: &#123;&#125; &#123;POS&#125; &#123;IP-ENABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client beat ok&quot;</span>,</span><br><span class="line">                                  cluster.getService().getName(), ip, port, cluster.getName(),</span><br><span class="line">                                  UtilsAndCommons.LOCALHOST_SITE);</span><br><span class="line">                  <span class="comment">// 发布变更事件 后面分析UDP通知客户端</span></span><br><span class="line">                  getPushService().serviceChanged(service);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Server处理客户端订阅"><a href="#Server处理客户端订阅" class="headerlink" title="Server处理客户端订阅"></a>Server处理客户端订阅</h4><p>客户端订阅服务，服务端的实例变更后，会UDP通知客户端，我们先来到服务订阅接口，获取参数，获取udp端口，然后处理请求，在doSrvIpxt处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">  <span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.READ)</span></span><br><span class="line">  <span class="keyword">public</span> ObjectNode <span class="title function_">list</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">      <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">      NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">      <span class="comment">// 用于指定客户端类型 </span></span><br><span class="line">      <span class="type">String</span> <span class="variable">agent</span> <span class="operator">=</span> WebUtils.getUserAgent(request);</span><br><span class="line">      <span class="type">String</span> <span class="variable">clusters</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;clusters&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;clientIP&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      <span class="comment">// UDP端口，用于变更通知 </span></span><br><span class="line">      <span class="type">int</span> <span class="variable">udpPort</span> <span class="operator">=</span> Integer.parseInt(WebUtils.optional(request, <span class="string">&quot;udpPort&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">      <span class="type">String</span> <span class="variable">env</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;env&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isCheck</span> <span class="operator">=</span> Boolean.parseBoolean(WebUtils.optional(request, <span class="string">&quot;isCheck&quot;</span>, <span class="string">&quot;false&quot;</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="type">String</span> <span class="variable">app</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;app&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      </span><br><span class="line">      <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> WebUtils.optional(request, <span class="string">&quot;tid&quot;</span>, StringUtils.EMPTY);</span><br><span class="line">      </span><br><span class="line">      <span class="type">boolean</span> <span class="variable">healthyOnly</span> <span class="operator">=</span> Boolean.parseBoolean(WebUtils.optional(request, <span class="string">&quot;healthyOnly&quot;</span>, <span class="string">&quot;false&quot;</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> doSrvIpxt(namespaceId, serviceName, agent, clusters, clientIP, udpPort, env, isCheck, app, tenant,</span><br><span class="line">              healthyOnly);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进入具体的处理方法，先是创建根据agent创建一个UDP Client然后放入map中，后面会根据这个map中client发送UDP请求，然后从注册表中获取所有可用的instance并封装称为json。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get service full information with instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> namespaceId namespace id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName service name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agent       agent infor string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusters    cluster names</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientIP    client ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> udpPort     push udp port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> env         env</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isCheck     is check request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> app         app name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tid         tenant</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> healthyOnly whether only for healthy check</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service full information with instances</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception any error during handle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ObjectNode <span class="title function_">doSrvIpxt</span><span class="params">(String namespaceId, String serviceName, String agent, String clusters, String clientIP,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> udpPort, String env, <span class="type">boolean</span> isCheck, String app, String tid, <span class="type">boolean</span> healthyOnly)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 根据不同的agent生成不同的ClientInfo 比如java agent生成一个java的ClientInfo</span></span><br><span class="line">        <span class="type">ClientInfo</span> <span class="variable">clientInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientInfo</span>(agent);</span><br><span class="line">        <span class="comment">// 这个就是返回的结果 后续代码就是对这个node各种操作</span></span><br><span class="line">        <span class="type">ObjectNode</span> <span class="variable">result</span> <span class="operator">=</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        <span class="comment">// 获取注册表的当前服务</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">        <span class="type">long</span> <span class="variable">cacheMillis</span> <span class="operator">=</span> switchDomain.getDefaultCacheMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// now try to enable the push</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (udpPort &gt; <span class="number">0</span> &amp;&amp; pushService.canEnablePush(agent)) &#123;</span><br><span class="line">                <span class="comment">// 创建当前发出订阅请求的Nacos client的UDP Client并放入缓存map中</span></span><br><span class="line">                <span class="comment">// 在UDP通信当中 Nacos Client充当是UDP Server</span></span><br><span class="line">                pushService</span><br><span class="line">                        .addClient(namespaceId, serviceName, clusters, agent, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(clientIP, udpPort),</span><br><span class="line">                                pushDataSource, tid, app);</span><br><span class="line">                cacheMillis = switchDomain.getPushCacheMillis(serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.SRV_LOG</span><br><span class="line">                    .error(<span class="string">&quot;[NACOS-API] failed to added push client &#123;&#125;, &#123;&#125;:&#123;&#125;&quot;</span>, clientInfo, clientIP, udpPort, e);</span><br><span class="line">            cacheMillis = switchDomain.getDefaultCacheMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果注册表中没有这个服务，则直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Loggers.SRV_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                Loggers.SRV_LOG.debug(<span class="string">&quot;no instance to serve for service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">            result.put(<span class="string">&quot;name&quot;</span>, serviceName);</span><br><span class="line">            result.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">            result.put(<span class="string">&quot;cacheMillis&quot;</span>, cacheMillis);</span><br><span class="line">            result.replace(<span class="string">&quot;hosts&quot;</span>, JacksonUtils.createEmptyArrayNode());</span><br><span class="line">            <span class="keyword">return</span> result; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否可用 如果不可用直接跑出异常</span></span><br><span class="line">        checkIfDisabled(service);</span><br><span class="line">        </span><br><span class="line">        List&lt;Instance&gt; srvedIPs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有可用实例</span></span><br><span class="line">        srvedIPs = service.srvIPs(Arrays.asList(StringUtils.split(clusters, <span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// filter ips using selector:</span></span><br><span class="line">        <span class="comment">// 选择器根据选择算法</span></span><br><span class="line">        <span class="comment">// 如果选择器不空 则根据选择算法选择可用的instance</span></span><br><span class="line">        <span class="keyword">if</span> (service.getSelector() != <span class="literal">null</span> &amp;&amp; StringUtils.isNotBlank(clientIP)) &#123;</span><br><span class="line">            srvedIPs = service.getSelector().select(clientIP, srvedIPs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有可用的instance 返回的Hosts还是为空的 直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(srvedIPs)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (Loggers.SRV_LOG.isDebugEnabled()) &#123;</span><br><span class="line">                Loggers.SRV_LOG.debug(<span class="string">&quot;no instance to serve for service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (clientInfo.type == ClientInfo.ClientType.JAVA</span><br><span class="line">                    &amp;&amp; clientInfo.version.compareTo(VersionUtil.parseVersion(<span class="string">&quot;1.0.0&quot;</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                result.put(<span class="string">&quot;dom&quot;</span>, serviceName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.put(<span class="string">&quot;dom&quot;</span>, NamingUtils.getServiceName(serviceName));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.put(<span class="string">&quot;name&quot;</span>, serviceName);</span><br><span class="line">            result.put(<span class="string">&quot;cacheMillis&quot;</span>, cacheMillis);</span><br><span class="line">            result.put(<span class="string">&quot;lastRefTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">            result.put(<span class="string">&quot;checksum&quot;</span>, service.getChecksum());</span><br><span class="line">            result.put(<span class="string">&quot;useSpecifiedURL&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            result.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">            result.put(<span class="string">&quot;env&quot;</span>, env);</span><br><span class="line">            result.set(<span class="string">&quot;hosts&quot;</span>, JacksonUtils.createEmptyArrayNode());</span><br><span class="line">            result.set(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.transferToJsonNode(service.getMetadata()));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里 说明是有可用的instance</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Instance&gt;&gt; ipMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 放入健康的instance</span></span><br><span class="line">        ipMap.put(Boolean.TRUE, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 放入不健康的instance</span></span><br><span class="line">        ipMap.put(Boolean.FALSE, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 把健康和不健康的实例分开放置在map中</span></span><br><span class="line">        <span class="keyword">for</span> (Instance ip : srvedIPs) &#123;</span><br><span class="line">            ipMap.get(ip.isHealthy()).add(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否需要检测instance的保护阈值 </span></span><br><span class="line">        <span class="keyword">if</span> (isCheck) &#123;</span><br><span class="line">            result.put(<span class="string">&quot;reachProtectThreshold&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取服务的保护阈值</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> service.getProtectThreshold();</span><br><span class="line">        <span class="comment">// 如果健康实例的数量/所有的instance数量 &lt;= 保护阈值 说明要启动保护机制 </span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">float</span>) ipMap.get(Boolean.TRUE).size() / srvedIPs.size() &lt;= threshold) &#123;</span><br><span class="line">            </span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;protect threshold reached, return all ips, service: &#123;&#125;&quot;</span>, serviceName);</span><br><span class="line">            <span class="keyword">if</span> (isCheck) &#123;</span><br><span class="line">                result.put(<span class="string">&quot;reachProtectThreshold&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动了保护阈值 那么消费者要调用所有的实例，这也可能导致调用到不可用的实例</span></span><br><span class="line">            <span class="comment">// 这样牺牲了调用者，但是不会吧所有请求都发给可用的实例，防止宕机</span></span><br><span class="line">            ipMap.get(Boolean.TRUE).addAll(ipMap.get(Boolean.FALSE));</span><br><span class="line">            ipMap.get(Boolean.FALSE).clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isCheck) &#123;</span><br><span class="line">            result.put(<span class="string">&quot;protectThreshold&quot;</span>, service.getProtectThreshold());</span><br><span class="line">            result.put(<span class="string">&quot;reachLocalSiteCallThreshold&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ArrayNode</span> <span class="variable">hosts</span> <span class="operator">=</span> JacksonUtils.createEmptyArrayNode();</span><br><span class="line">        <span class="comment">// 这个ipMap放的是所有健康和不健康的实例</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Boolean, List&lt;Instance&gt;&gt; entry : ipMap.entrySet()) &#123;</span><br><span class="line">            List&lt;Instance&gt; ips = entry.getValue();</span><br><span class="line">            <span class="comment">// 如果客户端只有健康的instance且当前遍历的map key为false 则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (healthyOnly &amp;&amp; !entry.getKey()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历的ips 可能是所有不健康的实例列表</span></span><br><span class="line">            <span class="comment">// 可能是所有健康的</span></span><br><span class="line">            <span class="comment">// 也可能是所有的instance列表</span></span><br><span class="line">            <span class="keyword">for</span> (Instance instance : ips) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// remove disabled instance:</span></span><br><span class="line">                <span class="comment">// 跳过禁用的instance</span></span><br><span class="line">                <span class="keyword">if</span> (!instance.isEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前遍历的instance 转换为json</span></span><br><span class="line">                <span class="type">ObjectNode</span> <span class="variable">ipObj</span> <span class="operator">=</span> JacksonUtils.createEmptyJsonNode();</span><br><span class="line">                </span><br><span class="line">                ipObj.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">                ipObj.put(<span class="string">&quot;port&quot;</span>, instance.getPort());</span><br><span class="line">                <span class="comment">// deprecated since nacos 1.0.0:</span></span><br><span class="line">                ipObj.put(<span class="string">&quot;valid&quot;</span>, entry.getKey());</span><br><span class="line">                ipObj.put(<span class="string">&quot;healthy&quot;</span>, entry.getKey());</span><br><span class="line">                ipObj.put(<span class="string">&quot;marked&quot;</span>, instance.isMarked());</span><br><span class="line">                ipObj.put(<span class="string">&quot;instanceId&quot;</span>, instance.getInstanceId());</span><br><span class="line">                ipObj.set(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.transferToJsonNode(instance.getMetadata()));</span><br><span class="line">                ipObj.put(<span class="string">&quot;enabled&quot;</span>, instance.isEnabled());</span><br><span class="line">                ipObj.put(<span class="string">&quot;weight&quot;</span>, instance.getWeight());</span><br><span class="line">                ipObj.put(<span class="string">&quot;clusterName&quot;</span>, instance.getClusterName());</span><br><span class="line">                <span class="keyword">if</span> (clientInfo.type == ClientInfo.ClientType.JAVA</span><br><span class="line">                        &amp;&amp; clientInfo.version.compareTo(VersionUtil.parseVersion(<span class="string">&quot;1.0.0&quot;</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ipObj.put(<span class="string">&quot;serviceName&quot;</span>, instance.getServiceName());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ipObj.put(<span class="string">&quot;serviceName&quot;</span>, NamingUtils.getServiceName(instance.getServiceName()));</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ipObj.put(<span class="string">&quot;ephemeral&quot;</span>, instance.isEphemeral());</span><br><span class="line">                <span class="comment">// 添加到hosts中</span></span><br><span class="line">                hosts.add(ipObj);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result.replace(<span class="string">&quot;hosts&quot;</span>, hosts);</span><br><span class="line">        <span class="keyword">if</span> (clientInfo.type == ClientInfo.ClientType.JAVA</span><br><span class="line">                &amp;&amp; clientInfo.version.compareTo(VersionUtil.parseVersion(<span class="string">&quot;1.0.0&quot;</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result.put(<span class="string">&quot;dom&quot;</span>, serviceName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.put(<span class="string">&quot;dom&quot;</span>, NamingUtils.getServiceName(serviceName));</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(<span class="string">&quot;name&quot;</span>, serviceName);</span><br><span class="line">        result.put(<span class="string">&quot;cacheMillis&quot;</span>, cacheMillis);</span><br><span class="line">        result.put(<span class="string">&quot;lastRefTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        result.put(<span class="string">&quot;checksum&quot;</span>, service.getChecksum());</span><br><span class="line">        result.put(<span class="string">&quot;useSpecifiedURL&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        result.put(<span class="string">&quot;clusters&quot;</span>, clusters);</span><br><span class="line">        result.put(<span class="string">&quot;env&quot;</span>, env);</span><br><span class="line">        result.replace(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.transferToJsonNode(service.getMetadata()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h4 id="Server和Client之间的UDP通信"><a href="#Server和Client之间的UDP通信" class="headerlink" title="Server和Client之间的UDP通信"></a>Server和Client之间的UDP通信</h4><h5 id="服务端发送UDP推送"><a href="#服务端发送UDP推送" class="headerlink" title="服务端发送UDP推送"></a>服务端发送UDP推送</h5><p>我们在心跳请求哪里发现，如果实例的健康状况发生了变化，那么我们要把这个状态的变更通知到订阅者，这是居于Spring事件机制做的，发布这个事件之后会有一个处理器来处理，具体就是封装成UDP报文发送给client，client再发送一个ack。我们先来到修改实例健康状态的代码。进入serviceChanged方法，看看具体是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新这个实例最新的心跳事件</span></span><br><span class="line">instance.setLastBeat(System.currentTimeMillis());</span><br><span class="line"><span class="keyword">if</span> (!instance.isMarked() &amp;&amp; !instance.isHealthy()) &#123;</span><br><span class="line">    <span class="comment">// 如果不是临时节点 而且之前标记为不健康</span></span><br><span class="line">    <span class="comment">// 既然心跳都来了，那么就更新为健康的</span></span><br><span class="line">    instance.setHealthy(<span class="literal">true</span>);</span><br><span class="line">    Loggers.EVT_LOG</span><br><span class="line">        .info(<span class="string">&quot;service: &#123;&#125; &#123;POS&#125; &#123;IP-ENABLED&#125; valid: &#123;&#125;:&#123;&#125;@&#123;&#125;, region: &#123;&#125;, msg: client beat ok&quot;</span>,</span><br><span class="line">              cluster.getService().getName(), ip, port, cluster.getName(),</span><br><span class="line">              UtilsAndCommons.LOCALHOST_SITE);</span><br><span class="line">    <span class="comment">// 发布变更事件 后面分析UDP通知客户端</span></span><br><span class="line">    getPushService().serviceChanged(service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceChanged</span><span class="params">(Service service)</span> &#123;</span><br><span class="line">        <span class="comment">// merge some change events to reduce the push frequency:</span></span><br><span class="line">        <span class="keyword">if</span> (futureMap</span><br><span class="line">                .containsKey(UtilsAndCommons.assembleFullServiceName(service.getNamespaceId(), service.getName()))) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        <span class="built_in">this</span>.applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceChangeEvent</span>(<span class="built_in">this</span>, service));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一旦这个事件发生了，触发了com.alibaba.nacos.naming.push.PushService#onApplicationEvent方法，那就要分析这个方法做的是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ServiceChangeEvent event)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> event.getService();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> service.getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> service.getNamespaceId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个定时操作 异步执行相关内容 变化一次只执行一次</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> GlobalExecutor.scheduleUdpSender(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Loggers.PUSH.info(serviceName + <span class="string">&quot; is changed, add it to push queue.&quot;</span>);</span><br><span class="line">            <span class="comment">// 从缓存map中获取 udp client client订阅服务的时候已经放进去了</span></span><br><span class="line">            ConcurrentMap&lt;String, PushClient&gt; clients = clientMap</span><br><span class="line">                .get(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">            <span class="comment">// 没有UDP客户端，直接结束了</span></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isEmpty(clients)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 更新最后引用事件</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastRefTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="comment">// 遍历所有 UDPclient 进行UDP推送</span></span><br><span class="line">            <span class="keyword">for</span> (PushClient client : clients.values()) &#123;</span><br><span class="line">                <span class="comment">// 如果这个UDPclient是一个僵尸client 就移除他</span></span><br><span class="line">                <span class="keyword">if</span> (client.zombie()) &#123;</span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">&quot;client is zombie: &quot;</span> + client.toString());</span><br><span class="line">                    clients.remove(client.toString());</span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">&quot;client is zombie: &quot;</span> + client.toString());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Receiver.AckEntry ackEntry;</span><br><span class="line">                Loggers.PUSH.debug(<span class="string">&quot;push serviceName: &#123;&#125; to client: &#123;&#125;&quot;</span>, serviceName, client.toString());</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getPushCacheKey(serviceName, client.getIp(), client.getAgent());</span><br><span class="line">                <span class="type">byte</span>[] compressData = <span class="literal">null</span>;</span><br><span class="line">                Map&lt;String, Object&gt; data = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (switchDomain.getDefaultPushCacheMillis() &gt;= <span class="number">20000</span> &amp;&amp; cache.containsKey(key)) &#123;</span><br><span class="line">                    org.javatuples.<span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> (org.javatuples.Pair) cache.get(key);</span><br><span class="line">                    compressData = (<span class="type">byte</span>[]) (pair.getValue0());</span><br><span class="line">                    data = (Map&lt;String, Object&gt;) pair.getValue1();</span><br><span class="line"></span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">&quot;[PUSH-CACHE] cache hit: &#123;&#125;:&#123;&#125;&quot;</span>, serviceName, client.getAddrStr());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (compressData != <span class="literal">null</span>) &#123;</span><br><span class="line">                    ackEntry = prepareAckEntry(client, compressData, data, lastRefTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ackEntry = prepareAckEntry(client, prepareHostsData(client), lastRefTime);</span><br><span class="line">                    <span class="keyword">if</span> (ackEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">                        cache.put(key, <span class="keyword">new</span> <span class="title class_">org</span>.javatuples.Pair&lt;&gt;(ackEntry.origin.getData(), ackEntry.data));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Loggers.PUSH.info(<span class="string">&quot;serviceName: &#123;&#125; changed, schedule push for: &#123;&#125;, agent: &#123;&#125;, key: &#123;&#125;&quot;</span>,</span><br><span class="line">                                  client.getServiceName(), client.getAddrStr(), client.getAgent(),</span><br><span class="line">                                  (ackEntry == <span class="literal">null</span> ? <span class="literal">null</span> : ackEntry.key));</span><br><span class="line">                <span class="comment">// UDP Push给客户端</span></span><br><span class="line">                udpPush(ackEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.PUSH.error(<span class="string">&quot;[NACOS-PUSH] failed to push serviceName: &#123;&#125; to client, error: &#123;&#125;&quot;</span>, serviceName, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            futureMap.remove(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    futureMap.put(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName), future);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下具体的UDP推送方法也就是 udpPush(ackEntry)  其实就是调用JDK的方法发送UDP报文，然后失败重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Receiver.AckEntry <span class="title function_">udpPush</span><span class="params">(Receiver.AckEntry ackEntry)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (ackEntry == <span class="literal">null</span>) &#123;</span><br><span class="line">           Loggers.PUSH.error(<span class="string">&quot;[NACOS-PUSH] ackEntry is null.&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 超过重试次数 返回</span></span><br><span class="line">       <span class="keyword">if</span> (ackEntry.getRetryTimes() &gt; MAX_RETRY_TIMES) &#123;</span><br><span class="line">           Loggers.PUSH.warn(<span class="string">&quot;max re-push times reached, retry times &#123;&#125;, key: &#123;&#125;&quot;</span>, ackEntry.retryTimes, ackEntry.key);</span><br><span class="line">           ackMap.remove(ackEntry.key);</span><br><span class="line">           udpSendTimeMap.remove(ackEntry.key);</span><br><span class="line">           failedPush += <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">return</span> ackEntry;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!ackMap.containsKey(ackEntry.key)) &#123;</span><br><span class="line">               totalPush++;</span><br><span class="line">           &#125;</span><br><span class="line">           ackMap.put(ackEntry.key, ackEntry);</span><br><span class="line">           udpSendTimeMap.put(ackEntry.key, System.currentTimeMillis());</span><br><span class="line">           </span><br><span class="line">           Loggers.PUSH.info(<span class="string">&quot;send udp packet: &quot;</span> + ackEntry.key);</span><br><span class="line">           <span class="comment">// 发送UDP报文 JDK层面的东西</span></span><br><span class="line">           udpSocket.send(ackEntry.origin);</span><br><span class="line">           </span><br><span class="line">           ackEntry.increaseRetryTime();</span><br><span class="line">           <span class="comment">// 推送失败后，重试发送UDP报文</span></span><br><span class="line">           GlobalExecutor.scheduleRetransmitter(<span class="keyword">new</span> <span class="title class_">Retransmitter</span>(ackEntry),</span><br><span class="line">                   TimeUnit.NANOSECONDS.toMillis(ACK_TIMEOUT_NANOS), TimeUnit.MILLISECONDS);</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> ackEntry;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.PUSH.error(<span class="string">&quot;[NACOS-PUSH] failed to push data: &#123;&#125; to client: &#123;&#125;, error: &#123;&#125;&quot;</span>, ackEntry.data,</span><br><span class="line">                   ackEntry.origin.getAddress().getHostAddress(), e);</span><br><span class="line">           ackMap.remove(ackEntry.key);</span><br><span class="line">           udpSendTimeMap.remove(ackEntry.key);</span><br><span class="line">           failedPush += <span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="客户端收到UDP报文的处理"><a href="#客户端收到UDP报文的处理" class="headerlink" title="客户端收到UDP报文的处理"></a>客户端收到UDP报文的处理</h5><p>只要服务变更，Server发送消息是遍历订阅这个服务的所有client，那么客户端一定有相应的处理，接下来就分析客户端是怎么处理UDP报文的。实际是client是有一个线程轮训处理的。其实在客户端启动的时候会调用这个方法org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration#onApplicationEvent，他做的事情就是在tomcat容器启动的时候就执行对应的方法，类似事件监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// webserver初始化结束事件</span></span><br><span class="line">bind(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(WebServerInitializedEvent event)</span> &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> event.getApplicationContext();</span><br><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebServerApplicationContext) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;management&quot;</span>.equals(((ConfigurableWebServerApplicationContext) context)</span><br><span class="line">.getServerNamespace())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.port.compareAndSet(<span class="number">0</span>, event.getWebServer().getPort());</span><br><span class="line"><span class="built_in">this</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中最重要的就是最后那个注册启动的方法，接着我们来看看，过滤掉一些不重要的信息，可以看到在这里是执行了一个注册方法，所以我们还要来到注册方法内部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Discovery Lifecycle disabled. Not starting&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only initialize if nonSecurePort is greater than 0 and it isn&#x27;t already running</span></span><br><span class="line"><span class="comment">// because of containerPortInitializer below</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.running.get()) &#123;</span><br><span class="line"><span class="built_in">this</span>.context.publishEvent(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InstancePreRegisteredEvent</span>(<span class="built_in">this</span>, getRegistration()));</span><br><span class="line">register();</span><br><span class="line"><span class="keyword">if</span> (shouldRegisterManagement()) &#123;</span><br><span class="line">registerManagement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.context.publishEvent(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InstanceRegisteredEvent</span>&lt;&gt;(<span class="built_in">this</span>, getConfiguration()));</span><br><span class="line"><span class="built_in">this</span>.running.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到register()方法内部，最终调用的是com.alibaba.cloud.nacos.registry.NacosServiceRegistry#register，然后定位到最终调用注册的方法，大概就是从配置文件中获取服务信息，发送post请求，同时启动一个心跳定时任务，其实这些东西前面已经分析过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NamingService</span> <span class="variable">namingService</span> <span class="operator">=</span> namingService();</span><br><span class="line"><span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> registration.getServiceId();</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> nacosDiscoveryProperties.getGroup();</span><br><span class="line"></span><br><span class="line"><span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">instance.getIp(), instance.getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">registration.toString(), e);</span><br><span class="line"><span class="comment">// rethrow a RuntimeException if the registration is failed.</span></span><br><span class="line"><span class="comment">// issue : https://github.com/alibaba/spring-cloud-alibaba/issues/1132</span></span><br><span class="line">rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重要是namingService.registerInstance(serviceId, group, instance);</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        serverProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以注意到上面有一个创建的方法即 NamingService namingService &#x3D; namingService()，其实内部是使用了NacosServiceManager通过反射调用了NamingService的构造方法来执行的，那我们直接定位到NamingService的构造方法，这里一定是执行了NamingService的初始化操作。在最后看到了有一个处理host的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="title function_">NacosNamingService</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        init(properties);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    ValidatorUtils.checkInitParam(properties);</span><br><span class="line">    <span class="built_in">this</span>.namespace = InitUtils.initNamespaceForNaming(properties);</span><br><span class="line">    InitUtils.initSerialization();</span><br><span class="line">    initServerAddr(properties);</span><br><span class="line">    InitUtils.initWebRootContext(properties);</span><br><span class="line">    initCacheDir();</span><br><span class="line">    initLogName(properties);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.serverProxy = <span class="keyword">new</span> <span class="title class_">NamingProxy</span>(<span class="built_in">this</span>.namespace, <span class="built_in">this</span>.endpoint, <span class="built_in">this</span>.serverList, properties);</span><br><span class="line">    <span class="built_in">this</span>.beatReactor = <span class="keyword">new</span> <span class="title class_">BeatReactor</span>(<span class="built_in">this</span>.serverProxy, initClientBeatThreadCount(properties));</span><br><span class="line">    <span class="comment">// 这里就是创建一个线程池来处理</span></span><br><span class="line">    <span class="built_in">this</span>.hostReactor = <span class="keyword">new</span> <span class="title class_">HostReactor</span>(<span class="built_in">this</span>.serverProxy, beatReactor, <span class="built_in">this</span>.cacheDir, isLoadCacheAtStart(properties),</span><br><span class="line">            isPushEmptyProtect(properties), initPollingThreadCount(properties));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入这个线程池的初始化代码内部，看到有一个关键信息就是创建一个PushReceiver来处理UDP推送信息。最后就来看看这个pushReceiver是怎么处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HostReactor</span><span class="params">(NamingProxy serverProxy, BeatReactor beatReactor, String cacheDir, <span class="type">boolean</span> loadCacheAtStart,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> pushEmptyProtection, <span class="type">int</span> pollingThreadCount)</span> &#123;</span><br><span class="line">       <span class="comment">// init executorService</span></span><br><span class="line">       <span class="built_in">this</span>.executor = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(pollingThreadCount, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">               <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">               thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">               thread.setName(<span class="string">&quot;com.alibaba.nacos.client.naming.updater&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> thread;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">this</span>.beatReactor = beatReactor;</span><br><span class="line">       <span class="built_in">this</span>.serverProxy = serverProxy;</span><br><span class="line">       <span class="built_in">this</span>.cacheDir = cacheDir;</span><br><span class="line">       <span class="keyword">if</span> (loadCacheAtStart) &#123;</span><br><span class="line">           <span class="built_in">this</span>.serviceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ServiceInfo&gt;(DiskCache.read(<span class="built_in">this</span>.cacheDir));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.serviceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ServiceInfo&gt;(<span class="number">16</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">this</span>.pushEmptyProtection = pushEmptyProtection;</span><br><span class="line">       <span class="built_in">this</span>.updatingMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;();</span><br><span class="line">       <span class="built_in">this</span>.failoverReactor = <span class="keyword">new</span> <span class="title class_">FailoverReactor</span>(<span class="built_in">this</span>, cacheDir);</span><br><span class="line">    <span class="comment">// 处理server 的UDP推送</span></span><br><span class="line">       <span class="built_in">this</span>.pushReceiver = <span class="keyword">new</span> <span class="title class_">PushReceiver</span>(<span class="built_in">this</span>);</span><br><span class="line">       <span class="built_in">this</span>.notifier = <span class="keyword">new</span> <span class="title class_">InstancesChangeNotifier</span>();</span><br><span class="line">       </span><br><span class="line">       NotifyCenter.registerToPublisher(InstancesChangeEvent.class, <span class="number">16384</span>);</span><br><span class="line">       NotifyCenter.registerSubscriber(notifier);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入pushReceiver，他是一个线程直接看run方法，可以看到它就是一个线程，然后做的事情就是获取UDP包，解析称为JSON然后把Nacos Server上面变更的service写入到本地，然后发送给服务器一个ack。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PushReceiver</span><span class="params">(HostReactor hostReactor)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.hostReactor = hostReactor;</span><br><span class="line">           <span class="built_in">this</span>.udpSocket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">           <span class="comment">// 创建一个线程池</span></span><br><span class="line">           <span class="built_in">this</span>.executorService = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                   <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                   thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                   thread.setName(<span class="string">&quot;com.alibaba.nacos.naming.push.receiver&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span> thread;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="comment">// 异步执行当前PushReceiver任务</span></span><br><span class="line">           <span class="built_in">this</span>.executorService.execute(<span class="built_in">this</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           NAMING_LOGGER.error(<span class="string">&quot;[NA] init udp socket failed&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (!closed) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// byte[] is initialized with 0 full filled by default</span></span><br><span class="line">               <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[UDP_MSS];</span><br><span class="line">               <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">               <span class="comment">// 接受来自server的UDP包 并封装</span></span><br><span class="line">               udpSocket.receive(packet);</span><br><span class="line">               <span class="comment">// 将数据解码称为JSON</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(IoUtils.tryDecompress(packet.getData()), UTF_8).trim();</span><br><span class="line">               NAMING_LOGGER.info(<span class="string">&quot;received push data: &quot;</span> + json + <span class="string">&quot; from &quot;</span> + packet.getAddress().toString());</span><br><span class="line">               </span><br><span class="line">               <span class="type">PushPacket</span> <span class="variable">pushPacket</span> <span class="operator">=</span> JacksonUtils.toObj(json, PushPacket.class);</span><br><span class="line">               String ack;</span><br><span class="line">               <span class="comment">// 根据不同的数据类型，返回到server不同的ack</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="string">&quot;dom&quot;</span>.equals(pushPacket.type) || <span class="string">&quot;service&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                   <span class="comment">// 将来自server的发生变更的service更新到当前Naocs Client本地注册表中</span></span><br><span class="line">                   hostReactor.processServiceJson(pushPacket.data);</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">// send ack to server</span></span><br><span class="line">                   ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;push-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;:\&quot;&quot;</span> + pushPacket.lastRefTime + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span></span><br><span class="line">                           + <span class="string">&quot;\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;dump&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                   <span class="comment">// dump data to server</span></span><br><span class="line">                   ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;dump-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;: \&quot;&quot;</span> + pushPacket.lastRefTime + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span></span><br><span class="line">                           + <span class="string">&quot;\&quot;&quot;</span> + StringUtils.escapeJavaScript(JacksonUtils.toJson(hostReactor.getServiceInfoMap()))</span><br><span class="line">                           + <span class="string">&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// do nothing send ack only</span></span><br><span class="line">                   ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;unknown-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;:\&quot;&quot;</span> + pushPacket.lastRefTime</span><br><span class="line">                           + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span> + <span class="string">&quot;\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 返回ack到server</span></span><br><span class="line">               udpSocket.send(<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(ack.getBytes(UTF_8), ack.getBytes(UTF_8).length,</span><br><span class="line">                       packet.getSocketAddress()));</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               NAMING_LOGGER.error(<span class="string">&quot;[NA] error while receiving push data&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Server间通信"><a href="#Server间通信" class="headerlink" title="Server间通信"></a>Server间通信</h4><p>Nacos在启动的时候会进行3项重要操作</p><ol><li>启动一个定时任务，每60S当前Server会向其他Nacos Server发送一次本地注册表</li><li>会从其他Nacos Server获取的注册表中的所有instance的状态，并更新到本地</li><li>启动一个定时任务，60S之后执行，每20S清理一次注册表中的空Service</li></ol><p>结论就是，ServerManager在创建的时候通过后置处理器初始化了这三个任务，我们直接来看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Init service maneger.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 第一项任务，上报本地注册表 本季注册表是以校验和方式发送</span></span><br><span class="line">       GlobalExecutor.scheduleServiceReporter(<span class="keyword">new</span> <span class="title class_">ServiceReporter</span>(), <span class="number">60000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">// 从其他nacos实例获取最新状态</span></span><br><span class="line">       GlobalExecutor.submitServiceUpdateManager(<span class="keyword">new</span> <span class="title class_">UpdatedServiceProcessor</span>());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (emptyServiceAutoClean) &#123;</span><br><span class="line"></span><br><span class="line">           Loggers.SRV_LOG.info(<span class="string">&quot;open empty service auto clean job, initialDelay : &#123;&#125; ms, period : &#123;&#125; ms&quot;</span>,</span><br><span class="line">                   cleanEmptyServiceDelay, cleanEmptyServicePeriod);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// delay 60s, period 20s;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// This task is not recommended to be performed frequently in order to avoid</span></span><br><span class="line">           <span class="comment">// the possibility that the service cache information may just be deleted</span></span><br><span class="line">           <span class="comment">// and then created due to the heartbeat mechanism</span></span><br><span class="line"><span class="comment">// 清除注册表中的空service</span></span><br><span class="line">           <span class="comment">// 会操作这个集群</span></span><br><span class="line">           GlobalExecutor.scheduleServiceAutoClean(<span class="keyword">new</span> <span class="title class_">EmptyServiceAutoClean</span>(), cleanEmptyServiceDelay,</span><br><span class="line">                   cleanEmptyServicePeriod);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Loggers.SRV_LOG.info(<span class="string">&quot;listen for service meta change&quot;</span>);</span><br><span class="line">           consistencyService.listen(KeyBuilder.SERVICE_META_KEY_PREFIX, <span class="built_in">this</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.error(<span class="string">&quot;listen for service meta change failed!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="上报本地注册表任务"><a href="#上报本地注册表任务" class="headerlink" title="上报本地注册表任务"></a>上报本地注册表任务</h5><p>上报注册表任务一看就知道是一个定时任务，我们来看一下这个任务具体的run方法。就是遍历所有的名称空间下的所有的服务，然后针对这些服务生成校验和，然后获取Nacos服务列表，发送出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// key=namespaceId value是一个集合，集合中是当前namespace中的所有的service的名称</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; allServiceNames = getAllServiceNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allServiceNames.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String namespaceId : allServiceNames.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServiceChecksum</span> <span class="variable">checksum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceChecksum</span>(namespaceId);</span><br><span class="line"><span class="comment">// namespaceId -&gt; 所有的服务名称</span></span><br><span class="line">            <span class="comment">// 遍历所有的namespace </span></span><br><span class="line">            <span class="keyword">for</span> (String serviceName : allServiceNames.get(namespaceId)) &#123;</span><br><span class="line">                <span class="comment">// 若当前服务不归当前server负责就跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!distroMapper.responsible(serviceName)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 从注册表中获取当前遍历的服务</span></span><br><span class="line">                <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (service == <span class="literal">null</span> || service.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 计算校验和</span></span><br><span class="line">                service.recalculateChecksum();</span><br><span class="line"><span class="comment">// 将计算好的校验和放入map</span></span><br><span class="line">                checksum.addItem(serviceName, service.getChecksum());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 发给其他服务器的时候 发送是这个</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line"><span class="comment">// 将当前namespace所有服务的校验和封装进去</span></span><br><span class="line">            msg.setData(JacksonUtils.toJson(checksum));</span><br><span class="line"><span class="comment">// 获取到所有的nacos</span></span><br><span class="line">            Collection&lt;Member&gt; sameSiteServers = memberManager.allMembers();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sameSiteServers == <span class="literal">null</span> || sameSiteServers.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 遍历发送</span></span><br><span class="line">            <span class="keyword">for</span> (Member server : sameSiteServers) &#123;</span><br><span class="line">                <span class="comment">// 跳过当前server</span></span><br><span class="line">                <span class="keyword">if</span> (server.getAddress().equals(NetUtils.localServer())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 同步器发送</span></span><br><span class="line">                synchronizer.send(server.getAddress(), msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.SRV_LOG.error(<span class="string">&quot;[DOMAIN-STATUS] Exception while sending service status&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        GlobalExecutor.scheduleServiceReporter(<span class="built_in">this</span>, switchDomain.getServiceStatusSynchronizationPeriodMillis(),</span><br><span class="line">                                               TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续分析一下发送状态同步是怎么做的，这就要研究 synchronizer.send(server.getAddress(), msg)这个方法了，进入方法内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String serverIP, Message msg)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (serverIP == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">10</span>);</span><br><span class="line">       </span><br><span class="line">       params.put(<span class="string">&quot;statuses&quot;</span>, msg.getData());</span><br><span class="line">       params.put(<span class="string">&quot;clientIP&quot;</span>, NetUtils.localServer());</span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://&quot;</span> + serverIP + <span class="string">&quot;:&quot;</span> + EnvUtil.getPort() + EnvUtil.getContextPath()</span><br><span class="line">               + UtilsAndCommons.NACOS_NAMING_CONTEXT + <span class="string">&quot;/service/status&quot;</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (IPUtil.containsPort(serverIP)) &#123;</span><br><span class="line">           url = <span class="string">&quot;http://&quot;</span> + serverIP + EnvUtil.getContextPath() + UtilsAndCommons.NACOS_NAMING_CONTEXT</span><br><span class="line">                   + <span class="string">&quot;/service/status&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 发送Post请求</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           HttpClient.asyncHttpPostLarge(url, <span class="literal">null</span>, JacksonUtils.toJson(params), <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;String&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(RestResult&lt;String&gt; result)</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!result.ok()) &#123;</span><br><span class="line">                       Loggers.SRV_LOG.warn(<span class="string">&quot;[STATUS-SYNCHRONIZE] failed to request serviceStatus, remote server: &#123;&#125;&quot;</span>,</span><br><span class="line">                               serverIP);</span><br><span class="line">       </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                   Loggers.SRV_LOG.warn(<span class="string">&quot;[STATUS-SYNCHRONIZE] failed to request serviceStatus, remote server: &quot;</span> + serverIP, throwable);</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancel</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Loggers.SRV_LOG.warn(<span class="string">&quot;[STATUS-SYNCHRONIZE] failed to request serviceStatus, remote server: &quot;</span> + serverIP, e);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="从其他Nacos获取最新注册表并更新到本地"><a href="#从其他Nacos获取最新注册表并更新到本地" class="headerlink" title="从其他Nacos获取最新注册表并更新到本地"></a>从其他Nacos获取最新注册表并更新到本地</h5><p>开始分析第二个任务，这个任务不是定时任务而是一个无限循环，从队列里面取出来一个发生了状态变更的service，然后启动一个线程来处理更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UpdatedServiceProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get changed service from other server asynchronously</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceKey</span> <span class="variable">serviceKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他服务发生了变更，全都放在这个队列中</span></span><br><span class="line">                    <span class="comment">// 从这个队列里面取出来一个状态发生了变更的服务</span></span><br><span class="line">                    serviceKey = toBeUpdatedServicesQueue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Loggers.EVT_LOG.error(<span class="string">&quot;[UPDATE-DOMAIN] Exception while taking item from LinkedBlockingDeque.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (serviceKey == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 另外启动一个线程来完成一个ServiceUpdate任务，</span></span><br><span class="line">                GlobalExecutor.submitServiceUpdate(<span class="keyword">new</span> <span class="title class_">ServiceUpdater</span>(serviceKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.EVT_LOG.error(<span class="string">&quot;[UPDATE-DOMAIN] Exception while update service: &#123;&#125;&quot;</span>, serviceKey, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>进入ServiceUpdater这个类，这个类是一个线程类，重点就是看一下run方法，内部调用的是updatedHealthStatus(namespaceId, serviceName, serverIP)，所以还要点进去看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ServiceUpdater</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        String namespaceId;</span><br><span class="line"></span><br><span class="line">        String serviceName;</span><br><span class="line"></span><br><span class="line">        String serverIP;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ServiceUpdater</span><span class="params">(ServiceKey serviceKey)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.namespaceId = serviceKey.getNamespaceId();</span><br><span class="line">            <span class="built_in">this</span>.serviceName = serviceKey.getServiceName();</span><br><span class="line">            <span class="built_in">this</span>.serverIP = serviceKey.getServerIP();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                updatedHealthStatus(namespaceId, serviceName, serverIP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Loggers.SRV_LOG</span><br><span class="line">                        .warn(<span class="string">&quot;[DOMAIN-UPDATER] Exception while update service: &#123;&#125; from &#123;&#125;, error: &#123;&#125;&quot;</span>, serviceName,</span><br><span class="line">                                serverIP, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的更新方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Update health status of instance in service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> namespaceId namespace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName service name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverIP    source server Ip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatedHealthStatus</span><span class="params">(String namespaceId, String serviceName, String serverIP)</span> &#123;</span><br><span class="line">   <span class="comment">// 同步器从其他server获取指定服务的数据</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> synchronizer.get(serverIP, UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">    <span class="type">JsonNode</span> <span class="variable">serviceJson</span> <span class="operator">=</span> JacksonUtils.toObj(msg.getData());</span><br><span class="line"><span class="comment">// 过去这个服务所有的实例</span></span><br><span class="line">    <span class="type">ArrayNode</span> <span class="variable">ipList</span> <span class="operator">=</span> (ArrayNode) serviceJson.get(<span class="string">&quot;ips&quot;</span>);</span><br><span class="line">    <span class="comment">// 这个map是存的是所有的instance的健康状态</span></span><br><span class="line">    <span class="comment">// key -&gt; ip+port value = healthy </span></span><br><span class="line">    Map&lt;String, String&gt; ipsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(ipList.size());</span><br><span class="line">    <span class="comment">// 遍历实例</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ipList.size(); i++) &#123;</span><br><span class="line"><span class="comment">// 格式是 ip:prot_healthy</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ipList.get(i).asText();</span><br><span class="line">        String[] strings = ip.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="comment">// 将遍历的instance的地址和健康状态放入map</span></span><br><span class="line">        ipsMap.put(strings[<span class="number">0</span>], strings[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从注册表中获取当前服务的</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 当前注册表中该服务所有instance</span></span><br><span class="line">    List&lt;Instance&gt; instances = service.allIPs();</span><br><span class="line">    <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line"><span class="comment">//获取来自于其他nacos该服务的所有instance</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> Boolean.parseBoolean(ipsMap.get(instance.toIpAddr()));</span><br><span class="line">        <span class="comment">// 如果当前注册表中的instance的状态和外来的不一致</span></span><br><span class="line">        <span class="keyword">if</span> (valid != instance.isHealthy()) &#123;</span><br><span class="line">            <span class="comment">// 发生变更 以外来的为准</span></span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            instance.setHealthy(valid);</span><br><span class="line">            Loggers.EVT_LOG.info(<span class="string">&quot;&#123;&#125; &#123;SYNC&#125; IP-&#123;&#125; : &#123;&#125;:&#123;&#125;@&#123;&#125;&quot;</span>, serviceName,</span><br><span class="line">                                 (instance.isHealthy() ? <span class="string">&quot;ENABLED&quot;</span> : <span class="string">&quot;DISABLED&quot;</span>), instance.getIp(), instance.getPort(),</span><br><span class="line">                                 instance.getClusterName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 只要有一个发生变更了 </span></span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="comment">// 向client发送推送 详见服务端发送UDP推送</span></span><br><span class="line">        pushService.serviceChanged(service);</span><br><span class="line">        <span class="keyword">if</span> (Loggers.EVT_LOG.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            List&lt;Instance&gt; allIps = service.allIPs();</span><br><span class="line">            <span class="keyword">for</span> (Instance instance : allIps) &#123;</span><br><span class="line">                stringBuilder.append(instance.toIpAddr()).append(<span class="string">&quot;_&quot;</span>).append(instance.isHealthy()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Loggers.EVT_LOG</span><br><span class="line">                .debug(<span class="string">&quot;[HEALTH-STATUS-UPDATED] namespace: &#123;&#125;, service: &#123;&#125;, ips: &#123;&#125;&quot;</span>, service.getNamespaceId(),</span><br><span class="line">                       service.getName(), stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定时清理空Service"><a href="#定时清理空Service" class="headerlink" title="定时清理空Service"></a>定时清理空Service</h5><p>第三个任务是一个典型的定时任务，开启后60S后执行，每20S执行一次，来看看具体是怎么做空Service清除的。主要做事情有几步：</p><ol><li>遍历所有的service取出来当前服务负责的</li><li>如果某个服务是空的，那么不要直接删除而是看它被判定为空的次数是不是大于阈值3</li><li>删除服务并且通过同步服务通知到其他Nacos Server</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空Service即为没有instance的Service</span></span><br><span class="line">GlobalExecutor.scheduleServiceAutoClean(<span class="keyword">new</span> <span class="title class_">EmptyServiceAutoClean</span>(), cleanEmptyServiceDelay,</span><br><span class="line">        cleanEmptyServicePeriod);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parallel flow opening threshold</span></span><br><span class="line"><span class="comment">// 这是一个并行流的阈值，一个namespace下的service数量超过100的时候，会将注册表创建为一个并行流</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parallelSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">// serviceMap就是注册表内层map</span></span><br><span class="line">    serviceMap.forEach((namespace, stringServiceMap) -&gt; &#123;</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Service&gt;&gt; stream = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果当前遍历的这个元素（namespace），包含的服务的数量超出了并行流阈值</span></span><br><span class="line">        <span class="comment">// 生产一个并行流</span></span><br><span class="line">        <span class="keyword">if</span> (stringServiceMap.size() &gt; parallelSize) &#123;</span><br><span class="line">            stream = stringServiceMap.entrySet().parallelStream();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stream = stringServiceMap.entrySet().stream();</span><br><span class="line">        &#125;</span><br><span class="line">        stream.filter(entry -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">// 当前遍历的服务是需要当前server负责的，通过过滤</span></span><br><span class="line">            <span class="keyword">return</span> distroMapper.responsible(serviceName);</span><br><span class="line">            <span class="comment">// 这里处理的server一定就是当前server负责的</span></span><br><span class="line">            <span class="comment">// 元素不空则进行操作 -&gt; </span></span><br><span class="line">        &#125;).forEach(entry -&gt; stringServiceMap.computeIfPresent(entry.getKey(), (serviceName, service) -&gt; &#123;</span><br><span class="line">           <span class="comment">// 这个服务是空的</span></span><br><span class="line">            <span class="keyword">if</span> (service.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// To avoid violent Service removal, the number of times the Service</span></span><br><span class="line">                <span class="comment">// experiences Empty is determined by finalizeCnt, and if the specified</span></span><br><span class="line">                <span class="comment">// value is reached, it is removed</span></span><br><span class="line"><span class="comment">// service.getFinalizeCount() -&gt; 记录的是这个service被判断为空的次数 3次 </span></span><br><span class="line">                <span class="comment">// 为空的次数超过了最大允许值，就删除这个服务</span></span><br><span class="line">                <span class="keyword">if</span> (service.getFinalizeCount() &gt; maxFinalizeCount) &#123;</span><br><span class="line">                    Loggers.SRV_LOG.warn(<span class="string">&quot;namespace : &#123;&#125;, [&#123;&#125;] services are automatically cleaned&quot;</span>, namespace,</span><br><span class="line">                                         serviceName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 通过同步服务remove</span></span><br><span class="line">                        easyRemoveService(namespace, serviceName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Loggers.SRV_LOG.error(<span class="string">&quot;namespace : &#123;&#125;, [&#123;&#125;] services are automatically clean has &quot;</span></span><br><span class="line">                                              + <span class="string">&quot;error : &#123;&#125;&quot;</span>, namespace, serviceName, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 计数器+1</span></span><br><span class="line">                service.setFinalizeCount(service.getFinalizeCount() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                Loggers.SRV_LOG</span><br><span class="line">                    .debug(<span class="string">&quot;namespace : &#123;&#125;, [&#123;&#125;] The number of times the current service experiences &quot;</span></span><br><span class="line">                           + <span class="string">&quot;an empty instance is : &#123;&#125;&quot;</span>, namespace, serviceName,</span><br><span class="line">                           service.getFinalizeCount());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不为空的话就把判定为空的次数设置为0</span></span><br><span class="line">                service.setFinalizeCount(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个步骤在这个方法中已经体现了，现在还有一点不情况的是如何通过同步服务通知到其他Nacos Server，就是用的同步服务的remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">easyRemoveService</span><span class="params">(String namespaceId, String serviceName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getService(namespaceId, serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;specified service not exist, serviceName : &quot;</span> + serviceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consistencyService.remove(KeyBuilder.buildServiceMetaKey(namespaceId, serviceName));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos-Tutorial&quot;&gt;&lt;a href=&quot;#Nacos-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;Nacos Tutorial&quot;&gt;&lt;/a&gt;Nacos Tutorial&lt;/h1&gt;&lt;h2 id=&quot;Nacos总览&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
    <category term="SpringCloud Alibaba" scheme="http://example.com/tags/SpringCloud-Alibaba/"/>
    
  </entry>
  
</feed>
